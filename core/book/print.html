<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cairo Core Library Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Core Library Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-the-cairo-core-library"><a class="header" href="#what-is-the-cairo-core-library">What is the Cairo core library?</a></h2>
<p>The Cairo core library provides the foundational building blocks for writing provable programs in Cairo. It offers essential utilities, data structures, mathematical functions, cryptographic tools, and system interactions making it suitable for both onchain and offchain development. Whether you are working on Starknet smart contracts, cryptographic applications, or general-purpose Cairo programs, the core library provides the fundamental tools needed.</p>
<p>you can access modules from the corelib in your program via the core prefix as follows</p>
<p>The core library is available to all  Cairo packages by default, meaning its features are available by simply importing specific modules into your program as follows:</p>
<pre><code class="language-rust">use core::array::Array;

fn main() {
    let mut arr = Array::new();
    arr.append(42);
}</code></pre>
<h2 id="how-to-use-this-documentation"><a class="header" href="#how-to-use-this-documentation">How to use this documentation?</a></h2>
<p>This documentation serves as a comprehensive reference for all components of the Cairo Core Library. It organizes functionality into modules, constants, functions, types, and traits, allowing developers to explore and understand available features efficiently. It is auto-generated from the core library's codebase using <a href="https://docs.swmansion.com/scarb/docs/extensions/documentation-generation.html">Scarb</a>, so if you find a bug, have a feature request, or want to improve the documentation, simply report an issue or submit a pull request on either <a href="https://github.com/starkware-libs/cairo">Cairo's</a> or <a href="https://github.com/software-mansion/scarb">Scarb's</a> GitHub repositories.</p>
<p>If you already know what you are looking for, the fastest way to find it is to use the search bar at the top of the page. Otherwise, you can take <a href="intro.html#a-quick-tour-of-the-documentation">a quick tour of the documentation</a> and start clicking on anything the seems interesting. If this is your first time, we recommend starting with browsing the library's modules and experimenting with their functionality in your Cairo programs.</p>
<p>Happy coding! ð“…ƒ</p>
<h2 id="a-quick-tour-of-the-documentation"><a class="header" href="#a-quick-tour-of-the-documentation">A quick tour of the documentation</a></h2>
<p>This documentation is structured into the following sections:</p>
<ul>
<li>
<p><a href="./modules.html">Modules</a> â€“ The main building blocks of the library
This section includes all standard modules, each serving a distinct purpose:</p>
<ul>
<li>
<p>Core Utilities:</p>
<ul>
<li><code>core</code> â€“ The base module with essential utilities</li>
<li><code>traits</code> â€“ Common behavior definitions used across multiple types</li>
<li><code>boolean</code> â€“ Boolean logic operations</li>
<li><code>array</code> â€“ Dynamic data structures for storing and managing sequences of values</li>
<li><code>dict</code> â€“ Key-value storage structures</li>
<li><code>option</code> â€“ Represents optional values</li>
<li><code>result</code> â€“ Used for error handling</li>
</ul>
</li>
<li>
<p>Numerical and Mathematical Modules:</p>
<ul>
<li><code>integer</code> â€“ Fixed-size integer operations (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, etc.)</li>
<li><code>math</code> â€“ Core mathematical functions</li>
<li><code>ops</code> â€“ Arithmetic and logical operators</li>
<li><code>num</code> â€“ Numeric utilities and traits</li>
<li><code>cmp</code> â€“ Comparisons and ordering</li>
</ul>
</li>
<li>
<p>Cryptography and Hashing:</p>
<ul>
<li><code>hash</code> â€“ Generic hash utilities.</li>
<li><code>poseidon</code>, <code>pedersen</code>, <code>keccak</code>, <code>sha256</code> â€“ Cryptographic hash functions</li>
<li><code>ecdsa</code> â€“ Signature verification and elliptic curve cryptography</li>
</ul>
</li>
<li>
<p>Starknet-Specific Modules:</p>
<ul>
<li><code>starknet</code> â€“ Essential utilities for writing smart contracts</li>
<li><code>syscalls</code> â€“ Low-level Starknet system interactions</li>
<li><code>storage</code> â€“ On-chain storage management</li>
<li><code>event</code> â€“ Emitting events for contract execution tracking</li>
<li><code>contract_address</code> â€“ Starknet contract address utilities</li>
<li><code>account</code> â€“ Account contract functionality</li>
</ul>
</li>
<li>
<p>Other Utilities:</p>
<ul>
<li><code>debug</code> â€“ Debugging tools</li>
<li><code>fmt</code> â€“ String formatting utilities</li>
<li><code>serde</code> â€“ Serialization and deserialization</li>
<li><code>metaprogramming</code> â€“ Advanced compile-time utilities</li>
<li><code>zeroable</code> â€“ Zero-initialized types</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Constants â€“ Predefined values for cryptographic and mathematical operations, , such as:</p>
<ul>
<li><code>stark_curve::ALPHA, BETA, ORDER</code> â€“ Constants for Stark curve operations</li>
<li><code>starknet::VALIDATED</code> â€“ The expected return value of a Starknet account's <code>__validate__</code> function in case of success</li>
</ul>
</li>
<li>
<p>Free Functions â€“ Globally accessible functions that donâ€™t belong to a specific trait, such as:</p>
<ul>
<li><code>panic_with_felt252</code> â€“ Triggers a panic with a given value</li>
<li><code>get_tx_info</code> â€“ Returns the transaction info (hash, signature, etc.) for the current transaction</li>
</ul>
</li>
<li>
<p>Structs â€“ Data structures used throughout Cairo programs, such as:</p>
<ul>
<li><code>Span&lt;T&gt;</code> â€“ A lightweight view over a contiguous memory block</li>
<li><code>Range&lt;T&gt;</code> â€“ Represents a range of values</li>
<li><code>BlockInfo</code>, <code>TxInfo</code>, <code>ExecutionInfo</code> â€“ Used for retrieving Starknet execution details</li>
<li><code>EventEmitter</code> â€“ Helps in emitting events from contracts</li>
</ul>
</li>
<li>
<p>Enums â€“ Enumerations for handling multiple possible values, such as:</p>
<ul>
<li><code>Option&lt;T&gt;</code> â€“ Represents either <code>Some(value)</code> or None</li>
<li><code>Result&lt;T, E&gt;</code> â€“ Represents either <code>Ok(value)</code> or <code>Err(error)</code></li>
<li><code>PanicResult</code> â€“ Handles different types of panics in execution.</li>
</ul>
</li>
<li>
<p>Type Aliases â€“ Shorthand for commonly used types, such as:</p>
<ul>
<li><code>usize</code> â€“ Represents an unsigned integer type used for indexing</li>
<li><code>SyscallResult&lt;T&gt;</code> â€“ A standardized way of handling syscall return values</li>
<li><code>NonZeroEcPoint</code> â€“ Ensures that an elliptic curve point is non-zero</li>
</ul>
</li>
<li>
<p>Traits â€“ Shared behavior implementations for different types, such as:</p>
<ul>
<li><code>PartialEq</code>, <code>PartialOrd</code> â€“ Used for comparisons</li>
<li><code>Iterator</code>, <code>IntoIterator</code> â€“ Traits for iterating over collections</li>
<li><code>Serialize</code>, <code>Deserialize</code> â€“ Serialization and deserialization behaviors</li>
</ul>
</li>
<li>
<p>Impls â€“ Concrete implementations of traits for various types, such as:</p>
<ul>
<li><code>CircuitElementDrop</code>, <code>CircuitElementCopy</code> â€“ Implementations for circuit computations</li>
<li><code>SpanIndex</code> â€“ Allows indexing into <code>Span&lt;T&gt;</code></li>
<li><code>PedersenImpl</code>, <code>PoseidonImpl</code> â€“ Implementations for cryptographic hashing</li>
</ul>
</li>
<li>
<p>Extern Types â€“ Sierra types that are usable in high-level Cairo, such as:</p>
<ul>
<li><code>Array&lt;T&gt;</code> â€“ A collection of elements of the same type continuous in memory.</li>
<li><code>Box&lt;T&gt;</code> â€“ A wrapper that enables moving the type around of cheaply</li>
<li><code>bytes31&lt;T&gt;</code> â€“ Represents a 31-byte fixed-size byte type.</li>
</ul>
</li>
<li>
<p>Extern Functions â€“ Sierra libfuncs that are usable in high-level Cairo, such as:</p>
<ul>
<li><code>hades_permutation</code> â€“ Hades permutation for triplets of <code>felt252</code></li>
<li><code>felt252_div</code> â€“ Division operation for <code>felt252</code></li>
<li><code>storage_read_syscall</code>, <code>storage_write_syscall</code> â€“ Direct Starknet storage interactions</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<ul>
<li>
<p><a href="./core.html">core</a></p>
</li>
<li>
<p><a href="./core-traits.html">traits</a></p>
</li>
<li>
<p><a href="./core-boolean.html">boolean</a></p>
</li>
<li>
<p><a href="./core-circuit.html">circuit</a></p>
</li>
<li>
<p><a href="./core-blake.html">blake</a></p>
</li>
<li>
<p><a href="./core-box.html">box</a></p>
</li>
<li>
<p><a href="./core-nullable.html">nullable</a></p>
</li>
<li>
<p><a href="./core-array.html">array</a></p>
</li>
<li>
<p><a href="./core-dict.html">dict</a></p>
</li>
<li>
<p><a href="./core-result.html">result</a></p>
</li>
<li>
<p><a href="./core-option.html">option</a></p>
</li>
<li>
<p><a href="./core-clone.html">clone</a></p>
</li>
<li>
<p><a href="./core-ec.html">ec</a></p>
</li>
<li>
<p><a href="./core-ecdsa.html">ecdsa</a></p>
</li>
<li>
<p><a href="./core-integer.html">integer</a></p>
</li>
<li>
<p><a href="./core-cmp.html">cmp</a></p>
</li>
<li>
<p><a href="./core-gas.html">gas</a></p>
</li>
<li>
<p><a href="./core-math.html">math</a></p>
</li>
<li>
<p><a href="./core-num.html">num</a></p>
</li>
<li>
<p><a href="./core-ops.html">ops</a></p>
</li>
<li>
<p><a href="./core-panics.html">panics</a></p>
</li>
<li>
<p><a href="./core-hash.html">hash</a></p>
</li>
<li>
<p><a href="./core-keccak.html">keccak</a></p>
</li>
<li>
<p><a href="./core-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-serde.html">serde</a></p>
</li>
<li>
<p><a href="./core-sha256.html">sha256</a></p>
</li>
<li>
<p><a href="./core-poseidon.html">poseidon</a></p>
</li>
<li>
<p><a href="./core-debug.html">debug</a></p>
</li>
<li>
<p><a href="./core-fmt.html">fmt</a></p>
</li>
<li>
<p><a href="./core-starknet.html">starknet</a></p>
</li>
<li>
<p><a href="./core-internal.html">internal</a></p>
</li>
<li>
<p><a href="./core-zeroable.html">zeroable</a></p>
</li>
<li>
<p><a href="./core-bytes_31.html">bytes_31</a></p>
</li>
<li>
<p><a href="./core-byte_array.html">byte_array</a></p>
</li>
<li>
<p><a href="./core-string.html">string</a></p>
</li>
<li>
<p><a href="./core-iter.html">iter</a></p>
</li>
<li>
<p><a href="./core-metaprogramming.html">metaprogramming</a></p>
</li>
<li>
<p><a href="./core-testing.html">testing</a></p>
</li>
<li>
<p><a href="./core-to_byte_array.html">to_byte_array</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve.html">stark_curve</a></p>
</li>
<li>
<p><a href="./core-num-traits.html">num::traits</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero.html">zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one.html">one</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size.html">bit_size</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops.html">num::traits::ops</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked.html">checked</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing.html">overflowing</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow.html">pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating.html">saturating</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping.html">wrapping</a></p>
</li>
<li>
<p><a href="./core-ops-index.html">index</a></p>
</li>
<li>
<p><a href="./core-hash-into_felt252_based.html">hash::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-serde-into_felt252_based.html">serde::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-fmt-into_felt252_based.html">fmt::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access.html">storage_access</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls.html">syscalls</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address.html">contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait.html">secp256_trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1.html">secp256k1</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1.html">secp256r1</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address.html">eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature.html">eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash.html">class_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-event.html">event</a></p>
</li>
<li>
<p><a href="./core-starknet-account.html">account</a></p>
</li>
<li>
<p><a href="./core-starknet-storage.html">storage</a></p>
</li>
<li>
<p><a href="./core-starknet-testing.html">starknet::testing</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">core</a></h1>
<p>Main entrypoint for the Cairo core library.</p>
<p>Fully qualified path: <code>core</code></p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<ul>
<li>
<p><a href="./core-traits.html">traits</a></p>
</li>
<li>
<p><a href="./core-boolean.html">boolean</a></p>
</li>
<li>
<p><a href="./core-circuit.html">circuit</a></p>
</li>
<li>
<p><a href="./core-blake.html">blake</a></p>
</li>
<li>
<p><a href="./core-box.html">box</a></p>
</li>
<li>
<p><a href="./core-nullable.html">nullable</a></p>
</li>
<li>
<p><a href="./core-array.html">array</a></p>
</li>
<li>
<p><a href="./core-dict.html">dict</a></p>
</li>
<li>
<p><a href="./core-result.html">result</a></p>
</li>
<li>
<p><a href="./core-option.html">option</a></p>
</li>
<li>
<p><a href="./core-clone.html">clone</a></p>
</li>
<li>
<p><a href="./core-ec.html">ec</a></p>
</li>
<li>
<p><a href="./core-ecdsa.html">ecdsa</a></p>
</li>
<li>
<p><a href="./core-integer.html">integer</a></p>
</li>
<li>
<p><a href="./core-cmp.html">cmp</a></p>
</li>
<li>
<p><a href="./core-gas.html">gas</a></p>
</li>
<li>
<p><a href="./core-math.html">math</a></p>
</li>
<li>
<p><a href="./core-num.html">num</a></p>
</li>
<li>
<p><a href="./core-ops.html">ops</a></p>
</li>
<li>
<p><a href="./core-panics.html">panics</a></p>
</li>
<li>
<p><a href="./core-hash.html">hash</a></p>
</li>
<li>
<p><a href="./core-keccak.html">keccak</a></p>
</li>
<li>
<p><a href="./core-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-serde.html">serde</a></p>
</li>
<li>
<p><a href="./core-sha256.html">sha256</a></p>
</li>
<li>
<p><a href="./core-poseidon.html">poseidon</a></p>
</li>
<li>
<p><a href="./core-debug.html">debug</a></p>
</li>
<li>
<p><a href="./core-fmt.html">fmt</a></p>
</li>
<li>
<p><a href="./core-starknet.html">starknet</a></p>
</li>
<li>
<p><a href="./core-internal.html">internal</a></p>
</li>
<li>
<p><a href="./core-zeroable.html">zeroable</a></p>
</li>
<li>
<p><a href="./core-bytes_31.html">bytes_31</a></p>
</li>
<li>
<p><a href="./core-byte_array.html">byte_array</a></p>
</li>
<li>
<p><a href="./core-string.html">string</a></p>
</li>
<li>
<p><a href="./core-iter.html">iter</a></p>
</li>
<li>
<p><a href="./core-metaprogramming.html">metaprogramming</a></p>
</li>
<li>
<p><a href="./core-testing.html">testing</a></p>
</li>
<li>
<p><a href="./core-to_byte_array.html">to_byte_array</a></p>
</li>
</ul>
<h2 id="free-functions"><a class="header" href="#free-functions">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-panic_with_felt252.html">panic_with_felt252</a></p>
</li>
<li>
<p><a href="./core-panic_with_const_felt252.html">panic_with_const_felt252</a></p>
</li>
<li>
<p><a href="./core-assert.html">assert</a></p>
</li>
</ul>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<ul>
<li>
<p><a href="./core-bool.html">bool</a></p>
</li>
<li>
<p><a href="./core-never.html">never</a></p>
</li>
</ul>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h2>
<ul>
<li><a href="./core-usize.html">usize</a></li>
</ul>
<h2 id="extern-types"><a class="header" href="#extern-types">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-RangeCheck.html">RangeCheck</a></p>
</li>
<li>
<p><a href="./core-SegmentArena.html">SegmentArena</a></p>
</li>
<li>
<p><a href="./core-felt252.html">felt252</a></p>
</li>
</ul>
<h2 id="extern-functions"><a class="header" href="#extern-functions">Extern functions</a></h2>
<ul>
<li><a href="./core-felt252_div.html">felt252_div</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">traits</a></h1>
<p>Core traits for various operations.This module provides a collection of essential traits that define common behavior patterns for Cairo types.  # Main Categories  ## Memory Management - <a href="./core-traits-Copy.html"><code>Copy</code></a>: Enables value semantics for types - <a href="./core-traits-Drop.html"><code>Drop</code></a>: Allows values to be safely discarded - <a href="./core-traits-Destruct.html"><code>Destruct</code></a>: Provides custom cleanup behavior for non-droppable types - <a href="./core-traits-PanicDestruct.html"><code>PanicDestruct</code></a>: Handles destruction during panic scenarios  ## Arithmetic Operations - <a href="./core-traits-Add.html"><code>Add</code></a>, <a href="./core-traits-Sub.html"><code>Sub</code></a>, <a href="./core-traits-Mul.html"><code>Mul</code></a>, <a href="./core-traits-Div.html"><code>Div</code></a>, <a href="./core-traits-Rem.html"><code>Rem</code></a>: Standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) - <a href="./core-traits-DivRem.html"><code>DivRem</code></a>: Combined division and remainder operation - <a href="./core-traits-Neg.html"><code>Neg</code></a>: Unary negation (<code>-</code>)  ## Bitwise Operations - <a href="./core-traits-BitAnd.html"><code>BitAnd</code></a>, <a href="./core-traits-BitOr.html"><code>BitOr</code></a>, <a href="./core-traits-BitXor.html"><code>BitXor</code></a>: Binary bitwise operations (<code>&amp;</code>, <code>|</code>, <code>^</code>) - <a href="./core-traits-BitNot.html"><code>BitNot</code></a>: Unary bitwise complement (<code>~</code>)  ## Comparison - <a href="./core-traits-PartialEq.html"><code>PartialEq</code></a>: Equality comparison (<code>==</code>, <code>!=</code>) - <a href="./core-traits-PartialOrd.html"><code>PartialOrd</code></a>: Ordering comparison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)  ## Type Conversion - <a href="./core-traits-Into.html"><code>Into</code></a>: Infallible type conversion - <a href="./core-traits-TryInto.html"><code>TryInto</code></a>: Fallible type conversion  ## Utility Traits - <a href="./core-traits-Default.html"><code>Default</code></a>: Creation of default values - <a href="./core-traits-Felt252DictValue.html"><code>Felt252DictValue</code></a>: Support for dictionary value types</p>
<p>Fully qualified path: <code>core::traits</code></p>
<h2 id="traits-1"><a class="header" href="#traits-1">Traits</a></h2>
<ul>
<li>
<p><a href="./core-traits-Copy.html">Copy</a></p>
</li>
<li>
<p><a href="./core-traits-Drop.html">Drop</a></p>
</li>
<li>
<p><a href="./core-traits-Add.html">Add</a></p>
</li>
<li>
<p><a href="./core-traits-AddEq.html">AddEq</a></p>
</li>
<li>
<p><a href="./core-traits-Sub.html">Sub</a></p>
</li>
<li>
<p><a href="./core-traits-SubEq.html">SubEq</a></p>
</li>
<li>
<p><a href="./core-traits-Mul.html">Mul</a></p>
</li>
<li>
<p><a href="./core-traits-MulEq.html">MulEq</a></p>
</li>
<li>
<p><a href="./core-traits-Div.html">Div</a></p>
</li>
<li>
<p><a href="./core-traits-DivEq.html">DivEq</a></p>
</li>
<li>
<p><a href="./core-traits-Rem.html">Rem</a></p>
</li>
<li>
<p><a href="./core-traits-RemEq.html">RemEq</a></p>
</li>
<li>
<p><a href="./core-traits-DivRem.html">DivRem</a></p>
</li>
<li>
<p><a href="./core-traits-PartialEq.html">PartialEq</a></p>
</li>
<li>
<p><a href="./core-traits-BitAnd.html">BitAnd</a></p>
</li>
<li>
<p><a href="./core-traits-BitOr.html">BitOr</a></p>
</li>
<li>
<p><a href="./core-traits-BitXor.html">BitXor</a></p>
</li>
<li>
<p><a href="./core-traits-BitNot.html">BitNot</a></p>
</li>
<li>
<p><a href="./core-traits-PartialOrd.html">PartialOrd</a></p>
</li>
<li>
<p><a href="./core-traits-Into.html">Into</a></p>
</li>
<li>
<p><a href="./core-traits-TryInto.html">TryInto</a></p>
</li>
<li>
<p><a href="./core-traits-Neg.html">Neg</a></p>
</li>
<li>
<p><a href="./core-traits-Not.html">Not</a></p>
</li>
<li>
<p><a href="./core-traits-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-traits-Index.html">Index</a></p>
</li>
<li>
<p><a href="./core-traits-Destruct.html">Destruct</a></p>
</li>
<li>
<p><a href="./core-traits-PanicDestruct.html">PanicDestruct</a></p>
</li>
<li>
<p><a href="./core-traits-Default.html">Default</a></p>
</li>
<li>
<p><a href="./core-traits-Felt252DictValue.html">Felt252DictValue</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean"><a class="header" href="#boolean">boolean</a></h1>
<p>Boolean operations.The <code>bool</code> type is a primitive type in Cairo representing a boolean value that can be either <code>true</code> or <code>false</code>. This module provides trait implementations for boolean operations.  # ExamplesBasic boolean operations:</p>
<pre><code class="language-cairo">
let value = true;
assert!(value == true);
assert!(!value == false);
</code></pre>
<p>Converting to optional values with <a href="%60BoolTrait::then_some%60"><code>BoolTrait::then_some</code></a>:</p>
<pre><code class="language-cairo">use core::boolean::BoolTrait;

let bool_value = true;
let result = bool_value.then_some(42_u8);
assert!(result == Some(42));

let bool_value = false;
let result = bool_value.then_some(42_u8);
assert!(result == None);
</code></pre>
<p>Fully qualified path: <code>core::boolean</code></p>
<h2 id="traits-2"><a class="header" href="#traits-2">Traits</a></h2>
<ul>
<li><a href="./core-boolean-BoolTrait.html">BoolTrait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit"><a class="header" href="#circuit">circuit</a></h1>
<p>Efficient modular arithmetic computations using arithmetic circuits.This module provides a type-safe way to perform modular arithmetic operations using arithmetic circuits. It is particularly useful for implementing cryptographic algorithms and other computations that require efficient modular arithmetic with large numbers.  # Core FeaturesModular arithmetic operations (add, subtract, multiply, inverse) - Support for numbers up to 384 bits - Type-safe circuit construction - Efficient evaluation of complex expressions  # Examples  ## Basic ArithmeticHere's an example showing basic modular arithmetic operations:</p>
<pre><code class="language-cairo">use core::circuit::{
   CircuitElement, EvalCircuitTrait, CircuitOutputsTrait, CircuitInput, CircuitModulus,
   AddInputResultTrait, CircuitInputs, circuit_add, circuit_mul,
};

// Compute (a + b) * c mod p
let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
let c = CircuitElement::&lt;CircuitInput&lt;2&gt;&gt; {};

let sum = circuit_add(a, b);
let result = circuit_mul(sum, c);

// Evaluate with inputs [3, 6, 2] modulo 7
let modulus = TryInto::&lt;_, CircuitModulus&gt;::try_into([7, 0, 0, 0]).unwrap();
let outputs = (result,)
    .new_inputs()
    .next([3, 0, 0, 0])
    .next([6, 0, 0, 0])
    .next([2, 0, 0, 0])
    .done()
    .eval(modulus)
    .unwrap();

// Result: (3 + 6) * 2 mod 7 = 4
assert!(outputs.get_output(result) == 4.into());
</code></pre>
<h1 id="how-it-worksthe-module-uses-a-type-based-approach-to-construct-and-evaluate-arithmetic-circuitscircuit-elements-are-created-using-circuitelementt-where-t-defines-their-role-input-or-gate-2-basic-operations-combine-elements-into-more-complex-expressions-chaining-gates-to-create-a-circuit-3-the-final-circuit-is-evaluated-with-specific-input-values-and-a-modulusoperations-are-performed-using-a-multi-limb-representation-for-large-numbers-with-each-number-represented-as-four-96-bit-limbs-allowing-for-values-up-to-384-bits---performance-considerationscircuit-evaluation-is-optimized-for-large-modular-arithmetic-operations---the-multi-limb-representation-allows-efficient-handling-of-large-numbers---circuit-construction-has-zero-runtime-overhead-due-to-type-based-approach---errorscircuit-evaluation-can-fail-in-certain-cases---when-computing-multiplicative-inverses-of-non-invertible-elements---when-the-modulus-is-0-or-1-in-that-case-the-evaluation-will-return-an-error"><a class="header" href="#how-it-worksthe-module-uses-a-type-based-approach-to-construct-and-evaluate-arithmetic-circuitscircuit-elements-are-created-using-circuitelementt-where-t-defines-their-role-input-or-gate-2-basic-operations-combine-elements-into-more-complex-expressions-chaining-gates-to-create-a-circuit-3-the-final-circuit-is-evaluated-with-specific-input-values-and-a-modulusoperations-are-performed-using-a-multi-limb-representation-for-large-numbers-with-each-number-represented-as-four-96-bit-limbs-allowing-for-values-up-to-384-bits---performance-considerationscircuit-evaluation-is-optimized-for-large-modular-arithmetic-operations---the-multi-limb-representation-allows-efficient-handling-of-large-numbers---circuit-construction-has-zero-runtime-overhead-due-to-type-based-approach---errorscircuit-evaluation-can-fail-in-certain-cases---when-computing-multiplicative-inverses-of-non-invertible-elements---when-the-modulus-is-0-or-1-in-that-case-the-evaluation-will-return-an-error">How It WorksThe module uses a type-based approach to construct and evaluate arithmetic circuits:Circuit elements are created using <code>CircuitElement&lt;T&gt;</code> where T defines their role (input or gate) 2. Basic operations combine elements into more complex expressions (chaining gates to create a circuit) 3. The final circuit is evaluated with specific input values and a modulusOperations are performed using a multi-limb representation for large numbers, with each number represented as four 96-bit limbs allowing for values up to 384 bits.  # Performance ConsiderationsCircuit evaluation is optimized for large modular arithmetic operations - The multi-limb representation allows efficient handling of large numbers - Circuit construction has zero runtime overhead due to type-based approach  # ErrorsCircuit evaluation can fail in certain cases: - When computing multiplicative inverses of non-invertible elements - When the modulus is 0 or 1 In that case the evaluation will return an Error.</a></h1>
<p>Fully qualified path: <code>core::circuit</code></p>
<h2 id="free-functions-1"><a class="header" href="#free-functions-1">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-circuit-circuit_add.html">circuit_add</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_sub.html">circuit_sub</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_inverse.html">circuit_inverse</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_mul.html">circuit_mul</a></p>
</li>
</ul>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li>
<p><a href="./core-circuit-u384.html">u384</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElement.html">CircuitElement</a></p>
</li>
</ul>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<ul>
<li><a href="./core-circuit-AddInputResult.html">AddInputResult</a></li>
</ul>
<h2 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type aliases</a></h2>
<ul>
<li>
<p><a href="./core-circuit-u96.html">u96</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstZero.html">ConstZero</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstOne.html">ConstOne</a></p>
</li>
</ul>
<h2 id="traits-3"><a class="header" href="#traits-3">Traits</a></h2>
<ul>
<li>
<p><a href="./core-circuit-CircuitElementTrait.html">CircuitElementTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitDefinition.html">CircuitDefinition</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitOutputsTrait.html">CircuitOutputsTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInputs.html">CircuitInputs</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResultTrait.html">AddInputResultTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-EvalCircuitTrait.html">EvalCircuitTrait</a></p>
</li>
</ul>
<h2 id="impls"><a class="header" href="#impls">Impls</a></h2>
<ul>
<li>
<p><a href="./core-circuit-CircuitElementDrop.html">CircuitElementDrop</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementCopy.html">CircuitElementCopy</a></p>
</li>
<li>
<p><a href="./core-circuit-DestructFailureGuarantee.html">DestructFailureGuarantee</a></p>
</li>
</ul>
<h2 id="extern-types-1"><a class="header" href="#extern-types-1">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-circuit-RangeCheck96.html">RangeCheck96</a></p>
</li>
<li>
<p><a href="./core-circuit-AddMod.html">AddMod</a></p>
</li>
<li>
<p><a href="./core-circuit-MulMod.html">MulMod</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitModulus.html">CircuitModulus</a></p>
</li>
<li>
<p><a href="./core-circuit-Circuit.html">Circuit</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInput.html">CircuitInput</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blake"><a class="header" href="#blake">blake</a></h1>
<p>Fully qualified path: <code>core::blake</code></p>
<h2 id="extern-functions-1"><a class="header" href="#extern-functions-1">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-blake-blake2s_compress.html">blake2s_compress</a></p>
</li>
<li>
<p><a href="./core-blake-blake2s_finalize.html">blake2s_finalize</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">box</a></h1>
<p><code>Box&lt;T&gt;</code> is a smart pointer that allows for:Storing values of arbitrary size while maintaining a fixed-size pointer * Enabling recursive types that would otherwise have infinite size * Moving large data structures efficiently by passing pointers instead of copying values  # ExamplesCreating a new box with <a href="%60BoxTrait::new%60"><code>BoxTrait::new</code></a>:</p>
<pre><code class="language-cairo">let boxed = BoxTrait::new(42);
let unboxed = boxed.unbox();
</code></pre>
<p>Working with larger structures:</p>
<pre><code class="language-cairo">let large_array = array![1, 2, 3, 4, 5];
let boxed_array = BoxTrait::new(large_array);
</code></pre>
<p>Creating a recursive data structure:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, Debug)]
</span>enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;)
}

let leaf = BinaryTree::Leaf(1);
let node = BinaryTree::Node((2, BoxTrait::new(leaf), BoxTrait::new(leaf)));
println!("{:?}", node);
</code></pre>
<p>NOTE: A <code>Box&lt;T&gt;</code> is a smart pointer type that provides a way to store a value of type <code>T</code> in Cairo VM's boxed segment, leaving only a pointer in the execution segment.</p>
<p>Fully qualified path: <code>core::box</code></p>
<h2 id="traits-4"><a class="header" href="#traits-4">Traits</a></h2>
<ul>
<li><a href="./core-box-BoxTrait.html">BoxTrait</a></li>
</ul>
<h2 id="extern-types-2"><a class="header" href="#extern-types-2">Extern types</a></h2>
<ul>
<li><a href="./core-box-Box.html">Box</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable"><a class="header" href="#nullable">nullable</a></h1>
<p>A wrapper type for handling optional values.<code>Nullable&lt;T&gt;</code> is a wrapper type that can either contain a value stored in a <code>Box&lt;T&gt;</code> or be null. It provides a safe way to handle optional values without the risk of dereferencing null pointers.This makes it particularly useful in dictionaries that store complex data structures that don't implement the <code>Felt252DictValue</code> trait; instead, they can be wrapped inside a <code>Nullable</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(10);
let unwrapped_value = value.deref();
</code></pre>
<p>Handling null values:</p>
<pre><code class="language-cairo">let null_value: Nullable&lt;u32&gt; = Default::default();
let unwrapped_value = null_value.deref_or(1);
</code></pre>
<p>Checking if the value is null:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(10);
let is_null = if value.is_null() {
    // Handle null case
} else {
    // Handle non-null case
};
</code></pre>
<p>Fully qualified path: <code>core::nullable</code></p>
<h2 id="enums-2"><a class="header" href="#enums-2">Enums</a></h2>
<ul>
<li><a href="./core-nullable-FromNullableResult.html">FromNullableResult</a></li>
</ul>
<h2 id="traits-5"><a class="header" href="#traits-5">Traits</a></h2>
<ul>
<li><a href="./core-nullable-NullableTrait.html">NullableTrait</a></li>
</ul>
<h2 id="extern-types-3"><a class="header" href="#extern-types-3">Extern types</a></h2>
<ul>
<li><a href="./core-nullable-Nullable.html">Nullable</a></li>
</ul>
<h2 id="extern-functions-2"><a class="header" href="#extern-functions-2">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-nullable-null.html">null</a></p>
</li>
<li>
<p><a href="./core-nullable-match_nullable.html">match_nullable</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">array</a></h1>
<p>A contiguous collection of elements of the same type in memory, written <code>Array&lt;T&gt;</code>.Arrays have O(1) indexing, O(1) push and O(1) pop (from the front).Arrays can only be mutated by appending to the end or popping from the front.  # ExamplesYou can explicitly create an <a href="./core-array-Array.html"><code>Array</code></a> with <a href="%60ArrayTrait::new%60"><code>ArrayTrait::new</code></a>:</p>
<pre><code class="language-cairo">let arr: Array&lt;usize&gt; = ArrayTrait::new();
</code></pre>
<p>...or by using the <code>array!</code> macro:</p>
<pre><code class="language-cairo">let arr: Array&lt;usize&gt; = array![];

let arr: Array&lt;usize&gt; = array![1, 2, 3, 4, 5];
</code></pre>
<p>You can <a href="%60append%60"><code>append</code></a> values onto the end of an array:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2];
arr.append(3);
</code></pre>
<p>Popping values from the front works like this:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2];
let one = arr.pop_front(); // Returns Some(1)
</code></pre>
<p>Arrays support indexing (through the <a href="./core-traits-IndexView.html"><code>IndexView</code></a> trait):</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let three = arr[2]; // Returns a snapshot (@T)
</code></pre>
<p>Arrays can be converted to <a href="./core-array-Span.html"><code>Span</code></a>s for read-only access:</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let span = arr.span();
</code></pre>
<p>A span can be manipulated without affecting the original array:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2, 3];
let mut span = arr.span();
span.pop_back();
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array</code></p>
<h2 id="structs-1"><a class="header" href="#structs-1">Structs</a></h2>
<ul>
<li>
<p><a href="./core-array-Span.html">Span</a></p>
</li>
<li>
<p><a href="./core-array-SpanIter.html">SpanIter</a></p>
</li>
<li>
<p><a href="./core-array-ArrayIter.html">ArrayIter</a></p>
</li>
</ul>
<h2 id="traits-6"><a class="header" href="#traits-6">Traits</a></h2>
<ul>
<li>
<p><a href="./core-array-ToSpanTrait.html">ToSpanTrait</a></p>
</li>
<li>
<p><a href="./core-array-ArrayTrait.html">ArrayTrait</a></p>
</li>
<li>
<p><a href="./core-array-SpanTrait.html">SpanTrait</a></p>
</li>
</ul>
<h2 id="impls-1"><a class="header" href="#impls-1">Impls</a></h2>
<ul>
<li><a href="./core-array-SpanIndex.html">SpanIndex</a></li>
</ul>
<h2 id="extern-types-4"><a class="header" href="#extern-types-4">Extern types</a></h2>
<ul>
<li><a href="./core-array-Array.html">Array</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dict"><a class="header" href="#dict">dict</a></h1>
<p>A dictionary-like data structure that maps <code>felt252</code> keys to values of any type.The <code>Felt252Dict</code> provides efficient key-value storage with operations for inserting, retrieving, and updating values. Each operation creates a new entry that can be validated through a process called squashing.  # ExamplesOne can create a new dictionary using the <a href="%60Default::default%60"><code>Default::default</code></a> method:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
</code></pre>
<p>... then insert new values corresponding to a given key with the <a href="%60Felt252DictTrait::insert%60"><code>Felt252DictTrait::insert</code></a> method, and retrieve any value given a key with the <a href="%60Felt252DictTrait::get%60"><code>Felt252DictTrait::get</code></a> method.</p>
<pre><code class="language-cairo">dict.insert(0, 10);
dict.insert(1, 20);
assert!(dict.get(0) == 10);
assert!(dict.get(1) == 20);

dict.insert(0, 20);
assert!(dict.get(0) == 20);
</code></pre>
<p>It is also possible to use the <a href="%60Felt252DictTrait::entry%60"><code>Felt252DictTrait::entry</code></a> method to retrieve the last entry given a certain key. In this case, the method takes ownership of the dictionary and returns the entry to update. After that, using the <a href="%60Felt252DictEntryTrait::finalize%60"><code>Felt252DictEntryTrait::finalize</code></a> allows to create a new entry in the dictionary. Using <code>entry</code> and <code>finalize</code> methods can be very useful given that it does not require the type in the dictionary to be copyable, meaning that we can use non-copyable types like arrays as dictionary values.</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);

let (entry, prev_value) = dict.entry(0);
let new_value: u8 = 20;
dict = entry.finalize(new_value);
</code></pre>
<p>Fully qualified path: <code>core::dict</code></p>
<h2 id="traits-7"><a class="header" href="#traits-7">Traits</a></h2>
<ul>
<li>
<p><a href="./core-dict-Felt252DictTrait.html">Felt252DictTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntryTrait.html">Felt252DictEntryTrait</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252DictTrait.html">SquashedFelt252DictTrait</a></p>
</li>
</ul>
<h2 id="extern-types-5"><a class="header" href="#extern-types-5">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-dict-Felt252Dict.html">Felt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252Dict.html">SquashedFelt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntry.html">Felt252DictEntry</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result">result</a></h1>
<p>Error handling with the <code>Result</code> type.<a href="./core-result-Result.html"><code>Result</code></a> is the type used for returning and propagating errors. It is an enum with the variants, <a href="%60Ok(T)%60"><code>Ok(T)</code></a>, representing success and containing a value, and <a href="%60Err(E)%60"><code>Err(E)</code></a>, representing error and containing an error value.</p>
<pre><code class="language-cairo">enum Result&lt;T, E&gt; {
   Ok: T,
   Err: E,
}
</code></pre>
<p>Functions return <a href="./core-result-Result.html"><code>Result</code></a> whenever errors are expected and recoverable.A simple function returning <a href="./core-result-Result.html"><code>Result</code></a> might be defined and used like so:</p>
<pre><code class="language-cairo">fn parse_version(header: felt252) -&gt; Result&lt;felt252, felt252&gt; {
    match header {
        0 =&gt; Ok(0),
        1 =&gt; Ok(1),
        _ =&gt; Err('invalid version'),
    }
}

let version = parse_version(1);
match version {
    Ok(v) =&gt; println!("working with version {}", v),
    Err(e) =&gt; println!("error parsing version: {:?}", e)
}
</code></pre>
<h1 id="results-must-be-useda-common-problem-with-using-return-values-to-indicate-errors-is-that-it-is-easy-to-ignore-the-return-value-thus-failing-to-handle-the-error-result-is-annotated-with-the-must_use-attribute-which-will-cause-the-compiler-to-issue-a-warning-when-a-result-value-is-ignored---method-overviewin-addition-to-working-with-pattern-matching-result-provides-a-wide-variety-of-different-methods---querying-the-variantthe-is_ok-and-is_err-methods-return-true-if-the-result-is-ok-or-err-respectively---extracting-contained-valuesthese-methods-extract-the-contained-value-in-a-resultt-eresultt-e-when-it-is-the-ok-variant-if-the-result-is-errexpect-panics-with-a-provided-felt252-error-message--unwrap-panics-with-a-generic-message--unwrap_or-returns-the-provided-default-value--unwrap_or_default-returns-the-default-value-of-the-type-t-which-must-implement-the-default-trait--unwrap_or_else-returns-the-result-of-evaluating-the-provided-functionexpect-resulttraitexpect-unwrap-resulttraitunwrap-unwrap_or-resulttraitunwrap_or-unwrap_or_default-resulttraitunwrap_or_default-unwrap_or_else-resulttraitunwrap_or_elsethese-methods-extract-the-contained-value-in-a-resultt-eresultt-e-when-it-is-the-err-variant-if-the-result-is-okexpect_err-panics-with-a-provided-felt252-error-message--unwrap_err-panics-with-a-generic-messageexpect_err-resulttraitexpect_err-unwrap_err-resulttraitunwrap_err---transforming-contained-valuesthese-methods-transform-result-to-optionok-transforms-resultt-eresultt-e-into-optiont-mapping-okv-to-somev-and-erre-to-none--err-transforms-resultt-eresultt-e-into-optione-mapping-okv-to-none-and-erre-to-someethis-method-transforms-the-contained-value-of-the-ok-variantmap-transforms-resultt-eresultt-e-into-resultu-eresultu-e-by-applying-the-provided-function-to-the-contained-value-of-ok-and-leaving-err-values-unchangedthis-method-transforms-the-contained-value-of-the-err-variantmap_err-transforms-resultt-eresultt-e-into-resultt-fresultt-f-by-applying-the-provided-function-to-the-contained-value-of-err-and-leaving-ok-values-unchangedthese-methods-transform-a-resultt-eresultt-e-into-a-value-of-a-possibly-different-type-umap_or-applies-the-provided-function-to-the-contained-value-of-ok-or-returns-the-provided-default-value-if-the-result-is-err--map_or_else-applies-the-provided-function-to-the-contained-value-of-ok-or-applies-the-provided-default-fallback-function-to-the-contained-value-of-errmap_or-resulttraitmap_or-map_or_else-resulttraitmap_or_else---boolean-operatorsthese-methods-treat-the-result-as-a-boolean-value-where-ok-acts-like-true-and-err-acts-like-false-there-are-two-categories-of-these-methods-ones-that-take-a-result-as-input-and-ones-that-take-a-function-as-inputthe-and-and-or-methods-take-another-result-as-input-and-produce-a-result-as-output-the-and-method-can-produce-a-resultu-eresultu-e-value-having-a-different-inner-type-u-than-resultt-eresultt-e-the-or-method-can-produce-a-resultt-fresultt-f-value-having-a-different-error-type-f-than-resultt-eresultt-e-method---self------input------output----------------------------------------------and--erre--ignored--erre---and--okx---errd---errd---and--okx---oky----oky----or---erre--errd---errd---or---erre--oky----oky----or---okx---ignored--okx--and-resulttraitand-or-resulttraitorthe-and_then-and-or_else-methods-take-a-function-as-input-and-only-evaluate-the-function-when-they-need-to-produce-a-new-value-the-and_then-method-can-produce-a-resultu-eresultu-e-value-having-a-different-inner-type-u-than-resultt-eresultt-e-the-or_else-method-can-produce-a-resultt-fresultt-f-value-having-a-different-error-type-f-than-resultt-eresultt-e-method--------self------function-input--function-result--output-------------------------------------------------------------------------and_then--erre--not-provided--not-evaluated--erre---and_then--okx---x-------------errd---------errd---and_then--okx---x-------------oky----------oky----or_else---erre--e-------------errd---------errd---or_else---erre--e-------------oky----------oky----or_else---okx---not-provided--not-evaluated--okx--and_then-resulttraitand_then-or_else-resulttraitor_else---the-question-mark-operator-when-writing-code-that-calls-many-functions-that-return-the-result-type-handling-okerr-can-be-tedious-the-question-mark-operator--hides-some-of-the-boilerplate-of-propagating-errors-up-the-call-stackit-replaces-this"><a class="header" href="#results-must-be-useda-common-problem-with-using-return-values-to-indicate-errors-is-that-it-is-easy-to-ignore-the-return-value-thus-failing-to-handle-the-error-result-is-annotated-with-the-must_use-attribute-which-will-cause-the-compiler-to-issue-a-warning-when-a-result-value-is-ignored---method-overviewin-addition-to-working-with-pattern-matching-result-provides-a-wide-variety-of-different-methods---querying-the-variantthe-is_ok-and-is_err-methods-return-true-if-the-result-is-ok-or-err-respectively---extracting-contained-valuesthese-methods-extract-the-contained-value-in-a-resultt-eresultt-e-when-it-is-the-ok-variant-if-the-result-is-errexpect-panics-with-a-provided-felt252-error-message--unwrap-panics-with-a-generic-message--unwrap_or-returns-the-provided-default-value--unwrap_or_default-returns-the-default-value-of-the-type-t-which-must-implement-the-default-trait--unwrap_or_else-returns-the-result-of-evaluating-the-provided-functionexpect-resulttraitexpect-unwrap-resulttraitunwrap-unwrap_or-resulttraitunwrap_or-unwrap_or_default-resulttraitunwrap_or_default-unwrap_or_else-resulttraitunwrap_or_elsethese-methods-extract-the-contained-value-in-a-resultt-eresultt-e-when-it-is-the-err-variant-if-the-result-is-okexpect_err-panics-with-a-provided-felt252-error-message--unwrap_err-panics-with-a-generic-messageexpect_err-resulttraitexpect_err-unwrap_err-resulttraitunwrap_err---transforming-contained-valuesthese-methods-transform-result-to-optionok-transforms-resultt-eresultt-e-into-optiont-mapping-okv-to-somev-and-erre-to-none--err-transforms-resultt-eresultt-e-into-optione-mapping-okv-to-none-and-erre-to-someethis-method-transforms-the-contained-value-of-the-ok-variantmap-transforms-resultt-eresultt-e-into-resultu-eresultu-e-by-applying-the-provided-function-to-the-contained-value-of-ok-and-leaving-err-values-unchangedthis-method-transforms-the-contained-value-of-the-err-variantmap_err-transforms-resultt-eresultt-e-into-resultt-fresultt-f-by-applying-the-provided-function-to-the-contained-value-of-err-and-leaving-ok-values-unchangedthese-methods-transform-a-resultt-eresultt-e-into-a-value-of-a-possibly-different-type-umap_or-applies-the-provided-function-to-the-contained-value-of-ok-or-returns-the-provided-default-value-if-the-result-is-err--map_or_else-applies-the-provided-function-to-the-contained-value-of-ok-or-applies-the-provided-default-fallback-function-to-the-contained-value-of-errmap_or-resulttraitmap_or-map_or_else-resulttraitmap_or_else---boolean-operatorsthese-methods-treat-the-result-as-a-boolean-value-where-ok-acts-like-true-and-err-acts-like-false-there-are-two-categories-of-these-methods-ones-that-take-a-result-as-input-and-ones-that-take-a-function-as-inputthe-and-and-or-methods-take-another-result-as-input-and-produce-a-result-as-output-the-and-method-can-produce-a-resultu-eresultu-e-value-having-a-different-inner-type-u-than-resultt-eresultt-e-the-or-method-can-produce-a-resultt-fresultt-f-value-having-a-different-error-type-f-than-resultt-eresultt-e-method---self------input------output----------------------------------------------and--erre--ignored--erre---and--okx---errd---errd---and--okx---oky----oky----or---erre--errd---errd---or---erre--oky----oky----or---okx---ignored--okx--and-resulttraitand-or-resulttraitorthe-and_then-and-or_else-methods-take-a-function-as-input-and-only-evaluate-the-function-when-they-need-to-produce-a-new-value-the-and_then-method-can-produce-a-resultu-eresultu-e-value-having-a-different-inner-type-u-than-resultt-eresultt-e-the-or_else-method-can-produce-a-resultt-fresultt-f-value-having-a-different-error-type-f-than-resultt-eresultt-e-method--------self------function-input--function-result--output-------------------------------------------------------------------------and_then--erre--not-provided--not-evaluated--erre---and_then--okx---x-------------errd---------errd---and_then--okx---x-------------oky----------oky----or_else---erre--e-------------errd---------errd---or_else---erre--e-------------oky----------oky----or_else---okx---not-provided--not-evaluated--okx--and_then-resulttraitand_then-or_else-resulttraitor_else---the-question-mark-operator-when-writing-code-that-calls-many-functions-that-return-the-result-type-handling-okerr-can-be-tedious-the-question-mark-operator--hides-some-of-the-boilerplate-of-propagating-errors-up-the-call-stackit-replaces-this">Results must be usedA common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. <a href="./core-result-Result.html"><code>Result</code></a> is annotated with the <code>#[must_use]</code> attribute, which will cause the compiler to issue a warning when a Result value is ignored.  # Method overviewIn addition to working with pattern matching, <a href="./core-result-Result.html"><code>Result</code></a> provides a wide variety of different methods.  ## Querying the variantThe <a href="%60is_ok%60"><code>is_ok</code></a> and <a href="%60is_err%60"><code>is_err</code></a> methods return <code>true</code> if the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#ok"><code>Ok</code></a> or <a href="./core-result.html#err"><code>Err</code></a>, respectively.  ## Extracting contained valuesThese methods extract the contained value in a [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) when it is the <a href="./core-result.html#ok"><code>Ok</code></a> variant. If the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#err"><code>Err</code></a>:<a href="%60expect%60"><code>expect</code></a> panics with a provided felt252 error message * <a href="%60unwrap%60"><code>unwrap</code></a> panics with a generic message * <a href="%60unwrap_or%60"><code>unwrap_or</code></a> returns the provided default value * <a href="%60unwrap_or_default%60"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code> (which must implement the <a href="./core-traits-Default.html"><code>Default</code></a> trait) * <a href="%60unwrap_or_else%60"><code>unwrap_or_else</code></a> returns the result of evaluating the provided function<a href="%60expect%60"><code>expect</code></a>: ResultTrait::expect <a href="%60unwrap%60"><code>unwrap</code></a>: ResultTrait::unwrap <a href="%60unwrap_or%60"><code>unwrap_or</code></a>: ResultTrait::unwrap_or <a href="%60unwrap_or_default%60"><code>unwrap_or_default</code></a>: ResultTrait::unwrap_or_default <a href="%60unwrap_or_else%60"><code>unwrap_or_else</code></a>: ResultTrait::unwrap_or_elseThese methods extract the contained value in a [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) when it is the <a href="./core-result.html#err"><code>Err</code></a> variant. If the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#ok"><code>Ok</code></a>:<a href="%60expect_err%60"><code>expect_err</code></a> panics with a provided felt252 error message * <a href="%60unwrap_err%60"><code>unwrap_err</code></a> panics with a generic message<a href="%60expect_err%60"><code>expect_err</code></a>: ResultTrait::expect_err <a href="%60unwrap_err%60"><code>unwrap_err</code></a>: ResultTrait::unwrap_err  ## Transforming contained valuesThese methods transform <a href="./core-result-Result.html"><code>Result</code></a> to <a href="./core-option-Option.html"><code>Option</code></a>:<a href="%60ok%60"><code>ok</code></a> transforms [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) into <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a>, mapping <a href="%60Ok(v)%60"><code>Ok(v)</code></a> to <a href="%60Some(v)%60"><code>Some(v)</code></a> and <a href="%60Err(e)%60"><code>Err(e)</code></a> to <a href="./core-option.html#none"><code>None</code></a> * <a href="%60err%60"><code>err</code></a> transforms [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) into <a href="%60Option%3CE%3E%60"><code>Option&lt;E&gt;</code></a>, mapping <a href="%60Ok(v)%60"><code>Ok(v)</code></a> to <a href="./core-option.html#none"><code>None</code></a> and <a href="%60Err(e)%60"><code>Err(e)</code></a> to <a href="%60Some(e)%60"><code>Some(e)</code></a>This method transforms the contained value of the <a href="./core-result.html#ok"><code>Ok</code></a> variant:<a href="%60map%60"><code>map</code></a> transforms [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) into [<code>Result&lt;U, E&gt;</code>](<code>Result&lt;U, E&gt;</code>) by applying the provided function to the contained value of <a href="./core-result.html#ok"><code>Ok</code></a> and leaving <a href="./core-result.html#err"><code>Err</code></a> values unchangedThis method transforms the contained value of the <a href="./core-result.html#err"><code>Err</code></a> variant:<a href="%60map_err%60"><code>map_err</code></a> transforms [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) into [<code>Result&lt;T, F&gt;</code>](<code>Result&lt;T, F&gt;</code>) by applying the provided function to the contained value of <a href="./core-result.html#err"><code>Err</code></a> and leaving <a href="./core-result.html#ok"><code>Ok</code></a> values unchangedThese methods transform a [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>) into a value of a possibly different type <code>U</code>:<a href="%60map_or%60"><code>map_or</code></a> applies the provided function to the contained value of <a href="./core-result.html#ok"><code>Ok</code></a>, or returns the provided default value if the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#err"><code>Err</code></a> * <a href="%60map_or_else%60"><code>map_or_else</code></a> applies the provided function to the contained value of <a href="./core-result.html#ok"><code>Ok</code></a>, or applies the provided default fallback function to the contained value of <a href="./core-result.html#err"><code>Err</code></a><a href="%60map_or%60"><code>map_or</code></a>: ResultTrait::map_or <a href="%60map_or_else%60"><code>map_or_else</code></a>: ResultTrait::map_or_else  ## Boolean operatorsThese methods treat the <a href="./core-result-Result.html"><code>Result</code></a> as a boolean value, where <a href="./core-result.html#ok"><code>Ok</code></a> acts like <a href="%60true%60"><code>true</code></a> and <a href="./core-result.html#err"><code>Err</code></a> acts like <a href="%60false%60"><code>false</code></a>. There are two categories of these methods: ones that take a <a href="./core-result-Result.html"><code>Result</code></a> as input, and ones that take a function as input.The <a href="%60and%60"><code>and</code></a> and <a href="%60or%60"><code>or</code></a> methods take another <a href="./core-result-Result.html"><code>Result</code></a> as input, and produce a <a href="./core-result-Result.html"><code>Result</code></a> as output. The <a href="%60and%60"><code>and</code></a> method can produce a [<code>Result&lt;U, E&gt;</code>](<code>Result&lt;U, E&gt;</code>) value having a different inner type <code>U</code> than [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>). The <a href="%60or%60"><code>or</code></a> method can produce a [<code>Result&lt;T, F&gt;</code>](<code>Result&lt;T, F&gt;</code>) value having a different error type <code>F</code> than [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>).| method  | self     | input     | output   | |---------|----------|-----------|----------| | <a href="%60and%60"><code>and</code></a> | <code>Err(e)</code> | (ignored) | <code>Err(e)</code> | | <a href="%60and%60"><code>and</code></a> | <code>Ok(x)</code>  | <code>Err(d)</code>  | <code>Err(d)</code> | | <a href="%60and%60"><code>and</code></a> | <code>Ok(x)</code>  | <code>Ok(y)</code>   | <code>Ok(y)</code>  | | <a href="%60or%60"><code>or</code></a>  | <code>Err(e)</code> | <code>Err(d)</code>  | <code>Err(d)</code> | | <a href="%60or%60"><code>or</code></a>  | <code>Err(e)</code> | <code>Ok(y)</code>   | <code>Ok(y)</code>  | | <a href="%60or%60"><code>or</code></a>  | <code>Ok(x)</code>  | (ignored) | <code>Ok(x)</code>  |<a href="%60and%60"><code>and</code></a>: ResultTrait::and <a href="%60or%60"><code>or</code></a>: ResultTrait::orThe <a href="%60and_then%60"><code>and_then</code></a> and <a href="%60or_else%60"><code>or_else</code></a> methods take a function as input, and only evaluate the function when they need to produce a new value. The <a href="%60and_then%60"><code>and_then</code></a> method can produce a [<code>Result&lt;U, E&gt;</code>](<code>Result&lt;U, E&gt;</code>) value having a different inner type <code>U</code> than [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>). The <a href="%60or_else%60"><code>or_else</code></a> method can produce a [<code>Result&lt;T, F&gt;</code>](<code>Result&lt;T, F&gt;</code>) value having a different error type <code>F</code> than [<code>Result&lt;T, E&gt;</code>](<code>Result&lt;T, E&gt;</code>).| method       | self     | function input | function result | output   | |--------------|----------|----------------|-----------------|----------| | <a href="%60and_then%60"><code>and_then</code></a> | <code>Err(e)</code> | (not provided) | (not evaluated) | <code>Err(e)</code> | | <a href="%60and_then%60"><code>and_then</code></a> | <code>Ok(x)</code>  | <code>x</code>            | <code>Err(d)</code>        | <code>Err(d)</code> | | <a href="%60and_then%60"><code>and_then</code></a> | <code>Ok(x)</code>  | <code>x</code>            | <code>Ok(y)</code>         | <code>Ok(y)</code>  | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>Err(e)</code> | <code>e</code>            | <code>Err(d)</code>        | <code>Err(d)</code> | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>Err(e)</code> | <code>e</code>            | <code>Ok(y)</code>         | <code>Ok(y)</code>  | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>Ok(x)</code>  | (not provided) | (not evaluated) | <code>Ok(x)</code>  |<a href="%60and_then%60"><code>and_then</code></a>: ResultTrait::and_then <a href="%60or_else%60"><code>or_else</code></a>: ResultTrait::or_else  # The question mark operator, <code>?</code>When writing code that calls many functions that return the <a href="./core-result-Result.html"><code>Result</code></a> type, handling <code>Ok</code>/<code>Err</code> can be tedious. The question mark operator, <code>?</code>, hides some of the boilerplate of propagating errors up the call stack.It replaces this:</a></h1>
<pre><code class="language-cairo">use core::integer::u8_overflowing_add;

fn add_three_numbers(a: u8, b: u8, c: u8) -&gt; Result&lt;u8, u8&gt; {
    match u8_overflowing_add(a, b) {
        Ok(sum_ab) =&gt; {
            match u8_overflowing_add(sum_ab, c) {
                Ok(total) =&gt; Ok(total),
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}
</code></pre>
<p>With this:</p>
<pre><code class="language-cairo">use core::integer::u8_overflowing_add;

fn add_three_numbers_2(a: u8, b: u8, c: u8) -&gt; Result&lt;u8, u8&gt; {
    let total = u8_overflowing_add(u8_overflowing_add(a, b)?, c)?;
    Ok(total)
}
</code></pre>
<p>It's much nicer<img src="./core-result.html#ok" alt="Ok" />: Ok <a href="./core-result.html#err"><code>Err</code></a>: Err  ## Iterating over <code>Result</code>A <a href="./core-result-Result.html"><code>Result</code></a> can be iterated over. This can be helpful if you need an iterator that is conditionally empty. The iterator will either produce a single value (when the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#ok"><code>Ok</code></a>), or produce no values (when the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#err"><code>Err</code></a>). For example, <a href="%60into_iter%60"><code>into_iter</code></a> contains <a href="%60Some(v)%60"><code>Some(v)</code></a> if the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="%60Ok(v)%60"><code>Ok(v)</code></a>, and <a href="./core-option.html#none"><code>None</code></a> if the <a href="./core-result-Result.html"><code>Result</code></a> is <a href="./core-result.html#err"><code>Err</code></a>.</p>
<p>Fully qualified path: <code>core::result</code></p>
<h2 id="enums-3"><a class="header" href="#enums-3">Enums</a></h2>
<ul>
<li><a href="./core-result-Result.html">Result</a></li>
</ul>
<h2 id="traits-8"><a class="header" href="#traits-8">Traits</a></h2>
<ul>
<li><a href="./core-result-ResultTrait.html">ResultTrait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">option</a></h1>
<p>Optional values.The <a href="./core-option-Option.html"><code>Option</code></a> type represents an optional value: every <a href="./core-option-Option.html"><code>Option</code></a> is either <a href="./core-option.html#some"><code>Some</code></a> and contains a value, or <a href="./core-option.html#none"><code>None</code></a>, and does not. <a href="./core-option-Option.html"><code>Option</code></a> types are very common in Cairo code, as they have a number of uses:Initial values * Return values for functions that are not defined over their entire input range (partial functions) * Return value for otherwise reporting simple errors, where <a href="./core-option.html#none"><code>None</code></a> is returned on error * Optional struct fields * Optional function argumentsOptions are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the <code>None</code> case.</p>
<pre><code class="language-cairo">fn divide(numerator: u64, denominator: u64) -&gt; Option&lt;u64&gt; {
    if denominator == 0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

// The return value of the function is an option
let result = divide(2, 3);

// Pattern match to retrieve the value
match result {
    // The division was valid
    Some(x) =&gt; println!("Result: {x}"),
    // The division was invalid
    None    =&gt; println!("Cannot divide by 0"),
}
</code></pre>
<h1 id="the-question-mark-operator-similar-to-the-result-type-when-writing-code-that-calls-many-functions-that-return-the-option-type-handling-somenone-can-be-tedious-the-question-mark-operator--hides-some-of-the-boilerplate-of-propagating-values-up-the-call-stackit-replaces-this"><a class="header" href="#the-question-mark-operator-similar-to-the-result-type-when-writing-code-that-calls-many-functions-that-return-the-option-type-handling-somenone-can-be-tedious-the-question-mark-operator--hides-some-of-the-boilerplate-of-propagating-values-up-the-call-stackit-replaces-this">The question mark operator, <code>?</code>Similar to the <a href="./core-result-Result.html"><code>Result</code></a> type, when writing code that calls many functions that return the <a href="./core-option-Option.html"><code>Option</code></a> type, handling <code>Some</code>/<code>None</code> can be tedious. The question mark operator, <code>?</code>, hides some of the boilerplate of propagating values up the call stack.It replaces this:</a></h1>
<pre><code class="language-cairo">fn add_last_numbers(mut array: Array&lt;u32&gt;) -&gt; Option&lt;u32&gt; {
    let a = array.pop_front();
    let b = array.pop_front();

    match (a, b) {
        (Some(x), Some(y)) =&gt; Some(x + y),
        _ =&gt; None,
    }
}

</code></pre>
<p>With this:</p>
<pre><code class="language-cairo">fn add_last_numbers(mut array: Array&lt;u32&gt;) -&gt; Option&lt;u32&gt; {
    Some(array.pop_front()? + array.pop_front()?)
 }
</code></pre>
<p>It's much nicer!Ending the expression with <code>?</code> will result in the <a href="./core-option.html#some"><code>Some</code></a>'s unwrapped value, unless the result is <a href="./core-option.html#none"><code>None</code></a>, in which case <a href="./core-option.html#none"><code>None</code></a> is returned early from the enclosing function. <code>?</code> can be used in functions that return <a href="./core-option-Option.html"><code>Option</code></a> because of the early return of <a href="./core-option.html#none"><code>None</code></a> that it provides.<a href="./core-option.html#some"><code>Some</code></a>: Some <a href="./core-option.html#none"><code>None</code></a>: None  # Method overviewIn addition to working with pattern matching, <a href="./core-option-Option.html"><code>Option</code></a> provides a wide variety of different methods.  ## Querying the variantThe <a href="%60is_some%60"><code>is_some</code></a> and <a href="%60is_none%60"><code>is_none</code></a> methods return <code>true</code> if the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#some"><code>Some</code></a> or <a href="./core-option.html#none"><code>None</code></a>, respectively.<a href="%60is_none%60"><code>is_none</code></a>: OptionTrait::is_none <a href="%60is_none_or%60"><code>is_none_or</code></a>: OptionTrait::is_none_or <a href="%60is_some%60"><code>is_some</code></a>: OptionTrait::is_some <a href="%60is_some_and%60"><code>is_some_and</code></a>: OptionTrait::is_some_and  ## Extracting the contained valueThese methods extract the contained value in an <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a> when it is the <a href="./core-option.html#some"><code>Some</code></a> variant. If the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#none"><code>None</code></a>:<a href="%60expect%60"><code>expect</code></a> panics with a provided custom message * <a href="%60unwrap%60"><code>unwrap</code></a> panics with a generic message * <a href="%60unwrap_or%60"><code>unwrap_or</code></a> returns the provided default value * <a href="%60unwrap_or_default%60"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code> (which must implement the <a href="./core-traits-Default.html"><code>Default</code></a> trait) * <a href="%60unwrap_or_else%60"><code>unwrap_or_else</code></a> returns the result of evaluating the provided function<a href="%60expect%60"><code>expect</code></a>: OptionTrait::expect <a href="%60unwrap%60"><code>unwrap</code></a>: OptionTrait::unwrap <a href="%60unwrap_or%60"><code>unwrap_or</code></a>: OptionTrait::unwrap_or <a href="%60unwrap_or_default%60"><code>unwrap_or_default</code></a>: OptionTrait::unwrap_or_default <a href="%60unwrap_or_else%60"><code>unwrap_or_else</code></a>: OptionTrait::unwrap_or_else  ## Transforming contained valuesThese methods transform <a href="./core-option-Option.html"><code>Option</code></a> to <a href="./core-result-Result.html"><code>Result</code></a>:<a href="%60ok_or%60"><code>ok_or</code></a> transforms <a href="%60Some(v)%60"><code>Some(v)</code></a> to <a href="%60Ok(v)%60"><code>Ok(v)</code></a>, and <a href="./core-option.html#none"><code>None</code></a> to <a href="%60Err(err)%60"><code>Err(err)</code></a> using the provided default <code>err</code> value. * <a href="%60ok_or_else%60"><code>ok_or_else</code></a> transforms <a href="%60Some(v)%60"><code>Some(v)</code></a> to <a href="%60Ok(v)%60"><code>Ok(v)</code></a>, and <a href="./core-option.html#none"><code>None</code></a> to a value of <a href="./core-result.html#err"><code>Err</code></a> using the provided function<a href="%60Err(err)%60"><code>Err(err)</code></a>: Err <a href="%60Ok(v)%60"><code>Ok(v)</code></a>: Ok <a href="%60Some(v)%60"><code>Some(v)</code></a>: Some <a href="%60ok_or%60"><code>ok_or</code></a>: OptionTrait::ok_or <a href="%60ok_or_else%60"><code>ok_or_else</code></a>: OptionTrait::ok_or_elseThese methods transform the <a href="./core-option.html#some"><code>Some</code></a> variant:<a href="%60map%60"><code>map</code></a> transforms <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a> to <a href="%60Option%3CU%3E%60"><code>Option&lt;U&gt;</code></a> by applying the provided function to the contained value of <a href="./core-option.html#some"><code>Some</code></a> and leaving <a href="./core-option.html#none"><code>None</code></a> values unchangedThese methods transform <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a> to a value of a possibly different type <code>U</code>:<a href="%60map_or%60"><code>map_or</code></a> applies the provided function to the contained value of <a href="./core-option.html#some"><code>Some</code></a>, or returns the provided default value if the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#none"><code>None</code></a> * <a href="%60map_or_else%60"><code>map_or_else</code></a> applies the provided function to the contained value of <a href="./core-option.html#some"><code>Some</code></a>, or returns the result of evaluating the provided fallback function if the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#none"><code>None</code></a><a href="%60map_or%60"><code>map_or</code></a>: OptionTrait::map_or <a href="%60map_or_else%60"><code>map_or_else</code></a>: OptionTrait::map_or_else  ## Boolean operatorsThese methods treat the <a href="./core-option-Option.html"><code>Option</code></a> as a boolean value, where <a href="./core-option.html#some"><code>Some</code></a> acts like <a href="%60true%60"><code>true</code></a> and <a href="./core-option.html#none"><code>None</code></a> acts like <a href="%60false%60"><code>false</code></a>. There are two categories of these methods: ones that take an <a href="./core-option-Option.html"><code>Option</code></a> as input, and ones that take a function as input (to be lazily evaluated).The <a href="%60and%60"><code>and</code></a>, <a href="%60or%60"><code>or</code></a>, and <a href="%60xor%60"><code>xor</code></a> methods take another <a href="./core-option-Option.html"><code>Option</code></a> as input, and produce an <a href="./core-option-Option.html"><code>Option</code></a> as output. Only the <a href="%60and%60"><code>and</code></a> method can produce an <a href="%60Option%3CU%3E%60"><code>Option&lt;U&gt;</code></a> value having a different inner type <code>U</code> than <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a>.| method  | self      | input     | output    | |---------|-----------|-----------|-----------| | <a href="%60and%60"><code>and</code></a> | <code>None</code>    | (ignored) | <code>None</code>    | | <a href="%60and%60"><code>and</code></a> | <code>Some(x)</code> | <code>None</code>    | <code>None</code>    | | <a href="%60and%60"><code>and</code></a> | <code>Some(x)</code> | <code>Some(y)</code> | <code>Some(y)</code> | | <a href="%60or%60"><code>or</code></a>  | <code>None</code>    | <code>None</code>    | <code>None</code>    | | <a href="%60or%60"><code>or</code></a>  | <code>None</code>    | <code>Some(y)</code> | <code>Some(y)</code> | | <a href="%60or%60"><code>or</code></a>  | <code>Some(x)</code> | (ignored) | <code>Some(x)</code> | | <a href="%60xor%60"><code>xor</code></a> | <code>None</code>    | <code>None</code>    | <code>None</code>    | | <a href="%60xor%60"><code>xor</code></a> | <code>None</code>    | <code>Some(y)</code> | <code>Some(y)</code> | | <a href="%60xor%60"><code>xor</code></a> | <code>Some(x)</code> | <code>None</code>    | <code>Some(x)</code> | | <a href="%60xor%60"><code>xor</code></a> | <code>Some(x)</code> | <code>Some(y)</code> | <code>None</code>    |<a href="%60and%60"><code>and</code></a>: OptionTrait::and <a href="%60or%60"><code>or</code></a>: OptionTrait::or <a href="%60xor%60"><code>xor</code></a>: OptionTrait::xorThe <a href="%60and_then%60"><code>and_then</code></a> and <a href="%60or_else%60"><code>or_else</code></a> methods take a function as input, and only evaluate the function when they need to produce a new value. Only the <a href="%60and_then%60"><code>and_then</code></a> method can produce an <a href="%60Option%3CU%3E%60"><code>Option&lt;U&gt;</code></a> value having a different inner type <code>U</code> than <a href="%60Option%3CT%3E%60"><code>Option&lt;T&gt;</code></a>.| method       | self      | function input | function result | output    | |--------------|-----------|----------------|-----------------|-----------| | <a href="%60and_then%60"><code>and_then</code></a> | <code>None</code>    | (not provided) | (not evaluated) | <code>None</code>    | | <a href="%60and_then%60"><code>and_then</code></a> | <code>Some(x)</code> | <code>x</code>            | <code>None</code>          | <code>None</code>    | | <a href="%60and_then%60"><code>and_then</code></a> | <code>Some(x)</code> | <code>x</code>            | <code>Some(y)</code>       | <code>Some(y)</code> | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>None</code>    | (not provided) | <code>None</code>          | <code>None</code>    | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>None</code>    | (not provided) | <code>Some(y)</code>       | <code>Some(y)</code> | | <a href="%60or_else%60"><code>or_else</code></a>  | <code>Some(x)</code> | (not provided) | (not evaluated) | <code>Some(x)</code> |<a href="%60and_then%60"><code>and_then</code></a>: OptionTrait::and_then <a href="%60or_else%60"><code>or_else</code></a>: OptionTrait::or_else ## Iterating over <code>Option</code>An <a href="./core-option-Option.html"><code>Option</code></a> can be iterated over. This can be helpful if you need an iterator that is conditionally empty. The iterator will either produce a single value (when the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#some"><code>Some</code></a>), or produce no values (when the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#none"><code>None</code></a>). For example, <a href="%60into_iter%60"><code>into_iter</code></a> contains <a href="%60Some(v)%60"><code>Some(v)</code></a> if the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="%60Some(v)%60"><code>Some(v)</code></a>, and <a href="./core-option.html#none"><code>None</code></a> if the <a href="./core-option-Option.html"><code>Option</code></a> is <a href="./core-option.html#none"><code>None</code></a>.</p>
<p>Fully qualified path: <code>core::option</code></p>
<h2 id="structs-2"><a class="header" href="#structs-2">Structs</a></h2>
<ul>
<li><a href="./core-option-OptionIter.html">OptionIter</a></li>
</ul>
<h2 id="enums-4"><a class="header" href="#enums-4">Enums</a></h2>
<ul>
<li><a href="./core-option-Option.html">Option</a></li>
</ul>
<h2 id="traits-9"><a class="header" href="#traits-9">Traits</a></h2>
<ul>
<li><a href="./core-option-OptionTrait.html">OptionTrait</a></li>
</ul>
<h2 id="impls-2"><a class="header" href="#impls-2">Impls</a></h2>
<ul>
<li><a href="./core-option-DestructOption.html">DestructOption</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">clone</a></h1>
<p>The <code>Clone</code> trait provides the ability to duplicate instances of types that cannot be 'implicitly copied'.In Cairo, some simple types are "implicitly copyable": when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy, and are not at risk of accessing un-allocated memory, so the compiler considers them cheap and safe to copy. For other types, copies must be made explicitly, by convention implementing the <a href="./core-clone-Clone.html"><code>Clone</code></a> trait and calling the <a href="%60Clone::clone%60"><code>Clone::clone</code></a> method.  # Examples</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let cloned_arr = arr.clone();
assert!(arr == cloned_arr);
</code></pre>
<p>You can use the <code>#[derive(Clone)]</code> attribute to automatically generate the implementation for your type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Clone, Drop)]
</span>struct Sheep {
   name: ByteArray,
   age: u8,
}

fn main() {
   let dolly = Sheep {
       name: "Dolly",
       age: 6,
   };

   let cloned_sheep = dolly.clone();  // Famous cloned sheep!
}
</code></pre>
<p>Fully qualified path: <code>core::clone</code></p>
<h2 id="traits-10"><a class="header" href="#traits-10">Traits</a></h2>
<ul>
<li><a href="./core-clone-Clone.html">Clone</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec"><a class="header" href="#ec">ec</a></h1>
<p>Functions and constructs related to elliptic curve operations on the STARK curve.This module provides implementations for various elliptic curve operations tailored for the STARK curve.Curve information: * Curve equation: yÂ² â‰¡ xÂ³ + Î±Â·x + Î² (mod p) * Î± = 1 * Î² = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89 * p = 0x0800000000000011000000000000000000000000000000000000000000000001 = 2^251 + 17 * 2^192 + 1 Generator point: * x = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca * y = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f  # ExamplesCreating points and basic operations:</p>
<pre><code class="language-cairo">// Create a point from coordinates
let point = EcPointTrait::new(
    x: 336742005567258698661916498343089167447076063081786685068305785816009957563,
    y: 1706004133033694959518200210163451614294041810778629639790706933324248611779,
).unwrap();

// Perform scalar multiplication
let result = point.mul(2);

// Add points
let sum = point + result;

// Subtract points
let diff = result - point;
</code></pre>
<p>Using EC state for batch operations:</p>
<pre><code class="language-cairo">let p = EcPointTrait::new_from_x(1).unwrap();
let p_nz = p.try_into().unwrap();

// Initialize state
let mut state = EcStateTrait::init();

// Add points and scalar multiplications
state.add(p_nz);
state.add_mul(1, p_nz);

// Get the final result
let _result = state.finalize();
</code></pre>
<p>Fully qualified path: <code>core::ec</code></p>
<h2 id="modules-2"><a class="header" href="#modules-2">Modules</a></h2>
<ul>
<li><a href="./core-ec-stark_curve.html">stark_curve</a></li>
</ul>
<h2 id="type-aliases-2"><a class="header" href="#type-aliases-2">Type aliases</a></h2>
<ul>
<li><a href="./core-ec-NonZeroEcPoint.html">NonZeroEcPoint</a></li>
</ul>
<h2 id="traits-11"><a class="header" href="#traits-11">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcStateTrait.html">EcStateTrait</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointTrait.html">EcPointTrait</a></p>
</li>
</ul>
<h2 id="impls-3"><a class="header" href="#impls-3">Impls</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcStateImpl.html">EcStateImpl</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointImpl.html">EcPointImpl</a></p>
</li>
</ul>
<h2 id="extern-types-6"><a class="header" href="#extern-types-6">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcOp.html">EcOp</a></p>
</li>
<li>
<p><a href="./core-ec-EcPoint.html">EcPoint</a></p>
</li>
<li>
<p><a href="./core-ec-EcState.html">EcState</a></p>
</li>
</ul>
<h2 id="extern-functions-3"><a class="header" href="#extern-functions-3">Extern functions</a></h2>
<ul>
<li><a href="./core-ec-ec_point_unwrap.html">ec_point_unwrap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecdsa"><a class="header" href="#ecdsa">ecdsa</a></h1>
<p>Elliptic Curve Digital Signature Algorithm (ECDSA) for the STARK curve.This module provides implementations for ECDSA signature verification and public key recovery specifically tailored for the STARK curve.Curve information: * Curve equation: yÂ² â‰¡ xÂ³ + Î±Â·x + Î² (mod p) * Î± = 1 * Î² = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89 * p = 0x0800000000000011000000000000000000000000000000000000000000000001 = 2^251 + 17 * 2^192 + 1 Generator point: * x = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca * y = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f</p>
<p>Fully qualified path: <code>core::ecdsa</code></p>
<h2 id="free-functions-2"><a class="header" href="#free-functions-2">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-ecdsa-check_ecdsa_signature.html">check_ecdsa_signature</a></p>
</li>
<li>
<p><a href="./core-ecdsa-recover_public_key.html">recover_public_key</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer"><a class="header" href="#integer">integer</a></h1>
<p>Integer types and operations.This module provides the built-in integer types and their associated operations.  # Integer TypesThe following integer types are available:Unsigned integers: <a href="./core-integer-u8.html"><code>u8</code></a>, <a href="./core-integer-u16.html"><code>u16</code></a>, <a href="./core-integer-u32.html"><code>u32</code></a>, <a href="./core-integer-u64.html"><code>u64</code></a>, <a href="./core-integer-u128.html"><code>u128</code></a>, <a href="./core-integer-u256.html"><code>u256</code></a> * Signed integers: <a href="./core-integer-i8.html"><code>i8</code></a>, <a href="./core-integer-i16.html"><code>i16</code></a>, <a href="./core-integer-i32.html"><code>i32</code></a>, <a href="./core-integer-i64.html"><code>i64</code></a>, <a href="./core-integer-i128.html"><code>i128</code></a>  # OperationsInteger types implement various traits that enable common operations:Basic arithmetic via <a href="./core-traits-Add.html"><code>Add</code></a>, <a href="./core-traits-Sub.html"><code>Sub</code></a>, <a href="./core-traits-Mul.html"><code>Mul</code></a>, <a href="./core-traits-Div.html"><code>Div</code></a>, <a href="./core-traits-Rem.html"><code>Rem</code></a> and <a href="./core-traits-DivRem.html"><code>DivRem</code></a> * Bitwise operations via <a href="./core-traits-BitAnd.html"><code>BitAnd</code></a>, <a href="./core-traits-BitOr.html"><code>BitOr</code></a>, <a href="./core-traits-BitXor.html"><code>BitXor</code></a>, and <a href="./core-traits-BitNot.html"><code>BitNot</code></a> * Comparison via <a href="./core-traits-PartialEq.html"><code>PartialEq</code></a> and <a href="./core-traits-PartialOrd.html"><code>PartialOrd</code></a> * Safe arithmetic via <a href="%60CheckedAdd%60"><code>CheckedAdd</code></a>, <a href="%60CheckedSub%60"><code>CheckedSub</code></a>, <a href="%60CheckedMul%60"><code>CheckedMul</code></a> * Wrapping arithmetic via <a href="%60WrappingAdd%60"><code>WrappingAdd</code></a>, <a href="%60WrappingSub%60"><code>WrappingSub</code></a>, <a href="%60WrappingMul%60"><code>WrappingMul</code></a> * Overflow handling via <a href="%60OverflowingAdd%60"><code>OverflowingAdd</code></a>, <a href="%60OverflowingSub%60"><code>OverflowingSub</code></a>, <a href="%60OverflowingMul%60"><code>OverflowingMul</code></a><a href="./core-traits-Add.html"><code>Add</code></a>: crate::traits::Add <a href="./core-traits-Sub.html"><code>Sub</code></a>: crate::traits::Sub <a href="./core-traits-Mul.html"><code>Mul</code></a>: crate::traits::Mul <a href="./core-traits-Div.html"><code>Div</code></a>: crate::traits::Div <a href="./core-traits-Rem.html"><code>Rem</code></a>: crate::traits::Rem <a href="./core-traits-DivRem.html"><code>DivRem</code></a>: crate::traits::DivRem <a href="%60CheckedAdd%60"><code>CheckedAdd</code></a>: crate::num::traits::ops::checked::CheckedAdd <a href="%60CheckedSub%60"><code>CheckedSub</code></a>: crate::num::traits::ops::checked::CheckedSub <a href="%60CheckedMul%60"><code>CheckedMul</code></a>: crate::num::traits::ops::checked::CheckedMul <a href="%60WrappingAdd%60"><code>WrappingAdd</code></a>: crate::num::traits::ops::wrapping::WrappingAdd <a href="%60WrappingSub%60"><code>WrappingSub</code></a>: crate::num::traits::ops::wrapping::WrappingSub <a href="%60WrappingMul%60"><code>WrappingMul</code></a>: crate::num::traits::ops::wrapping::WrappingMul <a href="%60OverflowingAdd%60"><code>OverflowingAdd</code></a>: crate::num::traits::ops::overflowing::OverflowingAdd <a href="%60OverflowingSub%60"><code>OverflowingSub</code></a>: crate::num::traits::ops::overflowing::OverflowingSub <a href="%60OverflowingMul%60"><code>OverflowingMul</code></a>: crate::num::traits::ops::overflowing::OverflowingMul  # ExamplesBasic operators:</p>
<pre><code class="language-cairo">let a: u8 = 5;
let b: u8 = 10;
assert_eq!(a + b, 15);
assert_eq!(a * b, 50);
assert_eq!(a &amp; b, 0);
assert!(a &lt; b);
</code></pre>
<p>Checked operations:</p>
<pre><code class="language-cairo">use core::num::traits::{CheckedAdd, Bounded};

let max: u8 = Bounded::MAX;
assert!(max.checked_add(1_u8).is_none());
</code></pre>
<h1 id="conversionsintegers-can-be-converted-between-different-types-usingtryinto-for-potentially-fallible-conversions--into-for-infallible-conversions-to-wider-types"><a class="header" href="#conversionsintegers-can-be-converted-between-different-types-usingtryinto-for-potentially-fallible-conversions--into-for-infallible-conversions-to-wider-types">ConversionsIntegers can be converted between different types using:<a href="./core-traits-TryInto.html"><code>TryInto</code></a> for potentially fallible conversions * <a href="./core-traits-Into.html"><code>Into</code></a> for infallible conversions to wider types</a></h1>
<p>Fully qualified path: <code>core::integer</code></p>
<h2 id="free-functions-3"><a class="header" href="#free-functions-3">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128_wrapping_add.html">u128_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_sub.html">u128_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wide_mul.html">u128_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_mul.html">u128_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_add.html">u8_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_sub.html">u8_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_add.html">u16_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_sub.html">u16_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_add.html">u32_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_sub.html">u32_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_add.html">u64_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_sub.html">u64_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_add.html">u256_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_sub.html">u256_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_sub.html">u256_overflow_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_mul.html">u256_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_mul.html">u256_overflow_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_wide_mul.html">u256_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u512_safe_div_rem_by_u256.html">u512_safe_div_rem_by_u256</a></p>
</li>
</ul>
<h2 id="structs-3"><a class="header" href="#structs-3">Structs</a></h2>
<ul>
<li>
<p><a href="./core-integer-u256.html">u256</a></p>
</li>
<li>
<p><a href="./core-integer-u512.html">u512</a></p>
</li>
</ul>
<h2 id="traits-12"><a class="header" href="#traits-12">Traits</a></h2>
<ul>
<li>
<p><a href="./core-integer-NumericLiteral.html">NumericLiteral</a></p>
</li>
<li>
<p><a href="./core-integer-BoundedInt.html">BoundedInt</a></p>
</li>
</ul>
<h2 id="extern-types-7"><a class="header" href="#extern-types-7">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128.html">u128</a></p>
</li>
<li>
<p><a href="./core-integer-U128MulGuarantee.html">U128MulGuarantee</a></p>
</li>
<li>
<p><a href="./core-integer-Bitwise.html">Bitwise</a></p>
</li>
<li>
<p><a href="./core-integer-u8.html">u8</a></p>
</li>
<li>
<p><a href="./core-integer-u16.html">u16</a></p>
</li>
<li>
<p><a href="./core-integer-u32.html">u32</a></p>
</li>
<li>
<p><a href="./core-integer-u64.html">u64</a></p>
</li>
<li>
<p><a href="./core-integer-i8.html">i8</a></p>
</li>
<li>
<p><a href="./core-integer-i16.html">i16</a></p>
</li>
<li>
<p><a href="./core-integer-i32.html">i32</a></p>
</li>
<li>
<p><a href="./core-integer-i64.html">i64</a></p>
</li>
<li>
<p><a href="./core-integer-i128.html">i128</a></p>
</li>
</ul>
<h2 id="extern-functions-4"><a class="header" href="#extern-functions-4">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128_overflowing_add.html">u128_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_sub.html">u128_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_sqrt.html">u128_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u128_safe_divmod.html">u128_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u128_byte_reverse.html">u128_byte_reverse</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_add.html">u8_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_sub.html">u8_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wide_mul.html">u8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_sqrt.html">u8_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u8_safe_divmod.html">u8_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_add.html">u16_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_sub.html">u16_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wide_mul.html">u16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u16_sqrt.html">u16_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u16_safe_divmod.html">u16_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_add.html">u32_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_sub.html">u32_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wide_mul.html">u32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u32_sqrt.html">u32_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u32_safe_divmod.html">u32_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_add.html">u64_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_sub.html">u64_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wide_mul.html">u64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u64_sqrt.html">u64_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u64_safe_divmod.html">u64_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u256_sqrt.html">u256_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-i8_wide_mul.html">i8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i8_diff.html">i8_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i16_wide_mul.html">i16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i16_diff.html">i16_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i32_wide_mul.html">i32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i32_diff.html">i32_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i64_wide_mul.html">i64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i64_diff.html">i64_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i128_diff.html">i128_diff</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmp"><a class="header" href="#cmp">cmp</a></h1>
<p>Utilities for comparing and ordering values. This module contains functions that rely on the <code>PartialOrd</code> trait for comparing values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::{min, max, minmax};

assert!(min(10, 20) == 10);
assert!(max(10, 20) == 20);

assert!(minmax(20, 10) == (10, 20));
assert!(minmax(10, 20) == (10, 20));
</code></pre>
<p>Fully qualified path: <code>core::cmp</code></p>
<h2 id="free-functions-4"><a class="header" href="#free-functions-4">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-cmp-min.html">min</a></p>
</li>
<li>
<p><a href="./core-cmp-max.html">max</a></p>
</li>
<li>
<p><a href="./core-cmp-minmax.html">minmax</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas"><a class="header" href="#gas">gas</a></h1>
<p>Utilities for handling gas in Cairo code.</p>
<p>Fully qualified path: <code>core::gas</code></p>
<h2 id="extern-types-8"><a class="header" href="#extern-types-8">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-gas-BuiltinCosts.html">BuiltinCosts</a></p>
</li>
<li>
<p><a href="./core-gas-GasBuiltin.html">GasBuiltin</a></p>
</li>
</ul>
<h2 id="extern-functions-5"><a class="header" href="#extern-functions-5">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-gas-withdraw_gas.html">withdraw_gas</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas_all.html">withdraw_gas_all</a></p>
</li>
<li>
<p><a href="./core-gas-redeposit_gas.html">redeposit_gas</a></p>
</li>
<li>
<p><a href="./core-gas-get_builtin_costs.html">get_builtin_costs</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">math</a></h1>
<p>Mathematical operations and utilities.Provides extended GCD, modular inverse, and modular arithmetic operations.</p>
<p>Fully qualified path: <code>core::math</code></p>
<h2 id="free-functions-5"><a class="header" href="#free-functions-5">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-math-egcd.html">egcd</a></p>
</li>
<li>
<p><a href="./core-math-inv_mod.html">inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_inv_mod.html">u256_inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_div_mod_n.html">u256_div_mod_n</a></p>
</li>
<li>
<p><a href="./core-math-u256_mul_mod_n.html">u256_mul_mod_n</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="num"><a class="header" href="#num">num</a></h1>
<p>Fully qualified path: <code>core::num</code></p>
<h2 id="modules-3"><a class="header" href="#modules-3">Modules</a></h2>
<ul>
<li><a href="./core-num-traits.html">traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ops"><a class="header" href="#ops">ops</a></h1>
<p>Overloadable operators.Implementing these traits allows you to overload certain operators.Note: Other overloadable operators are also defined in the <a href="./core-traits.html"><code>core::traits</code></a> module.Only operators backed by traits can be overloaded. For example, the addition assignment operator (<code>+=</code>) can be overloaded through the <a href="%60AddAssign%60"><code>AddAssign</code></a> trait, but since the assignment operator (<code>=</code>) has no backing trait, there is no way of overloading its semantics. Additionally, this module does not provide any mechanism to create new operators.Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and operator precedence. For example, when implementing <a href="%60MulAssign%60"><code>MulAssign</code></a>, the operation should have some resemblance to multiplication assignment.  # ExamplesThis example creates a <code>Point</code> struct that implements <a href="%60AddAssign%60"><code>AddAssign</code></a> and <a href="%60SubAssign%60"><code>SubAssign</code></a>, and then demonstrates adding and subtracting two <code>Point</code>s to themselves.</p>
<pre><code class="language-cairo">use core::ops::{AddAssign, SubAssign};

<span class="boring">[derive(Debug, Drop, Copy, PartialEq)]
</span>struct Point {
    x: i32,
    y: i32,
}

impl AddAssignImpl of AddAssign&lt;Point, Point&gt; {
    fn add_assign(ref self: Point, rhs: Point) {
        self = Point { x: self.x + rhs.x, y: self.y + rhs.y }
    }
}

impl SubAssignImpl of SubAssign&lt;Point, Point&gt; {
    fn sub_assign(ref self: Point, rhs: Point) {
        self = Point { x: self.x - rhs.x, y: self.y - rhs.y }
    }
}

fn main() {
    let mut point = Point {x : 3, y: 4};
    point += point;
    assert!(point == Point {x: 6, y: 8});
    point -= point;
    assert!(point == Point {x: 0, y: 0});
}
</code></pre>
<p>See the documentation for each trait for an example implementation.</p>
<p>Fully qualified path: <code>core::ops</code></p>
<h2 id="modules-4"><a class="header" href="#modules-4">Modules</a></h2>
<ul>
<li><a href="./core-ops-index.html">index</a></li>
</ul>
<h2 id="structs-4"><a class="header" href="#structs-4">Structs</a></h2>
<ul>
<li>
<p><a href="./core-ops-range-Range.html">Range</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusive.html">RangeInclusive</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusiveIterator.html">RangeInclusiveIterator</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeIterator.html">RangeIterator</a></p>
</li>
</ul>
<h2 id="traits-13"><a class="header" href="#traits-13">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ops-arith-AddAssign.html">AddAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-DivAssign.html">DivAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-MulAssign.html">MulAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-RemAssign.html">RemAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-SubAssign.html">SubAssign</a></p>
</li>
<li>
<p><a href="./core-ops-deref-Deref.html">Deref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-DerefMut.html">DerefMut</a></p>
</li>
<li>
<p><a href="./core-ops-function-Fn.html">Fn</a></p>
</li>
<li>
<p><a href="./core-ops-function-FnOnce.html">FnOnce</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">Index</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusiveTrait.html">RangeInclusiveTrait</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeTrait.html">RangeTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">panics</a></h1>
<p>Core panic mechanism.This module provides the core panic functionality used for error handling in Cairo. It defines the basic types and functions used to trigger and manage panics, which are Cairo's mechanism for handling unrecoverable errors.Panics can be triggered in several ways:Using the <code>panic</code> function:</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Or using the <code>panic!</code> macro:</p>
<pre><code class="language-cairo">panic!("Panic message");
</code></pre>
<p>This macro internally converts the message into a <code>ByteArray</code> and uses <code>panic_with_byte_array</code>.</p>
<p>Fully qualified path: <code>core::panics</code></p>
<h2 id="free-functions-6"><a class="header" href="#free-functions-6">Free functions</a></h2>
<ul>
<li><a href="./core-panics-panic_with_byte_array.html">panic_with_byte_array</a></li>
</ul>
<h2 id="structs-5"><a class="header" href="#structs-5">Structs</a></h2>
<ul>
<li><a href="./core-panics-Panic.html">Panic</a></li>
</ul>
<h2 id="enums-5"><a class="header" href="#enums-5">Enums</a></h2>
<ul>
<li><a href="./core-panics-PanicResult.html">PanicResult</a></li>
</ul>
<h2 id="extern-functions-6"><a class="header" href="#extern-functions-6">Extern functions</a></h2>
<ul>
<li><a href="./core-panics-panic.html">panic</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash"><a class="header" href="#hash">hash</a></h1>
<p>Generic hashing support.This module provides a hash state abstraction that can be updated with values and finalized to produce a hash. This allows for flexible and efficient hashing of any type with different hash functions.The simplest way to make a type hashable is to use <code>#[derive(Hash)]</code>. Hashing a value is done by initiating a <code>HashState</code> corresponding to a hash function, updating it with the value, and then finalizing it to get the hash result.  # ExamplesBasic usage with Pedersen and Poseidon hash:</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::poseidon::PoseidonTrait;

<span class="boring">[derive(Copy, Drop, Hash)]
</span>struct Person {
    id: u32,
    phone: u64,
}

fn main() {
  let person1 = Person { id: 1, phone: 555_666_7777 };
  let person2 = Person { id: 2, phone: 555_666_7778 };

  assert!(
      PedersenTrait::new(0)
          .update_with(person1)
          .finalize() != PedersenTrait::new(0)
          .update_with(person2)
          .finalize(),
  );
  assert!(
      PoseidonTrait::new()
          .update_with(person1)
          .finalize() != PoseidonTrait::new()
          .update_with(person2)
          .finalize(),
  );
}
</code></pre>
<p>Fully qualified path: <code>core::hash</code></p>
<h2 id="modules-5"><a class="header" href="#modules-5">Modules</a></h2>
<ul>
<li><a href="./core-hash-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="traits-14"><a class="header" href="#traits-14">Traits</a></h2>
<ul>
<li>
<p><a href="./core-hash-HashStateTrait.html">HashStateTrait</a></p>
</li>
<li>
<p><a href="./core-hash-Hash.html">Hash</a></p>
</li>
<li>
<p><a href="./core-hash-LegacyHash.html">LegacyHash</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateExTrait.html">HashStateExTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak"><a class="header" href="#keccak">keccak</a></h1>
<p>Keccak-256 cryptographic hash function implementation.  # Main Functions<a href="%60keccak_u256s_le_inputs%60"><code>keccak_u256s_le_inputs</code></a> - Hash multiple <code>u256</code> values in little-endian format - <a href="%60keccak_u256s_be_inputs%60"><code>keccak_u256s_be_inputs</code></a> - Hash multiple <code>u256</code> values in big-endian format - <a href="%60cairo_keccak%60"><code>cairo_keccak</code></a> - Hash u64 words with a final partial word. Closest to the syscall input. - <a href="%60compute_keccak_byte_array%60"><code>compute_keccak_byte_array</code></a> - Hash a <code>ByteArray</code> directly  # Examples</p>
<pre><code class="language-cairo">use core::keccak::*;

// Hash u256 values
let input = array![1_u256, 2_u256].span();
assert!(keccak_u256s_le_inputs(input) ==
0x234a9e12e9b063b60f7e3289ee9b86a731de8e7e41bd4987f10982d6a753444d);
assert!(keccak_u256s_be_inputs(input) ==
0xe0c2a7d2cc99d544061ac0ccbb083ac8976e54eed878fb1854dfe7b6ce7b0be9);

// Hash a `Bytearray`
let text: ByteArray = "Hello, Keccak!";
assert!(compute_keccak_byte_array(@text) ==
0x85c9aab73219c1e95c5b5966a4ecc8db4418c3500072a830cfb5a2d13d2c2249);
</code></pre>
<p>Fully qualified path: <code>core::keccak</code></p>
<h2 id="free-functions-7"><a class="header" href="#free-functions-7">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-keccak-keccak_u256s_le_inputs.html">keccak_u256s_le_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_be_inputs.html">keccak_u256s_be_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-cairo_keccak.html">cairo_keccak</a></p>
</li>
<li>
<p><a href="./core-keccak-compute_keccak_byte_array.html">compute_keccak_byte_array</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen"><a class="header" href="#pedersen">pedersen</a></h1>
<p>Pedersen hash related traits implementations.This module provides an implementation of the Pedersen hash function, which is a collision-resistant cryptographic hash function.The <code>HashState</code> struct represents the state of a Pedersen hash computation. It contains a single <code>felt252</code> field <code>state</code> that holds the current hash value.The <code>PedersenTrait</code> provides a <code>new</code> method to create a new <code>HashState</code> from a base value.The <a href="%60HashStateTrait%60"><code>HashStateTrait</code></a> defined in the Hash module provides the <code>update</code> and <code>finalize</code> methods to update the hash state and obtain the final hash value, respectively.  # Examples</p>
<pre><code class="language-cairo">use core::hash::HashStateTrait;
use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
state = state.update(1);
state = state.update(2);
let hash = state.finalize();
assert!(hash == 0x07546be9ecb576c12cd00962356afd90b615d8ef50605bc13badfd1fd218c0d5);
</code></pre>
<p>Fully qualified path: <code>core::pedersen</code></p>
<h2 id="structs-6"><a class="header" href="#structs-6">Structs</a></h2>
<ul>
<li><a href="./core-pedersen-HashState.html">HashState</a></li>
</ul>
<h2 id="traits-15"><a class="header" href="#traits-15">Traits</a></h2>
<ul>
<li><a href="./core-pedersen-PedersenTrait.html">PedersenTrait</a></li>
</ul>
<h2 id="impls-4"><a class="header" href="#impls-4">Impls</a></h2>
<ul>
<li><a href="./core-pedersen-PedersenImpl.html">PedersenImpl</a></li>
</ul>
<h2 id="extern-types-9"><a class="header" href="#extern-types-9">Extern types</a></h2>
<ul>
<li><a href="./core-pedersen-Pedersen.html">Pedersen</a></li>
</ul>
<h2 id="extern-functions-7"><a class="header" href="#extern-functions-7">Extern functions</a></h2>
<ul>
<li><a href="./core-pedersen-pedersen.html">pedersen</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde"><a class="header" href="#serde">serde</a></h1>
<p>Serialization and deserialization of data structures.This module provides traits and implementations for converting Cairo types into a sequence of <code>felt252</code> values (serialization) and back (deserialization).When passing values between Cairo and an external environment, serialization and deserialization are necessary to convert Cairo's data types into a sequence of <code>felt252</code> values, as <code>felt252</code> is the fundamental type of the language.  # The <code>Serde</code> TraitAll types that need to be serialized must implement the <code>Serde</code> trait. This includes both simple types that serialize to a single <code>felt252</code> and compound types (like <code>u256</code>) that require multiple <code>felt252</code> values.</p>
<p>Fully qualified path: <code>core::serde</code></p>
<h2 id="modules-6"><a class="header" href="#modules-6">Modules</a></h2>
<ul>
<li><a href="./core-serde-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="traits-16"><a class="header" href="#traits-16">Traits</a></h2>
<ul>
<li><a href="./core-serde-Serde.html">Serde</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256"><a class="header" href="#sha256">sha256</a></h1>
<p>Implementation of the SHA-256 cryptographic hash function.This module provides functions to compute SHA-256 hashes of data. The input data can be an array of 32-bit words, or a <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_byte_array;

let data = "Hello";
let hash = compute_sha256_byte_array(@data);
assert!(hash == [0x185f8db3, 0x2271fe25, 0xf561a6fc, 0x938b2e26, 0x4306ec30, 0x4eda5180,
0x7d17648, 0x26381969]);
</code></pre>
<p>Fully qualified path: <code>core::sha256</code></p>
<h2 id="free-functions-8"><a class="header" href="#free-functions-8">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-sha256-compute_sha256_u32_array.html">compute_sha256_u32_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_byte_array.html">compute_sha256_byte_array</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon"><a class="header" href="#poseidon">poseidon</a></h1>
<p>Poseidon hash related traits implementations and functions.This module provides cryptographic hash functions based on the Poseidon permutation.The Poseidon hash function is an arithmetic-friendly hash function optimized for use in zero-knowledge proof systems. This module implements the Poseidon hash using a sponge construction for arbitrary-length inputs.  # Examples</p>
<pre><code class="language-cairo">use core::hash::HashStateTrait;
use core::poseidon::PoseidonTrait;

// Create a new hash state
let mut state = PoseidonTrait::new();

// Update with values
state = state.update(1);
state = state.update(2);

// Finalize to get the hash
let hash = state.finalize();
</code></pre>
<p>Fully qualified path: <code>core::poseidon</code></p>
<h2 id="free-functions-9"><a class="header" href="#free-functions-9">Free functions</a></h2>
<ul>
<li><a href="./core-poseidon-poseidon_hash_span.html">poseidon_hash_span</a></li>
</ul>
<h2 id="structs-7"><a class="header" href="#structs-7">Structs</a></h2>
<ul>
<li><a href="./core-poseidon-HashState.html">HashState</a></li>
</ul>
<h2 id="traits-17"><a class="header" href="#traits-17">Traits</a></h2>
<ul>
<li><a href="./core-poseidon-PoseidonTrait.html">PoseidonTrait</a></li>
</ul>
<h2 id="impls-5"><a class="header" href="#impls-5">Impls</a></h2>
<ul>
<li><a href="./core-poseidon-PoseidonImpl.html">PoseidonImpl</a></li>
</ul>
<h2 id="extern-types-10"><a class="header" href="#extern-types-10">Extern types</a></h2>
<ul>
<li><a href="./core-poseidon-Poseidon.html">Poseidon</a></li>
</ul>
<h2 id="extern-functions-8"><a class="header" href="#extern-functions-8">Extern functions</a></h2>
<ul>
<li><a href="./core-poseidon-hades_permutation.html">hades_permutation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">debug</a></h1>
<p>Utilities related to printing of values at runtime. The recommended way of printing values is by using the <code>Display</code> and <code>Debug</code> traits available in the <a href="./core-fmt.html"><code>fmt</code></a> module. The items in this module are not public, and are not recommended for use.</p>
<p>Fully qualified path: <code>core::debug</code></p>
<h2 id="free-functions-10"><a class="header" href="#free-functions-10">Free functions</a></h2>
<ul>
<li><a href="./core-debug-print_byte_array_as_string.html">print_byte_array_as_string</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fmt"><a class="header" href="#fmt">fmt</a></h1>
<p>Functionality for formatting values.The main components of this module are:<code>Error</code>: A type representing formatting errors. - <code>Formatter</code>: A struct that holds the configuration and buffer for formatting. - <code>Display</code>: A trait for standard formatting using the empty format ("{}"). - <code>Debug</code>: A trait for debug formatting using the empty format ("{:?}"). - <code>LowerHex</code>: A trait for hex formatting in lower case.The module includes implementations of the <a href="%60Display%60"><code>Display</code></a>, <a href="%60Debug%60"><code>Debug</code></a> and <a href="%60LowerHex%60"><code>LowerHex</code></a> traits for various types.</p>
<p>Fully qualified path: <code>core::fmt</code></p>
<h2 id="modules-7"><a class="header" href="#modules-7">Modules</a></h2>
<ul>
<li><a href="./core-fmt-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="structs-8"><a class="header" href="#structs-8">Structs</a></h2>
<ul>
<li>
<p><a href="./core-fmt-Error.html">Error</a></p>
</li>
<li>
<p><a href="./core-fmt-Formatter.html">Formatter</a></p>
</li>
</ul>
<h2 id="traits-18"><a class="header" href="#traits-18">Traits</a></h2>
<ul>
<li>
<p><a href="./core-fmt-Display.html">Display</a></p>
</li>
<li>
<p><a href="./core-fmt-Debug.html">Debug</a></p>
</li>
<li>
<p><a href="./core-fmt-LowerHex.html">LowerHex</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet"><a class="header" href="#starknet">starknet</a></h1>
<p>Functionalities for interacting with the Starknet network.  # Core ComponentsStorage: The <code>storage</code> module defines abstractions on how to interact with Starknet contract storage. - Syscalls: The <code>syscalls</code> module contains the extern declarations for all the system calls available in Starknet. - Contract Addresses: The <code>contract_address</code> and <code>eth_address</code> modules provide types and utilities for working with Starknet contract addresses and Ethereum addresses. - Cryptography: The <code>secp256k1</code>, <code>secp256r1</code>, <code>secp256_trait</code>, and <code>eth_signature</code> modules handle various elliptic curve operations. - Execution Info: The <code>info</code> module exposes functions for accessing information about the current contract execution, such as the caller address, contract address, block info, and transaction info.</p>
<p>Fully qualified path: <code>core::starknet</code></p>
<h2 id="modules-8"><a class="header" href="#modules-8">Modules</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access.html">storage_access</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls.html">syscalls</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address.html">contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait.html">secp256_trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1.html">secp256k1</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1.html">secp256r1</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address.html">eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature.html">eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash.html">class_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-event.html">event</a></p>
</li>
<li>
<p><a href="./core-starknet-account.html">account</a></p>
</li>
<li>
<p><a href="./core-starknet-storage.html">storage</a></p>
</li>
<li>
<p><a href="./core-starknet-testing.html">testing</a></p>
</li>
</ul>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<ul>
<li><a href="./core-starknet-VALIDATED.html">VALIDATED</a></li>
</ul>
<h2 id="free-functions-11"><a class="header" href="#free-functions-11">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-info-get_block_info.html">get_block_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_number.html">get_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_timestamp.html">get_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_caller_address.html">get_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_contract_address.html">get_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_execution_info.html">get_execution_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_tx_info.html">get_tx_info</a></p>
</li>
</ul>
<h2 id="structs-9"><a class="header" href="#structs-9">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ExecutionInfo.html">ExecutionInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ResourceBounds.html">ResourceBounds</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-TxInfo.html">TxInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-BlockInfo.html">BlockInfo</a></p>
</li>
</ul>
<h2 id="type-aliases-3"><a class="header" href="#type-aliases-3">Type aliases</a></h2>
<ul>
<li><a href="./core-starknet-SyscallResult.html">SyscallResult</a></li>
</ul>
<h2 id="traits-19"><a class="header" href="#traits-19">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-SyscallResultTrait.html">SyscallResultTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">Store</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">Event</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">AccountContract</a></p>
</li>
</ul>
<h2 id="extern-types-11"><a class="header" href="#extern-types-11">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-starknet-System.html">System</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">ClassHash</a></p>
</li>
</ul>
<h2 id="extern-functions-9"><a class="header" href="#extern-functions-9">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-contract_address_const.html">contract_address_const</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal"><a class="header" href="#internal">internal</a></h1>
<p>Fully qualified path: <code>core::internal</code></p>
<h2 id="structs-10"><a class="header" href="#structs-10">Structs</a></h2>
<ul>
<li>
<p><a href="./core-internal-DropWith.html">DropWith</a></p>
</li>
<li>
<p><a href="./core-internal-InferDrop.html">InferDrop</a></p>
</li>
<li>
<p><a href="./core-internal-DestructWith.html">DestructWith</a></p>
</li>
<li>
<p><a href="./core-internal-InferDestruct.html">InferDestruct</a></p>
</li>
</ul>
<h2 id="enums-6"><a class="header" href="#enums-6">Enums</a></h2>
<ul>
<li>
<p><a href="./core-internal-OptionRev.html">OptionRev</a></p>
</li>
<li>
<p><a href="./core-internal-LoopResult.html">LoopResult</a></p>
</li>
</ul>
<h2 id="extern-functions-10"><a class="header" href="#extern-functions-10">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-internal-revoke_ap_tracking.html">revoke_ap_tracking</a></p>
</li>
<li>
<p><a href="./core-internal-require_implicit.html">require_implicit</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroable"><a class="header" href="#zeroable">zeroable</a></h1>
<p>Types and traits for handling non-zero values and zero checking operations.This module provides the <a href="./core-zeroable-NonZero.html"><code>NonZero</code></a> wrapper type which guarantees that a value is never zero. The <a href="%60Zeroable%60"><code>Zeroable</code></a> trait is meant for internal use only. The public-facing equivalent is the <a href="./core-num-traits-zero-Zero.html"><code>Zero</code></a> trait.</p>
<p>Fully qualified path: <code>core::zeroable</code></p>
<h2 id="extern-types-12"><a class="header" href="#extern-types-12">Extern types</a></h2>
<ul>
<li><a href="./core-zeroable-NonZero.html">NonZero</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes_31"><a class="header" href="#bytes_31">bytes_31</a></h1>
<p>Definitions and utilities for the <code>bytes31</code> type.The <code>bytes31</code> type is a compact, indexable 31-byte type.  # ExamplesCreating a <code>bytes31</code> from a <code>felt252</code>:</p>
<pre><code class="language-cairo">let value: bytes31 = 0xaabb.try_into().unwrap();
</code></pre>
<p>Accessing a byte by index:</p>
<pre><code class="language-cairo">assert!(value[0] == 0xbb);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31</code></p>
<h2 id="traits-20"><a class="header" href="#traits-20">Traits</a></h2>
<ul>
<li><a href="./core-bytes_31-Bytes31Trait.html">Bytes31Trait</a></li>
</ul>
<h2 id="impls-6"><a class="header" href="#impls-6">Impls</a></h2>
<ul>
<li><a href="./core-bytes_31-Bytes31Impl.html">Bytes31Impl</a></li>
</ul>
<h2 id="extern-types-13"><a class="header" href="#extern-types-13">Extern types</a></h2>
<ul>
<li><a href="./core-bytes_31-bytes31.html">bytes31</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte_array"><a class="header" href="#byte_array">byte_array</a></h1>
<p><code>ByteArray</code> is designed to handle large sequences of bytes with operations like appending, concatenation, and accessing individual bytes. It uses a structure that combines an <code>Array</code> of <code>bytes31</code> for full words and a <code>felt252</code> for handling partial words, optimizing for both space and performance.  # ExamplesThere are multiple ways to create a new <code>ByteArray</code>: - From a string literal:</p>
<pre><code class="language-cairo">let s = "Hello";
</code></pre>
<p>Using the <code>format!</code> macro:</p>
<pre><code class="language-cairo">let max_tps:u16 = 850;
let s = format!("Starknet's max TPS is: {}", max_tps);
</code></pre>
<p>You can append bytes to an existing <code>ByteArray</code> with <a href="%60ByteArrayTrait::append_byte%60"><code>ByteArrayTrait::append_byte</code></a>:</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_byte(0x41); // Appending a single byte 'A'
</code></pre>
<p>You can create a new <code>ByteArray</code> from an existing one by concatenating with <code>+</code>:</p>
<pre><code class="language-cairo">let s = "Hello";
let message = s + " world!";
</code></pre>
<p>Indexing operations are available on the <code>ByteArray</code> type as well:</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "ABC";
let first_byte = ba[0]
assert!(first_byte == 0x41);
</code></pre>
<p>Fully qualified path: <code>core::byte_array</code></p>
<h2 id="constants-1"><a class="header" href="#constants-1">Constants</a></h2>
<ul>
<li><a href="./core-byte_array-BYTE_ARRAY_MAGIC.html">BYTE_ARRAY_MAGIC</a></li>
</ul>
<h2 id="structs-11"><a class="header" href="#structs-11">Structs</a></h2>
<ul>
<li>
<p><a href="./core-byte_array-ByteArray.html">ByteArray</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayIter.html">ByteArrayIter</a></p>
</li>
</ul>
<h2 id="traits-21"><a class="header" href="#traits-21">Traits</a></h2>
<ul>
<li><a href="./core-byte_array-ByteArrayTrait.html">ByteArrayTrait</a></li>
</ul>
<h2 id="impls-7"><a class="header" href="#impls-7">Impls</a></h2>
<ul>
<li><a href="./core-byte_array-ByteArrayImpl.html">ByteArrayImpl</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">string</a></h1>
<p>Fully qualified path: <code>core::string</code></p>
<h2 id="traits-22"><a class="header" href="#traits-22">Traits</a></h2>
<ul>
<li><a href="./core-string-StringLiteral.html">StringLiteral</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iter"><a class="header" href="#iter">iter</a></h1>
<p>Composable external iteration.If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic code, so it's worth becoming familiar with them.Before explaining more, let's talk about how this module is structured:  # OrganizationThis module is largely organized by type:<a href="Traits">Traits</a> are the core portion: these traits define what kind of iterators exist and what you can do with them. The methods of these traits are worth putting some extra study time into. * <a href="Functions">Functions</a> provide some helpful ways to create some basic iterators. * <a href="Structs">Structs</a> are often the return types of the various methods on this module's traits. You'll usually want to look at the method that creates the <code>struct</code>, rather than the <code>struct</code> itself. For more detail about why, see '<a href="core-iter.html#implementing-iterator">Implementing Iterator</a>'.<a href="Traits">Traits</a>: #traits <a href="Functions">Functions</a>: #functions <a href="Structs">Structs</a>: #structsThat's it! Let's dig into iterators.  # IteratorThe heart and soul of this module is the <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> trait. The core of <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> looks like this:</p>
<pre><code class="language-cairo">trait Iterator {
    type Item;
    fn next(ref self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>An iterator has a method, <a href="%60next%60"><code>next</code></a>, which when called, returns an <a href="./core-option-Option.html">Option</a><Item>. Calling <a href="%60next%60"><code>next</code></a> will return <a href="%60Some(Item)%60"><code>Some(Item)</code></a> as long as there are elements, and once they've all been exhausted, will return <code>None</code> to indicate that iteration is finished.<a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>'s full definition includes a number of other methods as well, but they are default methods, built on top of <a href="%60next%60"><code>next</code></a>, and so you get them for free.Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the <a href="core-iter.html#adapters">Adapters</a> section below for more details.<a href="%60Some(Item)%60"><code>Some(Item)</code></a>: Some <a href="%60next%60"><code>next</code></a>: Iterator::next  # Forms of iterationThere is currently only one common method which can create iterators from a collection:<code>into_iter()</code>, which iterates over <code>T</code>.  # Implementing IteratorCreating an iterator of your own involves two steps: creating a <code>struct</code> to hold the iterator's state, and then implementing <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> for that <code>struct</code>. This is why there are so many <code>struct</code>s in this module: there is one for each iterator and iterator adapter.Let's make an iterator named <code>Counter</code> which counts from <code>1</code> to <code>5</code>:</p>
<pre><code class="language-cairo">// First, the struct:

/// An iterator which counts from one to five
<span class="boring">[derive(Drop)]
</span>struct Counter {
    count: usize,
}

// we want our count to start at one, so let's add a new() method to help.
// This isn't strictly necessary, but is convenient. Note that we start
// `count` at zero, we'll see why in `next()`'s implementation below.
<span class="boring">[generate_trait]
</span>impl CounterImpl of CounterTrait {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

// Then, we implement `Iterator` for our `Counter`:

impl CounterIter of core::iter::Iterator&lt;Counter&gt; {
    // we will be counting with usize
    type Item = usize;

    // next() is the only required method
    fn next(ref self: Counter) -&gt; Option&lt;Self::Item&gt; {
        // Increment our count. This is why we started at zero.
        self.count += 1;

        // Check to see if we've finished counting or not.
        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

// And now we can use it!

let mut counter = CounterTrait::new();

assert!(counter.next() == Some(1));
assert!(counter.next() == Some(2));
assert!(counter.next() == Some(3));
assert!(counter.next() == Some(4));
assert!(counter.next() == Some(5));
assert!(counter.next() == None);
</code></pre>
<p>Calling <a href="%60next%60"><code>next</code></a> this way gets repetitive. Cairo has a construct which can call <a href="%60next%60"><code>next</code></a> on your iterator, until it reaches <code>None</code>. Let's go over that next.  # <code>for</code> loops and <code>IntoIterator</code>Cairo's <code>for</code> loop syntax is actually sugar for iterators. Here's a basic example of <code>for</code>:</p>
<pre><code class="language-cairo">let values = array![1, 2, 3, 4, 5];

for x in values {
    println!("{x}");
}
</code></pre>
<p>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our array to produce an iterator. What gives?There's a trait in the core library for converting something into an iterator: <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>. This trait has one method, <a href="%60into_iter%60"><code>into_iter</code></a>, which converts the thing implementing <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a> into an iterator. Let's take a look at that <code>for</code> loop again, and what the compiler converts it into:</p>
<pre><code class="language-cairo">let values = array![1, 2, 3, 4, 5];

for x in values {
    println!("{x}");
}
</code></pre>
<p>Cairo de-sugars this into:</p>
<pre><code class="language-cairo">let values = array![1, 2, 3, 4, 5];
{
    let mut iter = IntoIterator::into_iter(values);
    let result = loop {
            let mut next = 0;
            match iter.next() {
                Some(val) =&gt; next = val,
                None =&gt; {
                    break;
                },
            };
            let x = next;
            let () = { println!("{x}"); };
        };
    result
}
</code></pre>
<p>First, we call <code>into_iter()</code> on the value. Then, we match on the iterator that returns, calling <a href="%60next%60"><code>next</code></a> over and over until we see a <code>None</code>. At that point, we <code>break</code> out of the loop, and we're done iterating.There's one more subtle bit here: the core library contains an interesting implementation of <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>:</p>
<pre><code class="language-ignore (only-for-syntax-highlight)">impl IteratorIntoIterator&lt;T, +Iterator&lt;T&gt;&gt; of IntoIterator&lt;T&gt;
</code></pre>
<p>In other words, all <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>s implement <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>, by just returning themselves. This means two things:If you're writing an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>, you can use it with a <code>for</code> loop. 2. If you're creating a collection, implementing <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a> for it will allow your collection to be used with the <code>for</code> loop.  # AdaptersFunctions which take an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> and return another <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> are often called 'iterator adapters', as they're a form of the 'adapter pattern'.Common iterators adapters include <a href="%60map%60"><code>map</code></a>, <a href="%60enumerate%60"><code>enumerate</code></a> and <a href="%60zip%60"><code>zip</code></a>.<a href="%60map%60"><code>map</code></a>: Iterator::map <a href="%60enumerate%60"><code>enumerate</code></a>: Iterator::enumerate <a href="%60zip%60"><code>zip</code></a>: Iterator::zip  # LazinessIterators (and iterator <a href="core-iter.html#adapters">adapters</a>) are lazy. This means that just creating an iterator doesn't do a whole lot. Nothing really happens until you call <a href="%60next%60"><code>next</code></a>. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the <a href="%60map%60"><code>map</code></a> method calls a closure on each element it iterates over:</p>
<pre><code class="language-cairo">let v = array![1, 2, 3, 4, 5];
let _ = v.into_iter().map(|x| println!("{x}"));
</code></pre>
<p>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</p>
<pre><code class="language-text">Unhandled `#[must_use]` type
</code></pre>
<p>Fully qualified path: <code>core::iter</code></p>
<h2 id="traits-23"><a class="header" href="#traits-23">Traits</a></h2>
<ul>
<li>
<p><a href="./core-iter-adapters-peekable-PeekableTrait.html">PeekableTrait</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-Extend.html">Extend</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-FromIterator.html">FromIterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-IntoIterator.html">IntoIterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-iterator-Iterator.html">Iterator</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metaprogramming"><a class="header" href="#metaprogramming">metaprogramming</a></h1>
<p>Metaprogramming utilities.</p>
<p>Fully qualified path: <code>core::metaprogramming</code></p>
<h2 id="traits-24"><a class="header" href="#traits-24">Traits</a></h2>
<ul>
<li><a href="./core-metaprogramming-TypeEqual.html">TypeEqual</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">testing</a></h1>
<p>Measurement of gas consumption for testing purpose.This module provides the <code>get_available_gas</code> function, useful for asserting the amount of gas consumed by a particular operation or function call. By calling <code>get_available_gas</code> before and after the operation, you can calculate the exact amount of gas used.</p>
<p>Fully qualified path: <code>core::testing</code></p>
<h2 id="extern-functions-11"><a class="header" href="#extern-functions-11">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-testing-get_available_gas.html">get_available_gas</a></p>
</li>
<li>
<p><a href="./core-testing-get_unspent_gas.html">get_unspent_gas</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to_byte_array"><a class="header" href="#to_byte_array">to_byte_array</a></h1>
<p>ASCII representation of numeric types for <code>ByteArray</code> manipulation.This module enables conversion of numeric values into their ASCII string representation, with support for different numeric bases and efficient appending to existing <code>ByteArray</code>.  # ExamplesBasic decimal formatting:</p>
<pre><code class="language-cairo">use core::to_byte_array::{FormatAsByteArray, AppendFormattedToByteArray};

let value: u32 = 42;
let base: NonZero&lt;u32&gt; = 10;

// Create a new formatted `ByteArray`
let formatted = value.format_as_byte_array(base);
assert!(formatted == "42");

// Append to an existing `ByteArray`
let mut buffer = "Value: ";
value.append_formatted_to_byte_array(ref buffer, base);
assert!(buffer == "Value: 42");
</code></pre>
<p>Custom base formatting:</p>
<pre><code class="language-cairo">use core::to_byte_array::FormatAsByteArray;
let value: u32 = 255;

// Hexadecimal representation
let hex = value.format_as_byte_array(16);
assert!(hex == "ff");

// Binary representation
let bin = value.format_as_byte_array(2);
assert!(bin == "11111111");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array</code></p>
<h2 id="traits-25"><a class="header" href="#traits-25">Traits</a></h2>
<ul>
<li>
<p><a href="./core-to_byte_array-AppendFormattedToByteArray.html">AppendFormattedToByteArray</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-FormatAsByteArray.html">FormatAsByteArray</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stark_curve"><a class="header" href="#stark_curve">stark_curve</a></h1>
<p>Fully qualified path: <code>core::ec::stark_curve</code></p>
<h2 id="constants-2"><a class="header" href="#constants-2">Constants</a></h2>
<ul>
<li>
<p><a href="./core-ec-stark_curve-ALPHA.html">ALPHA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-BETA.html">BETA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-ORDER.html">ORDER</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_X.html">GEN_X</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_Y.html">GEN_Y</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-26"><a class="header" href="#traits-26">traits</a></h1>
<p>Fully qualified path: <code>core::num::traits</code></p>
<h2 id="modules-9"><a class="header" href="#modules-9">Modules</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-zero.html">zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one.html">one</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size.html">bit_size</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops.html">ops</a></p>
</li>
</ul>
<h2 id="traits-27"><a class="header" href="#traits-27">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-zero-Zero.html">Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-bounded-Bounded.html">Bounded</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt-Sqrt.html">Sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul-WideMul.html">WideMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare-WideSquare.html">WideSquare</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">WrappingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">WrappingSub</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero"><a class="header" href="#zero">zero</a></h1>
<p>Traits for types with an additive identity element.</p>
<p>Fully qualified path: <code>core::num::traits::zero</code></p>
<h2 id="traits-28"><a class="header" href="#traits-28">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-zero-Zero.html">Zero</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one"><a class="header" href="#one">one</a></h1>
<p>Traits for types with a multiplicative identity element.</p>
<p>Fully qualified path: <code>core::num::traits::one</code></p>
<h2 id="traits-29"><a class="header" href="#traits-29">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-one-One.html">One</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit_size"><a class="header" href="#bit_size">bit_size</a></h1>
<p>Utilities for determining the bit size of types.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size</code></p>
<h2 id="traits-30"><a class="header" href="#traits-30">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-bit_size-BitSize.html">BitSize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ops-1"><a class="header" href="#ops-1">ops</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops</code></p>
<h2 id="modules-10"><a class="header" href="#modules-10">Modules</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-checked.html">checked</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing.html">overflowing</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow.html">pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating.html">saturating</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping.html">wrapping</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checked"><a class="header" href="#checked">checked</a></h1>
<p>Safe arithmetic operations with overflow/underflow checking.This module provides traits for performing arithmetic operations with explicit overflow and underflow protection. These operations return <code>None</code> when an overflow or underflow occurs, allowing you to handle these cases gracefully without panicking.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::{CheckedAdd, CheckedSub, CheckedMul};

// Checked addition
let a: u8 = 1;
assert!(a.checked_add(2) == Some(3));
assert!(a.checked_add(255) == None); // Overflow

// Checked subtraction
let b: u8 = 1;
assert!(b.checked_sub(1) == Some(0));
assert!(b.checked_sub(2) == None); // Underflow

// Checked multiplication
let c: u8 = 10;
assert!(c.checked_mul(20) == Some(200));
assert!(c.checked_mul(30) == None); // Overflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked</code></p>
<h2 id="traits-31"><a class="header" href="#traits-31">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">CheckedMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowing"><a class="header" href="#overflowing">overflowing</a></h1>
<p>Arithmetic operations with overflow detection.This module provides traits for performing arithmetic operations that explicitly track potential numeric overflow conditions.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing</code></p>
<h2 id="traits-32"><a class="header" href="#traits-32">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">OverflowingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow"><a class="header" href="#pow">pow</a></h1>
<p>Trait and implementations for raising a value to a power.This module provides efficient exponentiation operations for numeric types using the square-and-multiply algorithm, which achieves logarithmic time complexity O(log n).</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow</code></p>
<h2 id="traits-33"><a class="header" href="#traits-33">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-ops-pow-Pow.html">Pow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturating"><a class="header" href="#saturating">saturating</a></h1>
<p>Saturating arithmetic operations for numeric types.This module provides traits and implementations for arithmetic operations that saturate at the numeric type's boundaries instead of overflowing.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating</code></p>
<h2 id="traits-34"><a class="header" href="#traits-34">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">SaturatingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping"><a class="header" href="#wrapping">wrapping</a></h1>
<p>Arithmetic operations with overflow and underflow wrapping.This module provides traits for performing arithmetic operations that wrap around at the boundary of the type in case of overflow or underflow. This is particularly useful when you want to: - Perform arithmetic operations without panicking on overflow/underflow - Implement modular arithmetic - Handle cases where overflow is expected and desired  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::{WrappingAdd, WrappingSub, WrappingMul};

// Addition wrapping
let a: u8 = 255;
assert!(a.wrapping_add(1) == 0);

// Subtraction wrapping
let b: u8 = 0;
assert!(b.wrapping_sub(1) == 255);

// Multiplication wrapping
let c: u8 = 200;
assert!(c.wrapping_mul(2) == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping</code></p>
<h2 id="traits-35"><a class="header" href="#traits-35">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">WrappingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">index</a></h1>
<p>Indexing traits for indexing operations on collections.This module provides traits for implementing the indexing operator <code>[]</code>, offering two distinct approaches to access elements in collections:<a href="./core-ops-index-IndexView.html"><code>IndexView</code></a> - For snapshot-based access * <a href="./core-ops-index-Index.html"><code>Index</code></a> - For reference-based access  # When to use which traitUse <a href="./core-ops-index-IndexView.html"><code>IndexView</code></a> when the collection can be accessed in a read-only context and is not mutated by a read access. This is the most common case in Cairo. - Use <a href="./core-ops-index-Index.html"><code>Index</code></a> when the input type needs to be passed as <code>ref</code>. This is mainly useful for types depending on a <a href="./core-dict-Felt252Dict.html"><code>Felt252Dict</code></a>, where dictionary accesses are modifying the data structure itself.Only one of these traits should be implemented for any given type, not both.</p>
<p>Fully qualified path: <code>core::ops::index</code></p>
<h2 id="traits-36"><a class="header" href="#traits-36">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ops-index-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">Index</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based"><a class="header" href="#into_felt252_based">into_felt252_based</a></h1>
<p>Implementation for <code>Hash</code> for types that can be converted into <code>felt252</code> using the <code>Into</code> trait.  # Examples</p>
<pre><code class="language-cairo">impl MyTypeHash&lt;S, +HashStateTrait&lt;S&gt;, +Drop&lt;S&gt;&gt; =
    core::hash::into_felt252_based::HashImpl&lt;MyType, S&gt;;`
</code></pre>
<p>Fully qualified path: <code>core::hash::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based-1"><a class="header" href="#into_felt252_based-1">into_felt252_based</a></h1>
<p>Fully qualified path: <code>core::serde::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based-2"><a class="header" href="#into_felt252_based-2">into_felt252_based</a></h1>
<p>Implementations for <code>Debug</code> and <code>LowerHex</code> for types that can be converted into <code>felt252</code> using the <code>Into</code> trait.  # Examples</p>
<pre><code class="language-cairo">impl MyTypeDebug = crate::fmt::into_felt252_based::DebugImpl&lt;MyType&gt;;`
impl MyTypeLowerHex = crate::fmt::into_felt252_based::LowerHexImpl&lt;MyType&gt;;
</code></pre>
<p>Fully qualified path: <code>core::fmt::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_access"><a class="header" href="#storage_access">storage_access</a></h1>
<p>Storage access primitives for Starknet contract storage.This module provides abstractions over the system calls for reading from and writing to Starknet contract storage. It includes traits and implementations for storing various data types efficiently.  # Storage ArchitectureStorage addresses range from <code>[0, 2^251)</code> * Base addresses can be combined with offsets, allowing storage of up to 255 values sequentially * Multiple storage domains can be supported, each with its own set of storage space. Currently, only the domain <code>0</code> is supported. Values stored in domain <code>0</code> are committed to Ethereum as part of the state diffs.  # Core Components<a href="./core-starknet-storage_access-StorageAddress.html"><code>StorageAddress</code></a>: Represents a specific storage location * <a href="./core-starknet-storage_access-StorageBaseAddress.html"><code>StorageBaseAddress</code></a>: Base address that can be combined with offsets * <a href="%60Store%3CT%3E%60"><code>Store&lt;T&gt;</code></a>: Core trait for types that can be stored in contract storage * <a href="%60StorePacking%3CT,P%3E%60"><code>StorePacking&lt;T,P&gt;</code></a>: Trait for efficient packing/unpacking of valuesGenerally, you don't need to implement the <a href="./core-starknet-storage_access-Store.html"><code>Store</code></a> trait yourself. Most types of the core library, at the exception of collection types, implement the <a href="./core-starknet-storage_access-Store.html"><code>Store</code></a> trait - and thus, you can derive the <a href="./core-starknet-storage_access-Store.html"><code>Store</code></a> trait for your own types, as long as they don't contain any collections.</p>
<p>Fully qualified path: <code>core::starknet::storage_access</code></p>
<h2 id="traits-37"><a class="header" href="#traits-37">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-Store.html">Store</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorePacking.html">StorePacking</a></p>
</li>
</ul>
<h2 id="extern-types-14"><a class="header" href="#extern-types-14">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageBaseAddress.html">StorageBaseAddress</a></p>
</li>
</ul>
<h2 id="extern-functions-12"><a class="header" href="#extern-functions-12">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_const.html">storage_base_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_from_felt252.html">storage_base_address_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base_and_offset.html">storage_address_from_base_and_offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base.html">storage_address_from_base</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">syscalls</a></h1>
<p>Utilities for interacting with the Starknet OS.Writing smart contracts requires various associated operations, such as calling another contract or accessing the contractâ€™s storage, that standalone programs do not require. Cairo supports these operations by using system calls.System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, such as the current timestamp of the address of the caller, but also to modify the state of Starknet by, for example, storing values in a contract's storage or deploying new contracts.</p>
<p>Fully qualified path: <code>core::starknet::syscalls</code></p>
<h2 id="extern-functions-13"><a class="header" href="#extern-functions-13">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-syscalls-call_contract_syscall.html">call_contract_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-deploy_syscall.html">deploy_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-emit_event_syscall.html">emit_event_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_block_hash_syscall.html">get_block_hash_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_syscall.html">get_execution_info_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_v2_syscall.html">get_execution_info_v2_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-library_call_syscall.html">library_call_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-send_message_to_l1_syscall.html">send_message_to_l1_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_read_syscall.html">storage_read_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_write_syscall.html">storage_write_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-replace_class_syscall.html">replace_class_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_class_hash_at_syscall.html">get_class_hash_at_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-keccak_syscall.html">keccak_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-sha256_process_block_syscall.html">sha256_process_block_syscall</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address"><a class="header" href="#contract_address">contract_address</a></h1>
<p>The <code>ContractAddress</code> type represents a Starknet contract address, with a value range of <code>[0, 2**251)</code>.A variable of type <code>ContractAddress</code> can be created from a <code>felt252</code> value using the <code>contract_address_const</code> function, or using the <code>TryInto</code> trait.  # Examples</p>
<pre><code class="language-cairo">use starknet::contract_address::contract_address_const;

let contract_address = contract_address_const::&lt;0x0&gt;();
</code></pre>
<p>Fully qualified path: <code>core::starknet::contract_address</code></p>
<h2 id="extern-types-15"><a class="header" href="#extern-types-15">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-ContractAddress.html">ContractAddress</a></li>
</ul>
<h2 id="extern-functions-14"><a class="header" href="#extern-functions-14">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-contract_address_const.html">contract_address_const</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256_trait"><a class="header" href="#secp256_trait">secp256_trait</a></h1>
<p>Elliptic Curve Digital Signature Algorithm (ECDSA) for Secp256k1 and Secp256r1 curves.This module provides traits and functions for working with ECDSA signatures on the Secp256k1 and the Secp256r1 curves. It includes utilities for creating and validating signatures, as well as recovering public keys from signatures.  # Examples</p>
<pre><code class="language-cairo">use starknet::SyscallResultTrait;
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait</code></p>
<h2 id="free-functions-12"><a class="header" href="#free-functions-12">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256_trait-signature_from_vrs.html">signature_from_vrs</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_signature_entry_valid.html">is_signature_entry_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_valid_signature.html">is_valid_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-recover_public_key.html">recover_public_key</a></p>
</li>
</ul>
<h2 id="structs-12"><a class="header" href="#structs-12">Structs</a></h2>
<ul>
<li><a href="./core-starknet-secp256_trait-Signature.html">Signature</a></li>
</ul>
<h2 id="traits-38"><a class="header" href="#traits-38">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256Trait.html">Secp256Trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256PointTrait.html">Secp256PointTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1"><a class="header" href="#secp256k1">secp256k1</a></h1>
<p>Functions and constructs related to elliptic curve operations on the secp256k1 curve.This module provides functionality for performing operations on the secp256k1 elliptic curve, commonly used in cryptographic applications such as Bitcoin and Ethereum. It implements the traits defined in the <code>secp256_trait</code> module to ensure consistent behavior across different secp256 curve implementations.Curve information: * Base field: q = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f * Scalar field: r = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 * Curve equation: y^2 = x^3 + 7</p>
<p>Fully qualified path: <code>core::starknet::secp256k1</code></p>
<h2 id="extern-types-16"><a class="header" href="#extern-types-16">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-secp256k1-Secp256k1Point.html">Secp256k1Point</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1"><a class="header" href="#secp256r1">secp256r1</a></h1>
<p>Functions and constructs related to elliptic curve operations on the secp256r1 curve.This module provides functionality for performing operations on the NIST P-256 (also known as secp256r1) elliptic curve. It implements the traits defined in the <code>secp256_trait</code> module to ensure consistent behavior across different secp256 curve implementations.Curve information: * Base field: q = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff * Scalar field: r = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * a = -3 * b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b * Curve equation: y^2 = x^3 + ax + b</p>
<p>Fully qualified path: <code>core::starknet::secp256r1</code></p>
<h2 id="extern-types-17"><a class="header" href="#extern-types-17">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-secp256r1-Secp256r1Point.html">Secp256r1Point</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eth_address"><a class="header" href="#eth_address">eth_address</a></h1>
<p>Ethereum address type for working with Ethereum primitives.This module provides the <a href="./core-starknet-eth_address-EthAddress.html"><code>EthAddress</code></a> type, which is used when interacting with Ethereum primitives, such as signatures and L1 &lt;-&gt; L2 messages.</p>
<p>Fully qualified path: <code>core::starknet::eth_address</code></p>
<h2 id="structs-13"><a class="header" href="#structs-13">Structs</a></h2>
<ul>
<li><a href="./core-starknet-eth_address-EthAddress.html">EthAddress</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eth_signature"><a class="header" href="#eth_signature">eth_signature</a></h1>
<p>Utilities for Ethereum signature verification and address recovery.This module provides functionality for working with Ethereum signatures. It implements verification of Ethereum signatures against addresses and conversion of public keys to Ethereum addresses.</p>
<p>Fully qualified path: <code>core::starknet::eth_signature</code></p>
<h2 id="free-functions-13"><a class="header" href="#free-functions-13">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-eth_signature-verify_eth_signature.html">verify_eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-is_eth_signature_valid.html">is_eth_signature_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-public_key_point_to_eth_address.html">public_key_point_to_eth_address</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash"><a class="header" href="#class_hash">class_hash</a></h1>
<p>The <code>ClassHash</code> type represents a Starknet contract class hash, with a value range of <code>[0, 2**251)</code>.A variable of type <code>ClassHash</code> can be created from a <code>felt252</code> value using the <code>class_hash_const</code> function, or using the <code>TryInto</code> trait.  # Examples</p>
<pre><code class="language-cairo">use starknet::class_hash::class_hash_const;

let hash = class_hash_const::&lt;0x123&gt;();
let hash = 0x123.try_into().unwrap();
</code></pre>
<p>Fully qualified path: <code>core::starknet::class_hash</code></p>
<h2 id="extern-types-18"><a class="header" href="#extern-types-18">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-class_hash-ClassHash.html">ClassHash</a></li>
</ul>
<h2 id="extern-functions-15"><a class="header" href="#extern-functions-15">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-class_hash-class_hash_const.html">class_hash_const</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event"><a class="header" href="#event">event</a></h1>
<p>Event handling traits for Starknet smart contracts.This module provides traits for serializing, deserializing and emitting events on Starknet. The <a href="./core-starknet-event-Event.html"><code>Event</code></a> trait handles the serialization of event types, while the <a href="%60EventEmitter%60"><code>EventEmitter</code></a> trait provides the capability to emit events from Starknet contracts.</p>
<p>Fully qualified path: <code>core::starknet::event</code></p>
<h2 id="traits-39"><a class="header" href="#traits-39">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-event-Event.html">Event</a></p>
</li>
<li>
<p><a href="./core-starknet-event-EventEmitter.html">EventEmitter</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">account</a></h1>
<p>Account module defining the <a href="%60Call%60"><code>Call</code></a> struct and the <a href="./core-starknet-account-AccountContract.html"><code>AccountContract</code></a> trait.The <code>Call</code> struct represents a call to a contract, with the following fields: - <code>to</code>: The address of the contract to call. - <code>selector</code>: The entry point selector in the called contract. - <code>calldata</code>: The calldata to pass to the entry point.The <code>AccountContract</code> trait defines the standard interface for account contracts. It assumes that the calldata for invoke transactions is an <code>Array&lt;Call&gt;</code>, following the SNIP6 standard.Implementing this trait allows contracts to function as account contracts in the Starknet network, supporting class declarations and batched call execution.</p>
<p>Fully qualified path: <code>core::starknet::account</code></p>
<h2 id="structs-14"><a class="header" href="#structs-14">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-account-Call.html">Call</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcher.html">AccountContractDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractLibraryDispatcher.html">AccountContractLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeLibraryDispatcher.html">AccountContractSafeLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcher.html">AccountContractSafeDispatcher</a></p>
</li>
</ul>
<h2 id="traits-40"><a class="header" href="#traits-40">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-account-AccountContract.html">AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcherTrait.html">AccountContractDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcherTrait.html">AccountContractSafeDispatcherTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">storage</a></h1>
<p>Storage-related types and traits for Cairo contracts.This module implements the storage system for Starknet contracts, providing high-level abstractions for persistent data storage. It offers a type-safe interface for reading and writing to Starknet storage through the <a href="%60StoragePointerReadAccess%60"><code>StoragePointerReadAccess</code></a> and <a href="%60StoragePointerWriteAccess%60"><code>StoragePointerWriteAccess</code></a> traits, along with useful storage-only collection types like <a href="%60Vec%60"><code>Vec</code></a> and <a href="%60Map%60"><code>Map</code></a>.<a href="%60Vec%60"><code>Vec</code></a>: starknet::storage::vec::Vec <a href="%60Map%60"><code>Map</code></a>: starknet::storage::map::Map  # OverviewThe storage system in Starknet contracts is built on a key-value store where each storage slot is identified by a 251-bit address. The storage system allows interactions with storage using state variables, which are declared inside a <code>Storage</code> struct annotated with the <code>#[storage]</code> attribute. This ensures type-safe storage access and simplifies the process of reading and writing to storage.  # Using the Storage SystemStorage is typically declared using the <code>#[storage]</code> attribute on a struct:</p>
<pre><code class="language-cairo"><span class="boring">[storage]
</span>struct Storage {
    balance: u256,
    users: Map&lt;ContractAddress, User&gt;,
    nested_data: Map&lt;ContractAddress, Map&lt;ContractAddress, u8&gt;&gt;,
    collection: Vec&lt;u8&gt;,
}
</code></pre>
<p>Any type that implements the <code>Store</code> trait (or it's optimized <code>StorePacked</code> variant) can be used in storage.  This type can simply be derived using <code>#[derive(Store)]</code> - provided that all of the members of the type also implement <code>Store</code>.</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Default, Drop, Store)]
</span>struct User {
    name: felt252,
    age: u8,
}
</code></pre>
<p>Interaction with storage is made through a set of traits, depending on the type interacted with:<a href="%60StoragePointerReadAccess%60"><code>StoragePointerReadAccess</code></a> and <a href="%60StoragePointerWriteAccess%60"><code>StoragePointerWriteAccess</code></a> allow for reading and writing storable types. - <a href="%60StorageMapReadAccess%60"><code>StorageMapReadAccess</code></a> and <a href="%60StorageMapWriteAccess%60"><code>StorageMapWriteAccess</code></a> allow for reading and writing to storage <a href="%60Map%60"><code>Map</code></a>s. - <a href="%60StoragePathEntry%60"><code>StoragePathEntry</code></a> allows for accessing a specific entry in a <a href="%60Map%60"><code>Map</code></a>, and can be combined with the <code>StoragePointer</code> traits to read and write in these entries. - <a href="%60VecTrait%60"><code>VecTrait</code></a> and <a href="%60MutableVecTrait%60"><code>MutableVecTrait</code></a> allow for interacting with storage <a href="%60Vec%60"><code>Vec</code></a>s.<a href="%60VecTrait%60"><code>VecTrait</code></a>: starknet::storage::vec::VecTrait <a href="%60MutableVecTrait%60"><code>MutableVecTrait</code></a>: starknet::storage::vec::MutableVecTrait <a href="%60StorageMapReadAccess%60"><code>StorageMapReadAccess</code></a>: starknet::storage::map::StorageMapReadAccess <a href="%60StorageMapWriteAccess%60"><code>StorageMapWriteAccess</code></a>: starknet::storage::map::StorageMapWriteAccess <a href="%60StoragePathEntry%60"><code>StoragePathEntry</code></a>: starknet::storage::map::StoragePathEntry  ## Examples</p>
<pre><code class="language-cairo">fn use_storage(self: @ContractState) {
    let address = 'address'.try_into().unwrap();
    // Reading values
    let balance = self.balance.read();
    // For a `Map`, use the `entry` method to access values at specific keys:
    let user = self.users.entry(address).read();
    // Accessing nested `Map`s requires chaining `entry` calls:
    let nested = self.nested_data.entry(address).entry(address).read();
    // Accessing a specific index in a `Vec` requires using the `index` method:
    let element = self.collection[index];

    // Writing values
    self.balance.write(100);
    self.users.entry(address).write(Default::default());
    self.nested_data.entry(address).entry(address).write(10);
    self.collection[index].write(20);
}
</code></pre>
<h1 id="storage-lifecyclewhen-you-access-a-storage-variable-it-goes-through-several-transformationsflattenedstorage-the-starting-point-is-your-contracts-storage-struct-each-member-is-represented-either-as-a-storagebase-or-another-flattenedstorage-for-substoragev0-or-flat-membersstoragebase-for-simple-variables-this-holds-the-sn_keccak-hash-of-the-variable-name-which-becomes-the-storage-address-for-example"><a class="header" href="#storage-lifecyclewhen-you-access-a-storage-variable-it-goes-through-several-transformationsflattenedstorage-the-starting-point-is-your-contracts-storage-struct-each-member-is-represented-either-as-a-storagebase-or-another-flattenedstorage-for-substoragev0-or-flat-membersstoragebase-for-simple-variables-this-holds-the-sn_keccak-hash-of-the-variable-name-which-becomes-the-storage-address-for-example">Storage LifecycleWhen you access a storage variable, it goes through several transformations:FlattenedStorage: The starting point is your contract's storage struct. Each member is represented either as a <code>StorageBase</code> or another <code>FlattenedStorage</code> (for <code>#[substorage(v0)]</code> or <code>#[flat]</code> members).StorageBase: For simple variables, this holds the <code>sn_keccak</code> hash of the variable name, which becomes the storage address. For example:</a></h1>
<pre><code>#[storage]
struct Storage {
    balance: u128,  // Stored at sn_keccak('balance')
}
</code></pre>
<p>StoragePath: For complex types, a <code>StoragePath</code> represents an un-finalized path to aspecific entry in storage. For example, a <code>StoragePath</code> for a <code>Map</code> can be updated withspecific keys to point to a specific entry in the map.StoragePointer: The final form, pointing to the actual storage location. For multi-slotvalues (like structs), values are stored sequentially from this address.  # Storage CollectionsCairo's memory collection types, like <a href="%60Felt252Dict%60"><code>Felt252Dict</code></a> and <a href="./core-array-Array.html"><code>Array</code></a>, can not be used in storage.Consequently, any type that contains these types can not be used in storage either.Instead, Cairo has two storage-only collection types: <a href="%60Map%60"><code>Map</code></a> and <a href="%60Vec%60"><code>Vec</code></a>.Instead of storing these memory collections directly, you will need to reflect them intostorage using the <a href="%60Map%60"><code>Map</code></a> and <a href="%60Vec%60"><code>Vec</code></a> types.  # Address CalculationStorage addresses are calculated deterministically:For a single value variable, the address is the <code>sn_keccak</code> hash of the variable name's ASCIIencoding. <code>sn_keccak</code> is Starknet's version of the Keccak-256 hash function, with its outputtruncated to 250 bits.For variables composed of multiple values (tuples, structs, or enums), the base storageaddress is also the <code>sn_keccak</code> hash of the variable name's ASCII encoding. The storage layoutthen varies depending on the specific type. A struct will store its members as a sequence ofprimitive types, while an enum will store its variant index, followed by the members of thevariant.For variables within a storage node, the address is calculated using a chain of hashes thatrepresents the node structure. Given a member <code>m</code> within a storage variable <code>variable_name</code>,the path is computed as <code>h(sn_keccak(variable_name), sn_keccak(m))</code>, where <code>h</code> is the Pedersenhash. For nested storage nodes, this process repeats, creating a hash chain representing thepath to each leaf node. At the leaf node, the storage calculation follows the standard rules forthat variable type.For <a href="%60Map%60"><code>Map</code></a> or <a href="%60Vec%60"><code>Vec</code></a> variables, the address is calculated relative to the storage baseaddress (the <code>sn_keccak</code> hash of the variable name) combined with the mapping keys or vectorindices.See their respective module documentation for more details.</p>
<p>Fully qualified path: <code>core::starknet::storage</code></p>
<h2 id="structs-15"><a class="header" href="#structs-15">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage-StoragePointer.html">StoragePointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer0Offset.html">StoragePointer0Offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePath.html">StoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePath.html">PendingStoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-Mutable.html">Mutable</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-Map.html">Map</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-FlattenedStorage.html">FlattenedStorage</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageBase.html">StorageBase</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-Vec.html">Vec</a></p>
</li>
</ul>
<h2 id="traits-41"><a class="header" href="#traits-41">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage-StorageAsPointer.html">StorageAsPointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerReadAccess.html">StoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerWriteAccess.html">StoragePointerWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPath.html">StorageAsPath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePathTrait.html">PendingStoragePathTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-IntoIterRange.html">IntoIterRange</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-ValidStorageTypeTrait.html">ValidStorageTypeTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapReadAccess.html">StorageMapReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapWriteAccess.html">StorageMapWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StoragePathEntry.html">StoragePathEntry</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTrait.html">StorageTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTraitMut.html">StorageTraitMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNode.html">StorageNode</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNodeMut.html">StorageNodeMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointers.html">SubPointers</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersForward.html">SubPointersForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMut.html">SubPointersMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMutForward.html">SubPointersMutForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-MutableVecTrait.html">MutableVecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-VecTrait.html">VecTrait</a></p>
</li>
</ul>
<h2 id="impls-8"><a class="header" href="#impls-8">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage-SubPointersDeref.html">SubPointersDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-SubPointersMutDeref.html">SubPointersMutDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorableStoragePointerReadAccess.html">StorableStoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageNodeDeref.html">StorageNodeDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageNodeMutDeref.html">StorageNodeMutDeref</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">testing</a></h1>
<p>Testing utilities for Starknet contracts.This module provides functions for testing Starknet contracts. The functions allow manipulation of blockchain state and storage variables during tests, as well as inspection of emitted events and messages.Note: The functions in this module can only be used with the <code>cairo-test</code> testing framework. If you are using Starknet Foundry, refer to its <a href="https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html">documentation</a>.</p>
<p>Fully qualified path: <code>core::starknet::testing</code></p>
<h2 id="free-functions-14"><a class="header" href="#free-functions-14">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-testing-set_block_number.html">set_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_caller_address.html">set_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_contract_address.html">set_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_sequencer_address.html">set_sequencer_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_timestamp.html">set_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_version.html">set_version</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_account_contract_address.html">set_account_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_max_fee.html">set_max_fee</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_transaction_hash.html">set_transaction_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_chain_id.html">set_chain_id</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_nonce.html">set_nonce</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_signature.html">set_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_hash.html">set_block_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log_raw.html">pop_log_raw</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log.html">pop_log</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_l2_to_l1_message.html">pop_l2_to_l1_message</a></p>
</li>
</ul>
<h2 id="extern-functions-16"><a class="header" href="#extern-functions-16">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-testing-cheatcode.html">cheatcode</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-3"><a class="header" href="#constants-3">Constants</a></h1>
<ul>
<li>
<p><a href="./core-ec-stark_curve-ALPHA.html">ALPHA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-BETA.html">BETA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-ORDER.html">ORDER</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_X.html">GEN_X</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_Y.html">GEN_Y</a></p>
</li>
<li>
<p><a href="./core-starknet-VALIDATED.html">VALIDATED</a></p>
</li>
<li>
<p><a href="./core-byte_array-BYTE_ARRAY_MAGIC.html">BYTE_ARRAY_MAGIC</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alpha"><a class="header" href="#alpha">ALPHA</a></h1>
<p>The STARK Curve is defined by the equation yÂ² â‰¡ xÂ³ + Î±Â·x + Î² (mod p).</p>
<p>Fully qualified path: <code>core::ec::stark_curve::ALPHA</code></p>
<pre><code class="language-rust">pub const ALPHA: felt252 = 1;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beta"><a class="header" href="#beta">BETA</a></h1>
<p>The STARK Curve is defined by the equation yÂ² â‰¡ xÂ³ + Î±Â·x + Î² (mod p).</p>
<p>Fully qualified path: <code>core::ec::stark_curve::BETA</code></p>
<pre><code class="language-rust">pub const BETA: felt252 = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="order"><a class="header" href="#order">ORDER</a></h1>
<p>The order (number of points) of the STARK Curve.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::ORDER</code></p>
<pre><code class="language-rust">pub const ORDER: felt252 = 0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen_x"><a class="header" href="#gen_x">GEN_X</a></h1>
<p>The x coordinate of the generator point used in the ECDSA signature.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::GEN_X</code></p>
<pre><code class="language-rust">pub const GEN_X: felt252 = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen_y"><a class="header" href="#gen_y">GEN_Y</a></h1>
<p>The y coordinate of the generator point used in the ECDSA signature.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::GEN_Y</code></p>
<pre><code class="language-rust">pub const GEN_Y: felt252 = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validated"><a class="header" href="#validated">VALIDATED</a></h1>
<p>The expected return value of the <code>__validate__</code> function in account contracts.This constant is used to indicate that a transaction validation was successful. Account contracts must return this value from their <code>__validate__</code> function to signal that the transaction should proceed.</p>
<p>Fully qualified path: <code>core::starknet::VALIDATED</code></p>
<pre><code class="language-rust">pub const VALIDATED: felt252 = &apos;VALID&apos;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte_array_magic"><a class="header" href="#byte_array_magic">BYTE_ARRAY_MAGIC</a></h1>
<p>A magic constant for identifying serialization of <code>ByteArray</code> variables. An array of <code>felt252</code> with this magic value as one of the <code>felt252</code> indicates that you should expect right after it a serialized <code>ByteArray</code>. This is currently used mainly for prints and panics.</p>
<p>Fully qualified path: <code>core::byte_array::BYTE_ARRAY_MAGIC</code></p>
<pre><code class="language-rust">pub const BYTE_ARRAY_MAGIC: felt252 =
    0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="free-functions-15"><a class="header" href="#free-functions-15">Free functions</a></h1>
<ul>
<li>
<p><a href="./core-panic_with_felt252.html">panic_with_felt252</a></p>
</li>
<li>
<p><a href="./core-panic_with_const_felt252.html">panic_with_const_felt252</a></p>
</li>
<li>
<p><a href="./core-assert.html">assert</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_add.html">circuit_add</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_sub.html">circuit_sub</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_inverse.html">circuit_inverse</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_mul.html">circuit_mul</a></p>
</li>
<li>
<p><a href="./core-ecdsa-check_ecdsa_signature.html">check_ecdsa_signature</a></p>
</li>
<li>
<p><a href="./core-ecdsa-recover_public_key.html">ecdsa::recover_public_key</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_add.html">u128_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_sub.html">u128_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wide_mul.html">u128_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_mul.html">u128_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_add.html">u8_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_sub.html">u8_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_add.html">u16_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_sub.html">u16_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_add.html">u32_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_sub.html">u32_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_add.html">u64_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_sub.html">u64_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_add.html">u256_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_sub.html">u256_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_sub.html">u256_overflow_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_mul.html">u256_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_mul.html">u256_overflow_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_wide_mul.html">u256_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u512_safe_div_rem_by_u256.html">u512_safe_div_rem_by_u256</a></p>
</li>
<li>
<p><a href="./core-cmp-min.html">min</a></p>
</li>
<li>
<p><a href="./core-cmp-max.html">max</a></p>
</li>
<li>
<p><a href="./core-cmp-minmax.html">minmax</a></p>
</li>
<li>
<p><a href="./core-math-egcd.html">egcd</a></p>
</li>
<li>
<p><a href="./core-math-inv_mod.html">inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_inv_mod.html">u256_inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_div_mod_n.html">u256_div_mod_n</a></p>
</li>
<li>
<p><a href="./core-math-u256_mul_mod_n.html">u256_mul_mod_n</a></p>
</li>
<li>
<p><a href="./core-panics-panic_with_byte_array.html">panic_with_byte_array</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_le_inputs.html">keccak_u256s_le_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_be_inputs.html">keccak_u256s_be_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-cairo_keccak.html">cairo_keccak</a></p>
</li>
<li>
<p><a href="./core-keccak-compute_keccak_byte_array.html">compute_keccak_byte_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_u32_array.html">compute_sha256_u32_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_byte_array.html">compute_sha256_byte_array</a></p>
</li>
<li>
<p><a href="./core-poseidon-poseidon_hash_span.html">poseidon_hash_span</a></p>
</li>
<li>
<p><a href="./core-debug-print_byte_array_as_string.html">print_byte_array_as_string</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_info.html">get_block_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_number.html">get_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_timestamp.html">get_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_caller_address.html">get_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_contract_address.html">get_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_execution_info.html">get_execution_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_tx_info.html">get_tx_info</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-signature_from_vrs.html">signature_from_vrs</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_signature_entry_valid.html">is_signature_entry_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_valid_signature.html">is_valid_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-recover_public_key.html">starknet::secp256_trait::recover_public_key</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-verify_eth_signature.html">verify_eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-is_eth_signature_valid.html">is_eth_signature_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-public_key_point_to_eth_address.html">public_key_point_to_eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_number.html">set_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_caller_address.html">set_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_contract_address.html">set_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_sequencer_address.html">set_sequencer_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_timestamp.html">set_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_version.html">set_version</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_account_contract_address.html">set_account_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_max_fee.html">set_max_fee</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_transaction_hash.html">set_transaction_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_chain_id.html">set_chain_id</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_nonce.html">set_nonce</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_signature.html">set_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_hash.html">set_block_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log_raw.html">pop_log_raw</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log.html">pop_log</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_l2_to_l1_message.html">pop_l2_to_l1_message</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_with_felt252"><a class="header" href="#panic_with_felt252">panic_with_felt252</a></h1>
<p>Panics with the given <code>felt252</code> as error message.  # Examples</p>
<pre><code class="language-cairo">use core::panic_with_felt252;

panic_with_felt252('error message');
</code></pre>
<p>Fully qualified path: <code>core::panic_with_felt252</code></p>
<pre><code class="language-rust">pub fn panic_with_felt252(err_code: felt252) -&gt; never</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_with_const_felt252"><a class="header" href="#panic_with_const_felt252">panic_with_const_felt252</a></h1>
<p>Panics with the given const argument <code>felt252</code> as error message.  # Examples</p>
<pre><code class="language-cairo">use core::panic_with_const_felt252;

panic_with_const_felt252::&lt;'error message'&gt;();
</code></pre>
<p>Fully qualified path: <code>core::panic_with_const_felt252</code></p>
<pre><code class="language-rust">pub fn panic_with_const_felt252&lt;const ERR_CODE: felt252&gt;() -&gt; never</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert"><a class="header" href="#assert">assert</a></h1>
<p>Panics if <code>cond</code> is false with the given <code>felt252</code> as error message.  # Examples</p>
<pre><code class="language-cairo">assert(false, 'error message');
</code></pre>
<p>Fully qualified path: <code>core::assert</code></p>
<pre><code class="language-rust">pub const fn assert(cond: bool, err_code: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_add"><a class="header" href="#circuit_add">circuit_add</a></h1>
<p>Creates a new circuit element representing addition modulo p of two input circuits.This function combines two circuit elements using modular addition, creating a new circuit element that represents their sum modulo the circuit's modulus.  # Arguments<code>lhs</code> - Left-hand side circuit element * <code>rhs</code> - Right-hand side circuit element  # ReturnsA new circuit element representing <code>(lhs + rhs) mod p</code>  # Examples</p>
<pre><code class="language-cairo">let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
let sum = circuit_add(a, b);
</code></pre>
<p>Fully qualified path: <code>core::circuit::circuit_add</code></p>
<pre><code class="language-rust">pub fn circuit_add&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement&lt;AddModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_sub"><a class="header" href="#circuit_sub">circuit_sub</a></h1>
<p>Creates a new circuit element representing subtraction modulo p of two input circuits.This function combines two circuit elements using modular subtraction, creating a new circuit element that represents their difference modulo the circuit's modulus.  # Arguments<code>lhs</code> - Left-hand side circuit element (minuend) * <code>rhs</code> - Right-hand side circuit element (subtrahend)  # ReturnsA new circuit element representing <code>(lhs - rhs) mod p</code>  # Examples</p>
<pre><code class="language-cairo">let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
let diff = circuit_sub(a, b);
</code></pre>
<p>Fully qualified path: <code>core::circuit::circuit_sub</code></p>
<pre><code class="language-rust">pub fn circuit_sub&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement&lt;SubModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_inverse"><a class="header" href="#circuit_inverse">circuit_inverse</a></h1>
<p>Creates a new circuit element representing the multiplicative inverse modulo p of an input circuit.This function creates a new circuit element representing the multiplicative inverse of the input element modulo the circuit's modulus. The operation will fail during evaluation if the input is not invertible (not coprime with the modulus).  # Arguments<code>input</code> - Circuit element to compute the inverse of  # ReturnsA new circuit element representing <code>input^(-1) mod p</code>  # Examples</p>
<pre><code class="language-cairo">let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let inv_a = circuit_inverse(a);
</code></pre>
<p>Fully qualified path: <code>core::circuit::circuit_inverse</code></p>
<pre><code class="language-rust">pub fn circuit_inverse&lt;Input, +CircuitElementTrait&lt;Input&gt;&gt;(
    input: CircuitElement&lt;Input&gt;,
) -&gt; CircuitElement&lt;InverseGate&lt;Input&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_mul"><a class="header" href="#circuit_mul">circuit_mul</a></h1>
<p>Creates a new circuit element representing multiplication modulo p of two input circuits.This function combines two circuit elements using modular multiplication, creating a new circuit element that represents their product modulo the circuit's modulus.  # Arguments<code>lhs</code> - Left-hand side circuit element * <code>rhs</code> - Right-hand side circuit element  # ReturnsA new circuit element representing <code>(lhs * rhs) mod p</code>  # Examples</p>
<pre><code class="language-cairo">let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
let product = circuit_mul(a, b);
</code></pre>
<p>Fully qualified path: <code>core::circuit::circuit_mul</code></p>
<pre><code class="language-rust">pub fn circuit_mul&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement&lt;MulModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check_ecdsa_signature"><a class="header" href="#check_ecdsa_signature">check_ecdsa_signature</a></h1>
<p>Verifies an ECDSA signature against a message hash and public key.Note: the verification algorithm implemented by this function slightly deviates from the standard ECDSA. While this does not allow to create valid signatures if one does not possess the private key, it means that the signature algorithm used should be modified accordingly. This function validates that <code>s</code> and <code>r</code> are not 0 or equal to the curve order, but does not check that <code>r, s &lt; stark_curve::ORDER</code>, which should be checked by the caller.  # Arguments * <code>message_hash</code> - The hash of the signed message * <code>public_key</code> - The x-coordinate of the signer's public key point on the STARK curve * <code>signature_r</code> - The r component of the ECDSA signature (x-coordinate of point R) * <code>signature_s</code> - The s component of the ECDSA signature  # Returns Returns <code>true</code> if the signature is valid, <code>false</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">use core::ecdsa::check_ecdsa_signature;

let message_hash = 0x2d6479c0758efbb5aa07d35ed5454d728637fceab7ba544d3ea95403a5630a8;
let pubkey = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca;
let r = 0x6ff7b413a8457ef90f326b5280600a4473fef49b5b1dcdfcd7f42ca7aa59c69;
let s = 0x23a9747ed71abc5cb956c0df44ee8638b65b3e9407deade65de62247b8fd77;
assert!(check_ecdsa_signature(message_hash, pubkey, r, s));
</code></pre>
<p>Fully qualified path: <code>core::ecdsa::check_ecdsa_signature</code></p>
<pre><code class="language-rust">pub fn check_ecdsa_signature(
    message_hash: felt252, public_key: felt252, signature_r: felt252, signature_s: felt252,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recover_public_key"><a class="header" href="#recover_public_key">recover_public_key</a></h1>
<p>Recovers the public key from an ECDSA signature and message hash.Given a valid ECDSA signature, the original message hash, and the y-coordinate parity of point R, this function recovers the signer's public key. This is useful in scenarios where you need to verify a message has been signed by a specific public key.  # Arguments * <code>message_hash</code> - The hash of the signed message * <code>signature_r</code> - The r component of the ECDSA signature (x-coordinate of point R) * <code>signature_s</code> - The s component of the ECDSA signature * <code>y_parity</code> - The parity of the y-coordinate of point R (<code>true</code> for odd, <code>false</code> for even)  # Returns Returns <code>Some(public_key)</code> containing the x-coordinate of the recovered public key point if the signature is valid, <code>None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">use core::ecdsa::recover_public_key;

let message_hash = 0x503f4bea29baee10b22a7f10bdc82dda071c977c1f25b8f3973d34e6b03b2c;
let signature_r = 0xbe96d72eb4f94078192c2e84d5230cde2a70f4b45c8797e2c907acff5060bb;
let signature_s = 0x677ae6bba6daf00d2631fab14c8acf24be6579f9d9e98f67aa7f2770e57a1f5;
assert!(
    recover_public_key(:message_hash, :signature_r, :signature_s, y_parity: false)
        .unwrap() == 0x7b7454acbe7845da996377f85eb0892044d75ae95d04d3325a391951f35d2ec,
)
</code></pre>
<p>Fully qualified path: <code>core::ecdsa::recover_public_key</code></p>
<pre><code class="language-rust">pub fn recover_public_key(
    message_hash: felt252, signature_r: felt252, signature_s: felt252, y_parity: bool,
) -&gt; Option&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wrapping_add"><a class="header" href="#u128_wrapping_add">u128_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u128_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u128_wrapping_add(lhs: u128, rhs: u128) -&gt; u128 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wrapping_sub"><a class="header" href="#u128_wrapping_sub">u128_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u128_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u128_wrapping_sub(a: u128, b: u128) -&gt; u128 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wide_mul"><a class="header" href="#u128_wide_mul">u128_wide_mul</a></h1>
<p>Multiplies two u128s and returns <code>(high, low)</code> - the 128-bit parts of the result.</p>
<p>Fully qualified path: <code>core::integer::u128_wide_mul</code></p>
<pre><code class="language-rust">pub fn u128_wide_mul(a: u128, b: u128) -&gt; (u128, u128) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_mul"><a class="header" href="#u128_overflowing_mul">u128_overflowing_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_mul</code></p>
<pre><code class="language-rust">pub fn u128_overflowing_mul(lhs: u128, rhs: u128) -&gt; (u128, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wrapping_add"><a class="header" href="#u8_wrapping_add">u8_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u8_wrapping_add(lhs: u8, rhs: u8) -&gt; u8 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wrapping_sub"><a class="header" href="#u8_wrapping_sub">u8_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u8_wrapping_sub(lhs: u8, rhs: u8) -&gt; u8 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wrapping_add"><a class="header" href="#u16_wrapping_add">u16_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u16_wrapping_add(lhs: u16, rhs: u16) -&gt; u16 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wrapping_sub"><a class="header" href="#u16_wrapping_sub">u16_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u16_wrapping_sub(lhs: u16, rhs: u16) -&gt; u16 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wrapping_add"><a class="header" href="#u32_wrapping_add">u32_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u32_wrapping_add(lhs: u32, rhs: u32) -&gt; u32 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wrapping_sub"><a class="header" href="#u32_wrapping_sub">u32_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u32_wrapping_sub(lhs: u32, rhs: u32) -&gt; u32 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wrapping_add"><a class="header" href="#u64_wrapping_add">u64_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u64_wrapping_add(lhs: u64, rhs: u64) -&gt; u64 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wrapping_sub"><a class="header" href="#u64_wrapping_sub">u64_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u64_wrapping_sub(lhs: u64, rhs: u64) -&gt; u64 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_add"><a class="header" href="#u256_overflowing_add">u256_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_add</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_add(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_sub"><a class="header" href="#u256_overflowing_sub">u256_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_sub</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_sub(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflow_sub"><a class="header" href="#u256_overflow_sub">u256_overflow_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflow_sub</code></p>
<pre><code class="language-rust">pub fn u256_overflow_sub(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_mul"><a class="header" href="#u256_overflowing_mul">u256_overflowing_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_mul</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_mul(lhs: u256, rhs: u256) -&gt; (u256, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflow_mul"><a class="header" href="#u256_overflow_mul">u256_overflow_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflow_mul</code></p>
<pre><code class="language-rust">pub fn u256_overflow_mul(lhs: u256, rhs: u256) -&gt; (u256, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_wide_mul"><a class="header" href="#u256_wide_mul">u256_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_wide_mul</code></p>
<pre><code class="language-rust">pub fn u256_wide_mul(a: u256, b: u256) -&gt; u512 nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u512_safe_div_rem_by_u256"><a class="header" href="#u512_safe_div_rem_by_u256">u512_safe_div_rem_by_u256</a></h1>
<p>Calculates division with remainder of a u512 by a non-zero u256.</p>
<p>Fully qualified path: <code>core::integer::u512_safe_div_rem_by_u256</code></p>
<pre><code class="language-rust">pub fn u512_safe_div_rem_by_u256(
    lhs: u512, rhs: NonZero&lt;u256&gt;,
) -&gt; (u512, u256) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min"><a class="header" href="#min">min</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns the smaller of the two values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::min;

assert!(min(0, 1) == 0);
</code></pre>
<p>Fully qualified path: <code>core::cmp::min</code></p>
<pre><code class="language-rust">pub fn min&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="max"><a class="header" href="#max">max</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns the greater of the two values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::max;

assert!(max(0, 1) == 1);
</code></pre>
<p>Fully qualified path: <code>core::cmp::max</code></p>
<pre><code class="language-rust">pub fn max&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minmax"><a class="header" href="#minmax">minmax</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns a tuple with the smaller value and the greater value.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::minmax;

assert!(minmax(0, 1) == (0, 1));
assert!(minmax(1, 0) == (0, 1));
</code></pre>
<p>Fully qualified path: <code>core::cmp::minmax</code></p>
<pre><code class="language-rust">pub fn minmax&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; (T, T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egcd"><a class="header" href="#egcd">egcd</a></h1>
<p>Computes the extended GCD and Bezout coefficients for two numbers.Uses the Extended Euclidean algorithm to find (g, s, t, sub_direction) where <code>g = gcd(a, b)</code>. The relationship between inputs and outputs is: * If <code>sub_direction</code> is true:  <code>g = s * a - t * b</code> * If <code>sub_direction</code> is false: <code>g = t * b - s * a</code>Returns a tuple (g, s, t, sub_direction) where g is the GCD and <code>(s, -t)</code> or <code>(-s, t)</code> are the Bezout coefficients (according to <code>sub_direction</code>).  # Examples</p>
<pre><code class="language-cairo">use core::math::egcd;

let (g, s, t, dir) = egcd::&lt;u32&gt;(12, 8);
assert!(g == 4);
</code></pre>
<p>Fully qualified path: <code>core::math::egcd</code></p>
<pre><code class="language-rust">pub fn egcd&lt;
    T,
    +Copy&lt;T&gt;,
    +Drop&lt;T&gt;,
    +Add&lt;T&gt;,
    +Mul&lt;T&gt;,
    +DivRem&lt;T&gt;,
    +core::num::traits::Zero&lt;T&gt;,
    +core::num::traits::One&lt;T&gt;,
    +TryInto&lt;T, NonZero&lt;T&gt;&gt;,
&gt;(
    a: NonZero&lt;T&gt;, b: NonZero&lt;T&gt;,
) -&gt; (T, T, T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inv_mod"><a class="header" href="#inv_mod">inv_mod</a></h1>
<p>Computes the modular multiplicative inverse of <code>a</code> modulo <code>n</code>.Returns <code>s</code> such that <code>a*s â‰¡ 1 (mod n)</code> where <code>s</code> is between <code>1</code> and <code>n-1</code> inclusive, or <code>None</code> if <code>gcd(a,n) &gt; 1</code> (inverse doesn't exist).  # Examples</p>
<pre><code class="language-cairo">use core::math::inv_mod;

let inv = inv_mod::&lt;u32&gt;(3, 7);
assert!(inv == Some(5));
</code></pre>
<p>Fully qualified path: <code>core::math::inv_mod</code></p>
<pre><code class="language-rust">pub fn inv_mod&lt;
    T,
    +Copy&lt;T&gt;,
    +Drop&lt;T&gt;,
    +Add&lt;T&gt;,
    +Sub&lt;T&gt;,
    +Mul&lt;T&gt;,
    +DivRem&lt;T&gt;,
    +core::num::traits::Zero&lt;T&gt;,
    +core::num::traits::One&lt;T&gt;,
    +TryInto&lt;T, NonZero&lt;T&gt;&gt;,
&gt;(
    a: NonZero&lt;T&gt;, n: NonZero&lt;T&gt;,
) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_inv_mod"><a class="header" href="#u256_inv_mod">u256_inv_mod</a></h1>
<p>Returns the inverse of <code>a</code> modulo <code>n</code>, or <code>None</code> if <code>a</code> is not invertible modulo <code>n</code>.All <code>a</code>s will be considered not invertible for <code>n == 1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_inv_mod;

let inv = u256_inv_mod(3, 17);
assert!(inv == Some(6));
</code></pre>
<p>Fully qualified path: <code>core::math::u256_inv_mod</code></p>
<pre><code class="language-rust">pub fn u256_inv_mod(a: u256, n: NonZero&lt;u256&gt;) -&gt; Option&lt;NonZero&lt;u256&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_div_mod_n"><a class="header" href="#u256_div_mod_n">u256_div_mod_n</a></h1>
<p>Returns <code>a / b (mod n)</code>, or <code>None</code> if <code>b</code> is not invertible modulo <code>n</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_inv_mod;

let result = u256_div_mod_n(17, 7, 29);
assert!(result == Some(19));
</code></pre>
<p>Fully qualified path: <code>core::math::u256_div_mod_n</code></p>
<pre><code class="language-rust">pub fn u256_div_mod_n(a: u256, b: u256, n: NonZero&lt;u256&gt;) -&gt; Option&lt;u256&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_mul_mod_n"><a class="header" href="#u256_mul_mod_n">u256_mul_mod_n</a></h1>
<p>Returns <code>a * b (mod n)</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_mul_mod_n;

let result = u256_mul_mod_n(17, 23, 29);
assert!(result == 14);
</code></pre>
<p>Fully qualified path: <code>core::math::u256_mul_mod_n</code></p>
<pre><code class="language-rust">pub fn u256_mul_mod_n(a: u256, b: u256, n: NonZero&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_with_byte_array"><a class="header" href="#panic_with_byte_array">panic_with_byte_array</a></h1>
<p>Panics with a <code>ByteArray</code> message.Constructs a panic message by prepending the <code>BYTE_ARRAY_MAGIC</code> value and serializing the provided <code>ByteArray</code> into the panic data.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic_with_byte_array;

let error_msg = "An error occurred";
panic_with_byte_array(@error_msg);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic_with_byte_array</code></p>
<pre><code class="language-rust">pub fn panic_with_byte_array(err: @ByteArray) -&gt; crate::never</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_u256s_le_inputs"><a class="header" href="#keccak_u256s_le_inputs">keccak_u256s_le_inputs</a></h1>
<p>Computes the Keccak-256 hash of multiple <code>u256</code> values in little-endian format.  # Arguments<code>input</code> - A span of little-endian <code>u256</code> values to be hashed  # ReturnsThe 32-byte Keccak-256 hash as a little-endian <code>u256</code>  # Examples</p>
<pre><code class="language-cairo">use core::keccak::keccak_u256s_le_inputs;

let input: Span&lt;u256&gt; = array![0, 1, 2].span();
assert!(keccak_u256s_le_inputs(input) ==
0xf005473605efc7d8ff67d9f23fe2e4a4f23454c12b49b38822ed362e0a92a0a6);
</code></pre>
<p>Fully qualified path: <code>core::keccak::keccak_u256s_le_inputs</code></p>
<pre><code class="language-rust">pub fn keccak_u256s_le_inputs(mut input: Span&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_u256s_be_inputs"><a class="header" href="#keccak_u256s_be_inputs">keccak_u256s_be_inputs</a></h1>
<p>Computes the Keccak-256 hash of multiple <code>u256</code> values in big-endian format.  # Arguments<code>input</code> - A span of big-endian <code>u256</code> values to be hashed  # ReturnsThe 32-byte Keccak-256 hash as a little-endian <code>u256</code>  # Examples</p>
<pre><code class="language-cairo">use core::keccak::keccak_u256s_be_inputs;

let input = array![0x1234_u256, 0x5678_u256].span();
let hash = assert!(keccak_u256s_be_inputs(input) ==
0xfa31cb2326ed629f79d2da5beb78e2bd8ac7a1b8b86cae09eeb6a89a908b12a);
</code></pre>
<p>Fully qualified path: <code>core::keccak::keccak_u256s_be_inputs</code></p>
<pre><code class="language-rust">pub fn keccak_u256s_be_inputs(mut input: Span&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo_keccak"><a class="header" href="#cairo_keccak">cairo_keccak</a></h1>
<p>Computes the Keccak-256 hash of a byte sequence with custom padding.This function allows hashing arbitrary byte sequences by providing the input as 64-bit words in little-endian format and a final partial word.  # Arguments<code>input</code> - Array of complete 64-bit words in little-endian format * <code>last_input_word</code> - Final partial word (if any) * <code>last_input_num_bytes</code> - Number of valid bytes in the final word (0-7)  # ReturnsThe 32-byte Keccak-256 hash as a little-endian <code>u256</code>  # PanicsPanics if <code>last_input_num_bytes</code> is greater than 7.  # Examples</p>
<pre><code class="language-cairo">use core::keccak::cairo_keccak;

// Hash "Hello world!" by splitting into 64-bit words in little-endian
let mut input = array![0x6f77206f6c6c6548]; // a full 8-byte word
let hash = cairo_keccak(ref input, 0x21646c72, 4); // 4 bytes of the last word
assert!(hash == 0xabea1f2503529a21734e2077c8b584d7bee3f45550c2d2f12a198ea908e1d0ec);
</code></pre>
<p>Fully qualified path: <code>core::keccak::cairo_keccak</code></p>
<pre><code class="language-rust">pub fn cairo_keccak(
    ref input: Array&lt;u64&gt;, last_input_word: u64, last_input_num_bytes: usize,
) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_keccak_byte_array"><a class="header" href="#compute_keccak_byte_array">compute_keccak_byte_array</a></h1>
<p>Computes the Keccak-256 hash of a <code>ByteArray</code>.  # Arguments<code>arr</code> - The input bytes to hash  # ReturnsThe 32-byte Keccak-256 hash as a little-endian <code>u256</code>  # Examples</p>
<pre><code class="language-cairo">use core::keccak::compute_keccak_byte_array;

let text: ByteArray = "Hello world!";
let hash = compute_keccak_byte_array(@text);
assert!(hash == 0xabea1f2503529a21734e2077c8b584d7bee3f45550c2d2f12a198ea908e1d0ec);
</code></pre>
<p>Fully qualified path: <code>core::keccak::compute_keccak_byte_array</code></p>
<pre><code class="language-rust">pub fn compute_keccak_byte_array(arr: @ByteArray) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_sha256_u32_array"><a class="header" href="#compute_sha256_u32_array">compute_sha256_u32_array</a></h1>
<p>Computes the SHA-256 hash of an array of 32-bit words.  # Arguments<code>input</code> - An array of <code>u32</code> values to hash * <code>last_input_word</code> - The final word when input is not word-aligned * <code>last_input_num_bytes</code> - Number of bytes in the last input word (must be less than 4)  # ReturnsThe SHA-256 hash of the <code>input array</code> + <code>last_input_word</code> as big endian  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_u32_array;

let hash = compute_sha256_u32_array(array![0x68656c6c], 0x6f, 1);
assert!(hash == [0x2cf24dba, 0x5fb0a30e, 0x26e83b2a, 0xc5b9e29e, 0x1b161e5c, 0x1fa7425e,
0x73043362, 0x938b9824]);
</code></pre>
<p>Fully qualified path: <code>core::sha256::compute_sha256_u32_array</code></p>
<pre><code class="language-rust">pub fn compute_sha256_u32_array(
    mut input: Array&lt;u32&gt;, last_input_word: u32, last_input_num_bytes: u32,
) -&gt; [u32; 8]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_sha256_byte_array"><a class="header" href="#compute_sha256_byte_array">compute_sha256_byte_array</a></h1>
<p>Computes the SHA-256 hash of the input <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_byte_array;

</code></pre>
<p>Fully qualified path: <code>core::sha256::compute_sha256_byte_array</code></p>
<pre><code class="language-rust">pub fn compute_sha256_byte_array(arr: @ByteArray) -&gt; [u32; 8]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon_hash_span"><a class="header" href="#poseidon_hash_span">poseidon_hash_span</a></h1>
<p>Computes the Poseidon hash on the given span input. Applies the sponge construction to digest many elements. To distinguish between use cases, the capacity element is initialized to 0. To distinguish between different input sizes always pads with 1, and possibly with another 0 to complete to an even-sized input.  # Examples</p>
<pre><code class="language-cairo">let span = [1, 2].span();
let hash = poseidon_hash_span(span);

assert!(hash == 0x0371cb6995ea5e7effcd2e174de264b5b407027a75a231a70c2c8d196107f0e7);
</code></pre>
<p>Fully qualified path: <code>core::poseidon::poseidon_hash_span</code></p>
<pre><code class="language-rust">pub fn poseidon_hash_span(mut span: Span&lt;felt252&gt;) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print_byte_array_as_string"><a class="header" href="#print_byte_array_as_string">print_byte_array_as_string</a></h1>
<p>Prints a <code>ByteArray</code> as a string.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
print_byte_array_as_string(@ba);
</code></pre>
<p>Fully qualified path: <code>core::debug::print_byte_array_as_string</code></p>
<pre><code class="language-rust">pub fn print_byte_array_as_string(self: @ByteArray)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_info"><a class="header" href="#get_block_info">get_block_info</a></h1>
<p>Returns the block information for the current block.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_block_info;

let block_info = get_block_info().unbox();

let block_number = block_info.block_number;
let block_timestamp = block_info.block_timestamp;
let sequencer = block_info.sequencer_address;
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_block_info</code></p>
<pre><code class="language-rust">pub fn get_block_info() -&gt; Box&lt;BlockInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_number"><a class="header" href="#get_block_number">get_block_number</a></h1>
<p>Returns the number of the current block.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_block_number;

let block_number = get_block_number();
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_block_number</code></p>
<pre><code class="language-rust">pub fn get_block_number() -&gt; u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_timestamp"><a class="header" href="#get_block_timestamp">get_block_timestamp</a></h1>
<p>Returns the timestamp of the current block.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_block_timestamp;

let block_timestamp = get_block_timestamp();
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_block_timestamp</code></p>
<pre><code class="language-rust">pub fn get_block_timestamp() -&gt; u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_caller_address"><a class="header" href="#get_caller_address">get_caller_address</a></h1>
<p>Returns the address of the caller contract.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_caller_address;

let caller = get_caller_address();
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_caller_address</code></p>
<pre><code class="language-rust">pub fn get_caller_address() -&gt; ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_contract_address"><a class="header" href="#get_contract_address">get_contract_address</a></h1>
<p>Returns the address of the contract being executed.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_contract_address;

let contract_address = get_contract_address();
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_contract_address</code></p>
<pre><code class="language-rust">pub fn get_contract_address() -&gt; ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info"><a class="header" href="#get_execution_info">get_execution_info</a></h1>
<p>Returns the execution info for the current execution.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_execution_info;

let execution_info = get_execution_info().unbox();

// Access various execution context information
let caller = execution_info.caller_address;
let contract = execution_info.contract_address;
let selector = execution_info.entry_point_selector;
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_execution_info</code></p>
<pre><code class="language-rust">pub fn get_execution_info() -&gt; Box&lt;v2::ExecutionInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_tx_info"><a class="header" href="#get_tx_info">get_tx_info</a></h1>
<p>Returns the transaction information for the current transaction.  # Examples</p>
<pre><code class="language-cairo">use starknet::get_tx_info;

let tx_info = get_tx_info().unbox();

let account_contract_address = tx_info.account_contract_address;
let chain_id = tx_info.chain_id;
let nonce = tx_info.nonce;
let max_fee = tx_info.max_fee;
let tx_hash = tx_info.transaction_hash;
let signature = tx_info.signature;
let version = tx_info.version;
</code></pre>
<p>Fully qualified path: <code>core::starknet::info::get_tx_info</code></p>
<pre><code class="language-rust">pub fn get_tx_info() -&gt; Box&lt;v2::TxInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature_from_vrs"><a class="header" href="#signature_from_vrs">signature_from_vrs</a></h1>
<p>Creates an ECDSA signature from the <code>v</code>, <code>r</code>, and <code>s</code> values.<code>v</code> is the sum of an odd number and the parity of the y coordinate of the ec point whose x coordinate is <code>r</code>.See https://eips.ethereum.org/EIPS/eip-155 for more details.  # Examples</p>
<pre><code class="language-cairo">use starknet::secp256_trait::signature_from_vrs;

let signature = signature_from_vrs(0,
0xa73bd4903f0ce3b639bbbf6e8e80d16931ff4bcf5993d58468e8fb19086e8cac,
0x36dbcd03009df8c59286b162af3bd7fcc0450c9aa81be5d10d312af6c66b1d60);
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::signature_from_vrs</code></p>
<pre><code class="language-rust">pub fn signature_from_vrs(v: u32, r: u256, s: u256) -&gt; Signature</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_signature_entry_valid"><a class="header" href="#is_signature_entry_valid">is_signature_entry_valid</a></h1>
<p>Checks whether the given <code>value</code> is in the range [1, N), where N is the size of the curve.For ECDSA signatures to be secure, both <code>r</code> and <code>s</code> components must be in the range [1, N), where N is the order of the curve. Enforcing this range prevents signature malleability attacks where an attacker could create multiple valid signatures for the same message by adding multiples of N. This function validates that a given value meets this requirement.  # ReturnsReturns <code>true</code> if the value is in the valid range [1, N), <code>false</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">use starknet::secp256r1::Secp256r1Point;
use starknet::secp256_trait::is_signature_entry_valid;

assert!(!is_signature_entry_valid::&lt;Secp256r1Point&gt;(0));
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::is_signature_entry_valid</code></p>
<pre><code class="language-rust">pub fn is_signature_entry_valid&lt;
    Secp256Point, +Drop&lt;Secp256Point&gt;, impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
&gt;(
    value: u256,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_valid_signature"><a class="header" href="#is_valid_signature">is_valid_signature</a></h1>
<p>Checks whether a signature is valid given a public key point and a message hash.  # Examples</p>
<pre><code class="language-cairo">use starknet::SyscallResultTrait;
use starknet::secp256r1::Secp256r1Point;
use starknet::secp256_trait::{Secp256Trait, is_valid_signature};

let msg_hash = 0x4cee90eb86eaa050036147a12d49004b6b9c72bd725d39d4785011fe190f0b4d;
let r = 0xa73bd4903f0ce3b639bbbf6e8e80d16931ff4bcf5993d58468e8fb19086e8cac;
let s = 0x36dbcd03009df8c59286b162af3bd7fcc0450c9aa81be5d10d312af6c66b1d60;
let public_key = Secp256Trait::secp256_ec_new_syscall(
    0x4aebd3099c618202fcfe16ae7770b0c49ab5eadf74b754204a3bb6060e44eff3,
    0x7618b065f9832de4ca6ca971a7a1adc826d0f7c00181a5fb2ddf79ae00b4e10e,
)
    .unwrap_syscall()
    .unwrap();

assert!(is_valid_signature::&lt;Secp256r1Point&gt;(msg_hash, r, s, public_key));
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::is_valid_signature</code></p>
<pre><code class="language-rust">pub fn is_valid_signature&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    msg_hash: u256, r: u256, s: u256, public_key: Secp256Point,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recover_public_key-1"><a class="header" href="#recover_public_key-1">recover_public_key</a></h1>
<p>Recovers the public key associated with a given signature and message hash.Returns the public key as a point on the curve.  # Examples</p>
<pre><code class="language-cairo">use starknet::secp256r1::Secp256r1Point;
use starknet::secp256_trait::{Signature, recover_public_key};

let msg_hash = 0x4cee90eb86eaa050036147a12d49004b6b9c72bd725d39d4785011fe190f0b4d;

let signature = Signature {
    r: 0xa73bd4903f0ce3b639bbbf6e8e80d16931ff4bcf5993d58468e8fb19086e8cac,
    s: 0x36dbcd03009df8c59286b162af3bd7fcc0450c9aa81be5d10d312af6c66b1d60,
    y_parity: true,
};

let public_key = recover_public_key::&lt;Secp256r1Point&gt;(msg_hash, signature);
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::recover_public_key</code></p>
<pre><code class="language-rust">pub fn recover_public_key&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    msg_hash: u256, signature: Signature,
) -&gt; Option&lt;Secp256Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verify_eth_signature"><a class="header" href="#verify_eth_signature">verify_eth_signature</a></h1>
<p>Asserts that an Ethereum signature is valid for a given message hash and Ethereum address. Also verifies that the <code>r</code> and <code>s</code> components of the signature are in the range <code>[1, N)</code>, where N is the size of the curve.  # Arguments<code>msg_hash</code> - The 32-byte hash of the message that was signed * <code>signature</code> - The Ethereum signature containing <code>r</code>, <code>s</code> components and <code>y_parity</code> * <code>eth_address</code> - The expected Ethereum address of the signer  # PanicsPanics if: * The signature components are out of range (not in [1, N) where N is the curve order) * The recovered address doesn't match the provided address  # Examples</p>
<pre><code class="language-cairo">use starknet::eth_address::EthAddress;
use starknet::eth_signature::verify_eth_signature;
use starknet::secp256_trait::Signature;

let msg_hash = 0xe888fbb4cf9ae6254f19ba12e6d9af54788f195a6f509ca3e934f78d7a71dd85;
let r = 0x4c8e4fbc1fbb1dece52185e532812c4f7a5f81cf3ee10044320a0d03b62d3e9a;
let s = 0x4ac5e5c0c0e8a4871583cc131f35fb49c2b7f60e6a8b84965830658f08f7410c;
let y_parity = true;
let eth_address: EthAddress = 0x767410c1bb448978bd42b984d7de5970bcaf5c43_u256
    .try_into()
    .unwrap();
verify_eth_signature(msg_hash, Signature { r, s, y_parity }, eth_address);
</code></pre>
<p>Fully qualified path: <code>core::starknet::eth_signature::verify_eth_signature</code></p>
<pre><code class="language-rust">pub fn verify_eth_signature(msg_hash: u256, signature: Signature, eth_address: EthAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_eth_signature_valid"><a class="header" href="#is_eth_signature_valid">is_eth_signature_valid</a></h1>
<p>Validates an Ethereum signature against a message hash and Ethereum address. Similar to <code>verify_eth_signature</code> but returns a <code>Result</code> instead of panicking. Also verifies that <code>r</code> and <code>s</code> components of the signature are in the range <code>[1, N)</code>, where N is the size of the curve.  # Arguments<code>msg_hash</code> - The 32-byte hash of the message that was signed * <code>signature</code> - The Ethereum signature containing <code>r</code>, <code>s</code> components and <code>y_parity</code> * <code>eth_address</code> - The expected Ethereum address of the signer  # ReturnsReturns <code>Ok(())</code> if the signature is valid, or <code>Err(felt252)</code> containing an error message if invalid.  # Examples</p>
<pre><code class="language-cairo">use starknet::eth_address::EthAddress;
use starknet::eth_signature::is_eth_signature_valid;
use starknet::secp256_trait::Signature;

let msg_hash = 0xe888fbb4cf9ae6254f19ba12e6d9af54788f195a6f509ca3e934f78d7a71dd85;
let r = 0x4c8e4fbc1fbb1dece52185e532812c4f7a5f81cf3ee10044320a0d03b62d3e9a;
let s = 0x4ac5e5c0c0e8a4871583cc131f35fb49c2b7f60e6a8b84965830658f08f7410c;
let y_parity = true;
let eth_address: EthAddress = 0x767410c1bb448978bd42b984d7de5970bcaf5c43_u256
    .try_into()
    .unwrap();
assert!(is_eth_signature_valid(msg_hash, Signature { r, s, y_parity }, eth_address).is_ok());
</code></pre>
<p>Fully qualified path: <code>core::starknet::eth_signature::is_eth_signature_valid</code></p>
<pre><code class="language-rust">pub fn is_eth_signature_valid(
    msg_hash: u256, signature: Signature, eth_address: EthAddress,
) -&gt; Result&lt;(), felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public_key_point_to_eth_address"><a class="header" href="#public_key_point_to_eth_address">public_key_point_to_eth_address</a></h1>
<p>Converts a public key point to its corresponding Ethereum address.The Ethereum address is calculated by taking the Keccak-256 hash of the public key coordinates and taking the last 20 big-endian bytes.  # Arguments<code>public_key_point</code> - A point on a secp256 curve representing a public key  # ReturnsThe 20-byte Ethereum address derived from the public key  # Examples</p>
<pre><code class="language-cairo">use starknet::eth_signature::public_key_point_to_eth_address;
use starknet::secp256k1::Secp256k1Point;
use starknet::secp256_trait::Secp256Trait;

let public_key: Secp256k1Point = Secp256Trait::secp256_ec_get_point_from_x_syscall(
    0xa9a02d48081294b9bb0d8740d70d3607feb20876964d432846d9b9100b91eefd, false,
)
    .unwrap()
    .unwrap();
let eth_address = public_key_point_to_eth_address(public_key);
assert!(eth_address == 0x767410c1bb448978bd42b984d7de5970bcaf5c43.try_into().unwrap());
</code></pre>
<p>Fully qualified path: <code>core::starknet::eth_signature::public_key_point_to_eth_address</code></p>
<pre><code class="language-rust">pub fn public_key_point_to_eth_address&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    +Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    public_key_point: Secp256Point,
) -&gt; EthAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_number"><a class="header" href="#set_block_number">set_block_number</a></h1>
<p>Sets the block number to the provided value.  # Arguments<code>block_number</code> - The block number to set.After a call to <code>set_block_number</code>, <code>starknet::get_execution_info().block_info.block_number</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_number</code></p>
<pre><code class="language-rust">pub fn set_block_number(block_number: u64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_caller_address"><a class="header" href="#set_caller_address">set_caller_address</a></h1>
<p>Sets the caller address to the provided value.  # Arguments<code>address</code> - The caller address to set.After a call to <code>set_caller_address</code>, <code>starknet::get_execution_info().caller_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_caller_address</code></p>
<pre><code class="language-rust">pub fn set_caller_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_contract_address"><a class="header" href="#set_contract_address">set_contract_address</a></h1>
<p>Sets the contract address to the provided value.  # Arguments<code>address</code> - The contract address to set.After a call to <code>set_contract_address</code>, <code>starknet::get_execution_info().contract_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_contract_address</code></p>
<pre><code class="language-rust">pub fn set_contract_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_sequencer_address"><a class="header" href="#set_sequencer_address">set_sequencer_address</a></h1>
<p>Sets the sequencer address to the provided value.  # Arguments<code>address</code> - The sequencer address to set.After a call to <code>set_sequencer_address</code>, <code>starknet::get_execution_info().block_info.sequencer_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_sequencer_address</code></p>
<pre><code class="language-rust">pub fn set_sequencer_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_timestamp"><a class="header" href="#set_block_timestamp">set_block_timestamp</a></h1>
<p>Sets the block timestamp to the provided value.  # Arguments<code>block_timestamp</code> - The block timestamp to set.After a call to <code>set_block_timestamp</code>, <code>starknet::get_execution_info().block_info.block_timestamp</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_timestamp</code></p>
<pre><code class="language-rust">pub fn set_block_timestamp(block_timestamp: u64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_version"><a class="header" href="#set_version">set_version</a></h1>
<p>Sets the version to the provided value.  # Arguments<code>version</code> - The version to set.After a call to <code>set_version</code>, <code>starknet::get_execution_info().tx_info.version</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_version</code></p>
<pre><code class="language-rust">pub fn set_version(version: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_account_contract_address"><a class="header" href="#set_account_contract_address">set_account_contract_address</a></h1>
<p>Sets the account contract address.  # Arguments<code>address</code> - The account contract to set.After a call to <code>set_account_contract_address</code>, <code>starknet::get_execution_info().tx_info.account_contract_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_account_contract_address</code></p>
<pre><code class="language-rust">pub fn set_account_contract_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_max_fee"><a class="header" href="#set_max_fee">set_max_fee</a></h1>
<p>Sets the transaction max fee.  # Arguments<code>fee</code> - The max fee to set.After a call to <code>set_max_fee</code>, <code>starknet::get_execution_info().tx_info.max_fee</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_max_fee</code></p>
<pre><code class="language-rust">pub fn set_max_fee(fee: u128)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_transaction_hash"><a class="header" href="#set_transaction_hash">set_transaction_hash</a></h1>
<p>Sets the transaction hash.  # Arguments<code>hash</code> - The transaction hash to set.After a call to <code>set_transaction_hash</code>, <code>starknet::get_execution_info().tx_info.transaction_hash</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_transaction_hash</code></p>
<pre><code class="language-rust">pub fn set_transaction_hash(hash: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_chain_id"><a class="header" href="#set_chain_id">set_chain_id</a></h1>
<p>Set the transaction chain id.  # Arguments<code>chain_id</code> - The chain id to set.After a call to <code>set_chain_id</code>, <code>starknet::get_execution_info().tx_info.chain_id</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_chain_id</code></p>
<pre><code class="language-rust">pub fn set_chain_id(chain_id: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_nonce"><a class="header" href="#set_nonce">set_nonce</a></h1>
<p>Set the transaction nonce.  # Arguments<code>non</code> - The nonce to set.After a call to <code>set_nonce</code>, <code>starknet::get_execution_info().tx_info.nonce</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_nonce</code></p>
<pre><code class="language-rust">pub fn set_nonce(nonce: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_signature"><a class="header" href="#set_signature">set_signature</a></h1>
<p>Set the transaction signature.  # Arguments<code>signature</code> - The signature to set.After a call to <code>set_signature</code>, <code>starknet::get_execution_info().tx_info.signature</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_signature</code></p>
<pre><code class="language-rust">pub fn set_signature(signature: Span&lt;felt252&gt;)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_hash"><a class="header" href="#set_block_hash">set_block_hash</a></h1>
<p>Set the hash for a block.  # Arguments<code>block_number</code> - The targeted block number. <code>value</code> - The block hash to set.After a call to <code>set_block_hash</code>, <code>starknet::syscalls::get_block_hash_syscall</code> for the block_number will return the set value. Unset blocks values call would fail.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_hash</code></p>
<pre><code class="language-rust">pub fn set_block_hash(block_number: u64, value: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_log_raw"><a class="header" href="#pop_log_raw">pop_log_raw</a></h1>
<p>Pop the earliest unpopped logged event for the contract.  # Arguments<code>address</code> - The contract address from which to pop an event.The value is returned as a tuple of two spans, the first for the keys and the second for the data. May be called multiple times to pop multiple events. If called until <code>None</code> is returned, all events have been popped.</p>
<p>Fully qualified path: <code>core::starknet::testing::pop_log_raw</code></p>
<pre><code class="language-rust">pub fn pop_log_raw(address: ContractAddress) -&gt; Option&lt;(Span&lt;felt252&gt;, Span&lt;felt252&gt;)&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_log"><a class="header" href="#pop_log">pop_log</a></h1>
<p>Pop the earliest unpopped logged event for the contract as the requested type.  # Arguments<code>address</code> - The contract address from which to pop an event.Should be used when the type of the event is known. Type of the event should be the event defined within the contract. Useful for testing the contract's event emission. May be called multiple times to pop multiple events. If called until <code>None</code> is returned, all events have been popped.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[starknet::contract]
</span>mod contract {
<span class="boring">   [event]
</span><span class="boring">   [derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
</span>   pub enum Event {
      Event1: felt252,
      Event2: u128,
   }
   ...
}

<span class="boring">[test]
</span>fn test_event() {
    let contract_address = somehow_get_contract_address();
    call_code_causing_events(contract_address);
    assert_eq!(
        starknet::testing::pop_log(contract_address), Some(contract::Event::Event1(42))
    );
    assert_eq!(
        starknet::testing::pop_log(contract_address), Some(contract::Event::Event2(41))
    );
    assert_eq!(
        starknet::testing::pop_log(contract_address), Some(contract::Event::Event1(40))
    );
    assert_eq!(starknet::testing::pop_log_raw(contract_address), None);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::testing::pop_log</code></p>
<pre><code class="language-rust">pub fn pop_log&lt;T, +starknet::Event&lt;T&gt;&gt;(address: ContractAddress) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_l2_to_l1_message"><a class="header" href="#pop_l2_to_l1_message">pop_l2_to_l1_message</a></h1>
<p>Pop the earliest unpopped l2 to l1 message for the contract.  # Arguments<code>address</code> - The contract address from which to pop a l2-L1 message.The returned value is a tuple of the l1 address the message was sent to as a <code>felt252</code>, and the message data as a span. May be called multiple times to pop multiple messages. Useful for testing the contract's l2 to l1 message emission.</p>
<p>Fully qualified path: <code>core::starknet::testing::pop_l2_to_l1_message</code></p>
<pre><code class="language-rust">pub fn pop_l2_to_l1_message(address: ContractAddress) -&gt; Option&lt;(felt252, Span&lt;felt252&gt;)&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-16"><a class="header" href="#structs-16">Structs</a></h1>
<ul>
<li>
<p><a href="./core-circuit-u384.html">u384</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElement.html">CircuitElement</a></p>
</li>
<li>
<p><a href="./core-array-Span.html">Span</a></p>
</li>
<li>
<p><a href="./core-array-SpanIter.html">SpanIter</a></p>
</li>
<li>
<p><a href="./core-array-ArrayIter.html">ArrayIter</a></p>
</li>
<li>
<p><a href="./core-option-OptionIter.html">OptionIter</a></p>
</li>
<li>
<p><a href="./core-integer-u256.html">u256</a></p>
</li>
<li>
<p><a href="./core-integer-u512.html">u512</a></p>
</li>
<li>
<p><a href="./core-ops-range-Range.html">Range</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusive.html">RangeInclusive</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusiveIterator.html">RangeInclusiveIterator</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeIterator.html">RangeIterator</a></p>
</li>
<li>
<p><a href="./core-panics-Panic.html">Panic</a></p>
</li>
<li>
<p><a href="./core-pedersen-HashState.html">pedersen::HashState</a></p>
</li>
<li>
<p><a href="./core-poseidon-HashState.html">poseidon::HashState</a></p>
</li>
<li>
<p><a href="./core-fmt-Error.html">Error</a></p>
</li>
<li>
<p><a href="./core-fmt-Formatter.html">Formatter</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">starknet::eth_address::EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ExecutionInfo.html">ExecutionInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ResourceBounds.html">ResourceBounds</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-TxInfo.html">TxInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-BlockInfo.html">BlockInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Signature.html">Signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">starknet::eth_address::EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-account-Call.html">Call</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcher.html">AccountContractDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractLibraryDispatcher.html">AccountContractLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeLibraryDispatcher.html">AccountContractSafeLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcher.html">AccountContractSafeDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer.html">StoragePointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer0Offset.html">StoragePointer0Offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePath.html">StoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePath.html">PendingStoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-Mutable.html">Mutable</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-Map.html">Map</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-FlattenedStorage.html">FlattenedStorage</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageBase.html">StorageBase</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-Vec.html">Vec</a></p>
</li>
<li>
<p><a href="./core-internal-DropWith.html">DropWith</a></p>
</li>
<li>
<p><a href="./core-internal-InferDrop.html">InferDrop</a></p>
</li>
<li>
<p><a href="./core-internal-DestructWith.html">DestructWith</a></p>
</li>
<li>
<p><a href="./core-internal-InferDestruct.html">InferDestruct</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArray.html">ByteArray</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayIter.html">ByteArrayIter</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u384"><a class="header" href="#u384">u384</a></h1>
<p>A 384-bit unsigned integer, used for circuit values.</p>
<p>Fully qualified path: <code>core::circuit::u384</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, PartialEq)]
pub struct u384 {
    pub limb0: u96,
    pub limb1: u96,
    pub limb2: u96,
    pub limb3: u96,
}</code></pre>
<h2 id="members"><a class="header" href="#members">Members</a></h2>
<h3 id="limb0"><a class="header" href="#limb0">limb0</a></h3>
<p>The least significant 96 bits</p>
<p>Fully qualified path: <code>core::circuit::u384::limb0</code></p>
<pre><code class="language-rust">pub limb0: u96</code></pre>
<h3 id="limb1"><a class="header" href="#limb1">limb1</a></h3>
<p>Bits 96-191</p>
<p>Fully qualified path: <code>core::circuit::u384::limb1</code></p>
<pre><code class="language-rust">pub limb1: u96</code></pre>
<h3 id="limb2"><a class="header" href="#limb2">limb2</a></h3>
<p>Bits 192-287</p>
<p>Fully qualified path: <code>core::circuit::u384::limb2</code></p>
<pre><code class="language-rust">pub limb2: u96</code></pre>
<h3 id="limb3"><a class="header" href="#limb3">limb3</a></h3>
<p>The most significant 96 bits</p>
<p>Fully qualified path: <code>core::circuit::u384::limb3</code></p>
<pre><code class="language-rust">pub limb3: u96</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelement"><a class="header" href="#circuitelement">CircuitElement</a></h1>
<p>A wrapper for circuit elements, used to construct circuits.This type provides a generic wrapper around different circuit components (inputs, gates) and enables composition of circuit elements through arithmetic operations. The type parameter <code>T</code> defines the specific role of the element in the circuit.</p>
<p>Fully qualified path: <code>core::circuit::CircuitElement</code></p>
<pre><code class="language-rust">pub struct CircuitElement&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="span"><a class="header" href="#span">Span</a></h1>
<p>A span is a view into a contiguous collection of the same type - such as <code>Array</code>. It is a structure with a single field that holds a snapshot of an array. <code>Span</code> implements the <code>Copy</code> and the <code>Drop</code> traits.</p>
<p>Fully qualified path: <code>core::array::Span</code></p>
<pre><code class="language-rust">pub struct Span&lt;T&gt; {
    pub(crate) snapshot: @Array&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spaniter"><a class="header" href="#spaniter">SpanIter</a></h1>
<p>An iterator struct over a span collection.</p>
<p>Fully qualified path: <code>core::array::SpanIter</code></p>
<pre><code class="language-rust">pub struct SpanIter&lt;T&gt; {
    span: Span&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrayiter"><a class="header" href="#arrayiter">ArrayIter</a></h1>
<p>An iterator struct over an array collection.</p>
<p>Fully qualified path: <code>core::array::ArrayIter</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct ArrayIter&lt;T&gt; {
    array: Array&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optioniter"><a class="header" href="#optioniter">OptionIter</a></h1>
<p>An iterator over the value in the <a href="./core-option.html#some"><code>Some</code></a> variant of an <a href="./core-option-Option.html"><code>Option</code></a>.The iterator yields one value if the <a href="./core-option-Option.html"><code>Option</code></a> is a <a href="./core-option.html#some"><code>Some</code></a>, otherwise none.This struct is created by the <a href="%60into_iter%60"><code>into_iter</code></a> method on <a href="./core-option-Option.html"><code>Option</code></a> (provided by the <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a> trait).</p>
<p>Fully qualified path: <code>core::option::OptionIter</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct OptionIter&lt;T&gt; {
    inner: Option&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256"><a class="header" href="#u256">u256</a></h1>
<p>The 256-bit unsigned integer type.The <code>u256</code> type is composed of two 128-bit parts: the low part [0, 128) and the high part [128, 256).</p>
<p>Fully qualified path: <code>core::integer::u256</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq, Serde)]
pub struct u256 {
    pub low: u128,
    pub high: u128,
}</code></pre>
<h2 id="members-1"><a class="header" href="#members-1">Members</a></h2>
<h3 id="low"><a class="header" href="#low">low</a></h3>
<p>Fully qualified path: <code>core::integer::u256::low</code></p>
<pre><code class="language-rust">pub low: u128</code></pre>
<h3 id="high"><a class="header" href="#high">high</a></h3>
<p>Fully qualified path: <code>core::integer::u256::high</code></p>
<pre><code class="language-rust">pub high: u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u512"><a class="header" href="#u512">u512</a></h1>
<p>Fully qualified path: <code>core::integer::u512</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq, Serde)]
pub struct u512 {
    pub limb0: u128,
    pub limb1: u128,
    pub limb2: u128,
    pub limb3: u128,
}</code></pre>
<h2 id="members-2"><a class="header" href="#members-2">Members</a></h2>
<h3 id="limb0-1"><a class="header" href="#limb0-1">limb0</a></h3>
<p>Fully qualified path: <code>core::integer::u512::limb0</code></p>
<pre><code class="language-rust">pub limb0: u128</code></pre>
<h3 id="limb1-1"><a class="header" href="#limb1-1">limb1</a></h3>
<p>Fully qualified path: <code>core::integer::u512::limb1</code></p>
<pre><code class="language-rust">pub limb1: u128</code></pre>
<h3 id="limb2-1"><a class="header" href="#limb2-1">limb2</a></h3>
<p>Fully qualified path: <code>core::integer::u512::limb2</code></p>
<pre><code class="language-rust">pub limb2: u128</code></pre>
<h3 id="limb3-1"><a class="header" href="#limb3-1">limb3</a></h3>
<p>Fully qualified path: <code>core::integer::u512::limb3</code></p>
<pre><code class="language-rust">pub limb3: u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range"><a class="header" href="#range">Range</a></h1>
<p>A (half-open) range bounded inclusively below and exclusively above (<code>start..end</code>).The range <code>start..end</code> contains all values with <code>start &lt;= x &lt; end</code>. It is empty if <code>start &gt;= end</code>.  # ExamplesThe <code>start..end</code> syntax is a <code>Range</code>:</p>
<pre><code class="language-cairo">assert!((3..5) == core::ops::Range { start: 3, end: 5 });

let mut sum = 0;
for i in 3..6 {
    sum += i;
}
assert!(sum == 3 + 4 + 5);
</code></pre>
<p>Fully qualified path: <code>core::ops::range::Range</code></p>
<pre><code class="language-rust">#[derive(Clone, Drop, PartialEq)]
pub struct Range&lt;T&gt; {
    pub start: T,
    pub end: T,
}</code></pre>
<h2 id="members-3"><a class="header" href="#members-3">Members</a></h2>
<h3 id="start"><a class="header" href="#start">start</a></h3>
<p>The lower bound of the range (inclusive).</p>
<p>Fully qualified path: <code>core::ops::range::Range::start</code></p>
<pre><code class="language-rust">pub start: T</code></pre>
<h3 id="end"><a class="header" href="#end">end</a></h3>
<p>The upper bound of the range (exclusive).</p>
<p>Fully qualified path: <code>core::ops::range::Range::end</code></p>
<pre><code class="language-rust">pub end: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangeinclusive"><a class="header" href="#rangeinclusive">RangeInclusive</a></h1>
<p>Represents the range [start, end](start, end).</p>
<p>Fully qualified path: <code>core::ops::range::RangeInclusive</code></p>
<pre><code class="language-rust">#[derive(Clone, Drop, PartialEq)]
pub struct RangeInclusive&lt;T&gt; {
    pub start: T,
    pub end: T,
}</code></pre>
<h2 id="members-4"><a class="header" href="#members-4">Members</a></h2>
<h3 id="start-1"><a class="header" href="#start-1">start</a></h3>
<p>The lower bound of the range (inclusive).</p>
<p>Fully qualified path: <code>core::ops::range::RangeInclusive::start</code></p>
<pre><code class="language-rust">pub start: T</code></pre>
<h3 id="end-1"><a class="header" href="#end-1">end</a></h3>
<p>The upper bound of the range (inclusive).</p>
<p>Fully qualified path: <code>core::ops::range::RangeInclusive::end</code></p>
<pre><code class="language-rust">pub end: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangeinclusiveiterator"><a class="header" href="#rangeinclusiveiterator">RangeInclusiveIterator</a></h1>
<p>Fully qualified path: <code>core::ops::range::RangeInclusiveIterator</code></p>
<pre><code class="language-rust">#[derive(Clone, Drop)]
pub struct RangeInclusiveIterator&lt;T&gt; {
    pub(crate) cur: T,
    pub(crate) end: T,
    pub(crate) exhausted: bool,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangeiterator"><a class="header" href="#rangeiterator">RangeIterator</a></h1>
<p>Represents an iterator located at <code>cur</code>, whose end is <code>end</code> (<code>cur &lt;= end</code>).</p>
<p>Fully qualified path: <code>core::ops::range::RangeIterator</code></p>
<pre><code class="language-rust">#[derive(Clone, Drop, PartialEq)]
pub struct RangeIterator&lt;T&gt; {
    cur: T,
    end: T,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic</a></h1>
<p>Triggers an immediate panic with the provided data and terminates execution.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic</code></p>
<pre><code class="language-rust">pub extern fn panic(data: Array&lt;felt252&gt;) -&gt; crate::never;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstate"><a class="header" href="#hashstate">HashState</a></h1>
<p>Represents the current state of a Pedersen hash computation.The state is maintained as a single <code>felt252</code> value, which is updated through the <a href="%60HashStateTrait::finalize%60"><code>HashStateTrait::finalize</code></a> method.</p>
<p>Fully qualified path: <code>core::pedersen::HashState</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct HashState {
    pub state: felt252,
}</code></pre>
<h2 id="members-5"><a class="header" href="#members-5">Members</a></h2>
<h3 id="state"><a class="header" href="#state">state</a></h3>
<p>The current hash state</p>
<p>Fully qualified path: <code>core::pedersen::HashState::state</code></p>
<pre><code class="language-rust">pub state: felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstate-1"><a class="header" href="#hashstate-1">HashState</a></h1>
<p>State for Poseidon hash.</p>
<p>Fully qualified path: <code>core::poseidon::HashState</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct HashState {
    pub s0: felt252,
    pub s1: felt252,
    pub s2: felt252,
    pub odd: bool,
}</code></pre>
<h2 id="members-6"><a class="header" href="#members-6">Members</a></h2>
<h3 id="s0"><a class="header" href="#s0">s0</a></h3>
<p>Fully qualified path: <code>core::poseidon::HashState::s0</code></p>
<pre><code class="language-rust">pub s0: felt252</code></pre>
<h3 id="s1"><a class="header" href="#s1">s1</a></h3>
<p>Fully qualified path: <code>core::poseidon::HashState::s1</code></p>
<pre><code class="language-rust">pub s1: felt252</code></pre>
<h3 id="s2"><a class="header" href="#s2">s2</a></h3>
<p>Fully qualified path: <code>core::poseidon::HashState::s2</code></p>
<pre><code class="language-rust">pub s2: felt252</code></pre>
<h3 id="odd"><a class="header" href="#odd">odd</a></h3>
<p>Fully qualified path: <code>core::poseidon::HashState::odd</code></p>
<pre><code class="language-rust">pub odd: bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error"><a class="header" href="#error">Error</a></h1>
<p>Dedicated type for representing formatting errors.</p>
<p>Fully qualified path: <code>core::fmt::Error</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct Error {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatter"><a class="header" href="#formatter">Formatter</a></h1>
<p>Configuration for formatting.</p>
<p>Fully qualified path: <code>core::fmt::Formatter</code></p>
<pre><code class="language-rust">#[derive(Default, Drop)]
pub struct Formatter {
    pub buffer: ByteArray,
}</code></pre>
<h2 id="members-7"><a class="header" href="#members-7">Members</a></h2>
<h3 id="buffer"><a class="header" href="#buffer">buffer</a></h3>
<p>The pending result of formatting.</p>
<p>Fully qualified path: <code>core::fmt::Formatter::buffer</code></p>
<pre><code class="language-rust">pub buffer: ByteArray</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddress"><a class="header" href="#ethaddress">EthAddress</a></h1>
<p>An Ethereum address, 20 bytes in length.</p>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq)]
pub struct EthAddress {
    address: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executioninfo"><a class="header" href="#executioninfo">ExecutionInfo</a></h1>
<p>The same as <code>ExecutionInfo</code>, but with the <code>TxInfo</code> field replaced with <code>v2::TxInfo</code>.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct ExecutionInfo {
    pub block_info: Box&lt;BlockInfo&gt;,
    pub tx_info: Box&lt;TxInfo&gt;,
    pub caller_address: ContractAddress,
    pub contract_address: ContractAddress,
    pub entry_point_selector: felt252,
}</code></pre>
<h2 id="members-8"><a class="header" href="#members-8">Members</a></h2>
<h3 id="block_info"><a class="header" href="#block_info">block_info</a></h3>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo::block_info</code></p>
<pre><code class="language-rust">pub block_info: Box&lt;BlockInfo&gt;</code></pre>
<h3 id="tx_info"><a class="header" href="#tx_info">tx_info</a></h3>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo::tx_info</code></p>
<pre><code class="language-rust">pub tx_info: Box&lt;TxInfo&gt;</code></pre>
<h3 id="caller_address"><a class="header" href="#caller_address">caller_address</a></h3>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo::caller_address</code></p>
<pre><code class="language-rust">pub caller_address: ContractAddress</code></pre>
<h3 id="contract_address-1"><a class="header" href="#contract_address-1">contract_address</a></h3>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo::contract_address</code></p>
<pre><code class="language-rust">pub contract_address: ContractAddress</code></pre>
<h3 id="entry_point_selector"><a class="header" href="#entry_point_selector">entry_point_selector</a></h3>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo::entry_point_selector</code></p>
<pre><code class="language-rust">pub entry_point_selector: felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resourcebounds"><a class="header" href="#resourcebounds">ResourceBounds</a></h1>
<p>V3 transactions resources used for enabling the fee market.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ResourceBounds</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct ResourceBounds {
    pub resource: felt252,
    pub max_amount: u64,
    pub max_price_per_unit: u128,
}</code></pre>
<h2 id="members-9"><a class="header" href="#members-9">Members</a></h2>
<h3 id="resource"><a class="header" href="#resource">resource</a></h3>
<p>The name of the resource.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ResourceBounds::resource</code></p>
<pre><code class="language-rust">pub resource: felt252</code></pre>
<h3 id="max_amount"><a class="header" href="#max_amount">max_amount</a></h3>
<p>The maximum amount of the resource allowed for usage during the execution.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ResourceBounds::max_amount</code></p>
<pre><code class="language-rust">pub max_amount: u64</code></pre>
<h3 id="max_price_per_unit"><a class="header" href="#max_price_per_unit">max_price_per_unit</a></h3>
<p>The maximum price the user is willing to pay for the resource unit.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ResourceBounds::max_price_per_unit</code></p>
<pre><code class="language-rust">pub max_price_per_unit: u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txinfo"><a class="header" href="#txinfo">TxInfo</a></h1>
<p>Extended information about the current transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct TxInfo {
    pub version: felt252,
    pub account_contract_address: ContractAddress,
    pub max_fee: u128,
    pub signature: Span&lt;felt252&gt;,
    pub transaction_hash: felt252,
    pub chain_id: felt252,
    pub nonce: felt252,
    pub resource_bounds: Span&lt;ResourceBounds&gt;,
    pub tip: u128,
    pub paymaster_data: Span&lt;felt252&gt;,
    pub nonce_data_availability_mode: u32,
    pub fee_data_availability_mode: u32,
    pub account_deployment_data: Span&lt;felt252&gt;,
}</code></pre>
<h2 id="members-10"><a class="header" href="#members-10">Members</a></h2>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<p>The version of the transaction. It is fixed (currently, 1) in the OS, and should be signed by the account contract. This field allows invalidating old transactions, whenever the meaning of the other transaction fields is changed (in the OS).</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::version</code></p>
<pre><code class="language-rust">pub version: felt252</code></pre>
<h3 id="account_contract_address"><a class="header" href="#account_contract_address">account_contract_address</a></h3>
<p>The account contract from which this transaction originates.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::account_contract_address</code></p>
<pre><code class="language-rust">pub account_contract_address: ContractAddress</code></pre>
<h3 id="max_fee"><a class="header" href="#max_fee">max_fee</a></h3>
<p>The <code>max_fee</code> field of the transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::max_fee</code></p>
<pre><code class="language-rust">pub max_fee: u128</code></pre>
<h3 id="signature"><a class="header" href="#signature">signature</a></h3>
<p>The signature of the transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::signature</code></p>
<pre><code class="language-rust">pub signature: Span&lt;felt252&gt;</code></pre>
<h3 id="transaction_hash"><a class="header" href="#transaction_hash">transaction_hash</a></h3>
<p>The hash of the transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::transaction_hash</code></p>
<pre><code class="language-rust">pub transaction_hash: felt252</code></pre>
<h3 id="chain_id"><a class="header" href="#chain_id">chain_id</a></h3>
<p>The identifier of the chain. This field can be used to prevent replay of testnet transactions on mainnet.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::chain_id</code></p>
<pre><code class="language-rust">pub chain_id: felt252</code></pre>
<h3 id="nonce"><a class="header" href="#nonce">nonce</a></h3>
<p>The transaction's nonce.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::nonce</code></p>
<pre><code class="language-rust">pub nonce: felt252</code></pre>
<h3 id="resource_bounds"><a class="header" href="#resource_bounds">resource_bounds</a></h3>
<p>A span of <code>ResourceBounds</code> structs used for V3 transactions.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::resource_bounds</code></p>
<pre><code class="language-rust">pub resource_bounds: Span&lt;ResourceBounds&gt;</code></pre>
<h3 id="tip"><a class="header" href="#tip">tip</a></h3>
<p>The tip of the transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::tip</code></p>
<pre><code class="language-rust">pub tip: u128</code></pre>
<h3 id="paymaster_data"><a class="header" href="#paymaster_data">paymaster_data</a></h3>
<p>If specified, the paymaster should pay for the execution of the transaction. The data includes the address of the paymaster sponsoring the transaction, followed by extra data to send to the paymaster. Used for V3 transactions.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::paymaster_data</code></p>
<pre><code class="language-rust">pub paymaster_data: Span&lt;felt252&gt;</code></pre>
<h3 id="nonce_data_availability_mode"><a class="header" href="#nonce_data_availability_mode">nonce_data_availability_mode</a></h3>
<p>The data availability mode for the nonce. Used for V3 transactions.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::nonce_data_availability_mode</code></p>
<pre><code class="language-rust">pub nonce_data_availability_mode: u32</code></pre>
<h3 id="fee_data_availability_mode"><a class="header" href="#fee_data_availability_mode">fee_data_availability_mode</a></h3>
<p>The data availability mode for the account balance from which fee will be taken. Used for V3 transactions.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::fee_data_availability_mode</code></p>
<pre><code class="language-rust">pub fee_data_availability_mode: u32</code></pre>
<h3 id="account_deployment_data"><a class="header" href="#account_deployment_data">account_deployment_data</a></h3>
<p>If nonempty, will contain the required data for deploying and initializing an account contract: its class hash, address salt and constructor calldata. Used for V3 transactions.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo::account_deployment_data</code></p>
<pre><code class="language-rust">pub account_deployment_data: Span&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockinfo"><a class="header" href="#blockinfo">BlockInfo</a></h1>
<p>Information about the current block.</p>
<p>Fully qualified path: <code>core::starknet::info::BlockInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct BlockInfo {
    pub block_number: u64,
    pub block_timestamp: u64,
    pub sequencer_address: ContractAddress,
}</code></pre>
<h2 id="members-11"><a class="header" href="#members-11">Members</a></h2>
<h3 id="block_number"><a class="header" href="#block_number">block_number</a></h3>
<p>The number, that is, the height, of this block.</p>
<p>Fully qualified path: <code>core::starknet::info::BlockInfo::block_number</code></p>
<pre><code class="language-rust">pub block_number: u64</code></pre>
<h3 id="block_timestamp"><a class="header" href="#block_timestamp">block_timestamp</a></h3>
<p>The time at which the sequencer began building the block, in seconds since the Unix epoch.</p>
<p>Fully qualified path: <code>core::starknet::info::BlockInfo::block_timestamp</code></p>
<pre><code class="language-rust">pub block_timestamp: u64</code></pre>
<h3 id="sequencer_address"><a class="header" href="#sequencer_address">sequencer_address</a></h3>
<p>The Starknet address of the sequencer that created the block.</p>
<p>Fully qualified path: <code>core::starknet::info::BlockInfo::sequencer_address</code></p>
<pre><code class="language-rust">pub sequencer_address: ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature-1"><a class="header" href="#signature-1">Signature</a></h1>
<p>Represents a Secp256{k/r}1 ECDSA signature.This struct holds the components of an ECDSA signature: <code>r</code>, <code>s</code>, and <code>y_parity</code>.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Signature</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, PartialEq, Serde, Hash)]
pub struct Signature {
    pub r: u256,
    pub s: u256,
    pub y_parity: bool,
}</code></pre>
<h2 id="members-12"><a class="header" href="#members-12">Members</a></h2>
<h3 id="r"><a class="header" href="#r">r</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Signature::r</code></p>
<pre><code class="language-rust">pub r: u256</code></pre>
<h3 id="s"><a class="header" href="#s">s</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Signature::s</code></p>
<pre><code class="language-rust">pub s: u256</code></pre>
<h3 id="y_parity"><a class="header" href="#y_parity">y_parity</a></h3>
<p>The parity of the y coordinate of the elliptic curve point whose x coordinate is <code>r</code>. <code>y_parity == true</code> means that the y coordinate is odd. Some places use non boolean <code>v</code> instead of <code>y_parity</code>. In that case, <code>signature_from_vrs</code> should be used.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Signature::y_parity</code></p>
<pre><code class="language-rust">pub y_parity: bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddress-1"><a class="header" href="#ethaddress-1">EthAddress</a></h1>
<p>An Ethereum address, 20 bytes in length.</p>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq)]
pub struct EthAddress {
    address: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call"><a class="header" href="#call">Call</a></h1>
<p>A struct representing a call to a contract.</p>
<p>Fully qualified path: <code>core::starknet::account::Call</code></p>
<pre><code class="language-rust">#[derive(Drop, Copy, Serde, Debug)]
pub struct Call {
    pub to: ContractAddress,
    pub selector: felt252,
    pub calldata: Span&lt;felt252&gt;,
}</code></pre>
<h2 id="members-13"><a class="header" href="#members-13">Members</a></h2>
<h3 id="to"><a class="header" href="#to">to</a></h3>
<p>The address of the contract to call.</p>
<p>Fully qualified path: <code>core::starknet::account::Call::to</code></p>
<pre><code class="language-rust">pub to: ContractAddress</code></pre>
<h3 id="selector"><a class="header" href="#selector">selector</a></h3>
<p>The entry point selector in the called contract.</p>
<p>Fully qualified path: <code>core::starknet::account::Call::selector</code></p>
<pre><code class="language-rust">pub selector: felt252</code></pre>
<h3 id="calldata"><a class="header" href="#calldata">calldata</a></h3>
<p>The calldata to pass to entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::Call::calldata</code></p>
<pre><code class="language-rust">pub calldata: Span&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractdispatcher"><a class="header" href="#accountcontractdispatcher">AccountContractDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}</code></pre>
<h2 id="members-14"><a class="header" href="#members-14">Members</a></h2>
<h3 id="contract_address-2"><a class="header" href="#contract_address-2">contract_address</a></h3>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcher::contract_address</code></p>
<pre><code class="language-rust">pub contract_address: starknet::ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractlibrarydispatcher"><a class="header" href="#accountcontractlibrarydispatcher">AccountContractLibraryDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractLibraryDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}</code></pre>
<h2 id="members-15"><a class="header" href="#members-15">Members</a></h2>
<h3 id="class_hash-1"><a class="header" href="#class_hash-1">class_hash</a></h3>
<p>Fully qualified path: <code>core::starknet::account::AccountContractLibraryDispatcher::class_hash</code></p>
<pre><code class="language-rust">pub class_hash: starknet::ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafelibrarydispatcher"><a class="header" href="#accountcontractsafelibrarydispatcher">AccountContractSafeLibraryDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeLibraryDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}</code></pre>
<h2 id="members-16"><a class="header" href="#members-16">Members</a></h2>
<h3 id="class_hash-2"><a class="header" href="#class_hash-2">class_hash</a></h3>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeLibraryDispatcher::class_hash</code></p>
<pre><code class="language-rust">pub class_hash: starknet::ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafedispatcher"><a class="header" href="#accountcontractsafedispatcher">AccountContractSafeDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}</code></pre>
<h2 id="members-17"><a class="header" href="#members-17">Members</a></h2>
<h3 id="contract_address-3"><a class="header" href="#contract_address-3">contract_address</a></h3>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcher::contract_address</code></p>
<pre><code class="language-rust">pub contract_address: starknet::ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointer"><a class="header" href="#storagepointer">StoragePointer</a></h1>
<p>A pointer to an address in storage, can be used to read and write values, if the generic type supports it (e.g. basic types like <code>felt252</code>).</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer</code></p>
<pre><code class="language-rust">pub struct StoragePointer&lt;T&gt; {
    pub __storage_pointer_address__: StorageBaseAddress,
    pub __storage_pointer_offset__: u8,
}</code></pre>
<h2 id="members-18"><a class="header" href="#members-18">Members</a></h2>
<h3 id="storage_pointer_address"><a class="header" href="#storage_pointer_address"><strong>storage_pointer_address</strong></a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer::__storage_pointer_address__</code></p>
<pre><code class="language-rust">pub __storage_pointer_address__: StorageBaseAddress</code></pre>
<h3 id="storage_pointer_offset"><a class="header" href="#storage_pointer_offset"><strong>storage_pointer_offset</strong></a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer::__storage_pointer_offset__</code></p>
<pre><code class="language-rust">pub __storage_pointer_offset__: u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointer0offset"><a class="header" href="#storagepointer0offset">StoragePointer0Offset</a></h1>
<p>Same as <code>StoragePointer</code>, but with <code>offset</code> 0, which allows for some optimizations.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer0Offset</code></p>
<pre><code class="language-rust">pub struct StoragePointer0Offset&lt;T&gt; {
    pub __storage_pointer_address__: StorageBaseAddress,
}</code></pre>
<h2 id="members-19"><a class="header" href="#members-19">Members</a></h2>
<h3 id="storage_pointer_address-1"><a class="header" href="#storage_pointer_address-1"><strong>storage_pointer_address</strong></a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer0Offset::__storage_pointer_address__</code></p>
<pre><code class="language-rust">pub __storage_pointer_address__: StorageBaseAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepath"><a class="header" href="#storagepath">StoragePath</a></h1>
<p>An intermediate struct to store a hash state, in order to be able to hash multiple values and get the final address. Storage path should have two interfaces, if <code>T</code> is storable then it should implement <code>StorageAsPointer</code> in order to be able to get the address of the storage path. Otherwise, if <code>T</code> is not storable then it should implement some kind of updating trait, e.g. <code>StoragePathEntry</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePath</code></p>
<pre><code class="language-rust">pub struct StoragePath&lt;T&gt; {
    __hash_state__: StoragePathHashState,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pendingstoragepath"><a class="header" href="#pendingstoragepath">PendingStoragePath</a></h1>
<p>A struct for delaying the creation of a storage path, used for lazy evaluation in storage nodes.</p>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePath</code></p>
<pre><code class="language-rust">pub struct PendingStoragePath&lt;T&gt; {
    __hash_state__: StoragePathHashState,
    __pending_key__: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable"><a class="header" href="#mutable">Mutable</a></h1>
<p>A wrapper around different storage related types, indicating that the instance is mutable, i.e. originally created from a <code>ref</code> contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::Mutable</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Mutable&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map"><a class="header" href="#map">Map</a></h1>
<p>A persistent key-value store in contract storage.This type cannot be instantiated as it is marked with <code>#[phantom]</code>. This is by design: <code>Map</code> is a compile-time type that only exists to provide type information for the compiler. It represents a mapping in storage, but the actual storage operations are handled by the <a href="./core-starknet-storage-map-StorageMapReadAccess.html"><code>StorageMapReadAccess</code></a>, <a href="./core-starknet-storage-map-StorageMapWriteAccess.html"><code>StorageMapWriteAccess</code></a>, and <a href="./core-starknet-storage-map-StoragePathEntry.html"><code>StoragePathEntry</code></a> traits.</p>
<p>Fully qualified path: <code>core::starknet::storage::map::Map</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Map&lt;K, V&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flattenedstorage"><a class="header" href="#flattenedstorage">FlattenedStorage</a></h1>
<p>A type that represents a flattened storage, i.e. a storage object which does not have any effect on the path taken into consideration when computing the address of the storage object.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::FlattenedStorage</code></p>
<pre><code class="language-rust">pub struct FlattenedStorage&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagebase"><a class="header" href="#storagebase">StorageBase</a></h1>
<p>A struct for holding an address to initialize a storage path with. The members (not direct members, but accessible using <code>deref</code>) of a contract state are either <code>StorageBase</code> or <code>FlattenedStorage</code> instances, with the generic type representing the type of the stored member.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageBase</code></p>
<pre><code class="language-rust">pub struct StorageBase&lt;T&gt; {
    pub __base_address__: felt252,
}</code></pre>
<h2 id="members-20"><a class="header" href="#members-20">Members</a></h2>
<h3 id="base_address"><a class="header" href="#base_address"><strong>base_address</strong></a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageBase::__base_address__</code></p>
<pre><code class="language-rust">pub __base_address__: felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec">Vec</a></h1>
<p>Represents a dynamic array in contract storage.This type is zero-sized and cannot be instantiated. Vectors can only be used in storage contexts and manipulated using the associated <code>VecTrait</code> and <code>MutableVecTrait</code> traits.</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::Vec</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Vec&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropwith"><a class="header" href="#dropwith">DropWith</a></h1>
<p>Wrapper type to ensure that a type <code>T</code> is dropped using a specific <code>Drop</code> impl.</p>
<p>Fully qualified path: <code>core::internal::DropWith</code></p>
<pre><code class="language-rust">pub struct DropWith&lt;T, impl DropT: Drop&lt;T&gt;&gt; {
    pub value: T,
}</code></pre>
<h2 id="members-21"><a class="header" href="#members-21">Members</a></h2>
<h3 id="value"><a class="header" href="#value">value</a></h3>
<p>Fully qualified path: <code>core::internal::DropWith::value</code></p>
<pre><code class="language-rust">pub value: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferdrop"><a class="header" href="#inferdrop">InferDrop</a></h1>
<p>Helper to have the same interface as <code>DropWith</code> while inferring the <code>Drop</code> implementation.</p>
<p>Fully qualified path: <code>core::internal::InferDrop</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct InferDrop&lt;T&gt; {
    pub value: T,
}</code></pre>
<h2 id="members-22"><a class="header" href="#members-22">Members</a></h2>
<h3 id="value-1"><a class="header" href="#value-1">value</a></h3>
<p>Fully qualified path: <code>core::internal::InferDrop::value</code></p>
<pre><code class="language-rust">pub value: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructwith"><a class="header" href="#destructwith">DestructWith</a></h1>
<p>Wrapper type to ensure that a type <code>T</code> is destructed using a specific <code>Destruct</code> impl.</p>
<p>Fully qualified path: <code>core::internal::DestructWith</code></p>
<pre><code class="language-rust">pub struct DestructWith&lt;T, impl DestructT: Destruct&lt;T&gt;&gt; {
    pub value: T,
}</code></pre>
<h2 id="members-23"><a class="header" href="#members-23">Members</a></h2>
<h3 id="value-2"><a class="header" href="#value-2">value</a></h3>
<p>Fully qualified path: <code>core::internal::DestructWith::value</code></p>
<pre><code class="language-rust">pub value: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferdestruct"><a class="header" href="#inferdestruct">InferDestruct</a></h1>
<p>Helper to have the same interface as <code>DestructWith</code> while inferring the <code>Destruct</code> implementation.</p>
<p>Fully qualified path: <code>core::internal::InferDestruct</code></p>
<pre><code class="language-rust">#[derive(Destruct)]
pub struct InferDestruct&lt;T&gt; {
    pub value: T,
}</code></pre>
<h2 id="members-24"><a class="header" href="#members-24">Members</a></h2>
<h3 id="value-3"><a class="header" href="#value-3">value</a></h3>
<p>Fully qualified path: <code>core::internal::InferDestruct::value</code></p>
<pre><code class="language-rust">pub value: T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearray"><a class="header" href="#bytearray">ByteArray</a></h1>
<p>Byte array type.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArray</code></p>
<pre><code class="language-rust">#[derive(Drop, Clone, PartialEq, Serde, Default)]
pub struct ByteArray {
    pub(crate) data: Array&lt;bytes31&gt;,
    pub(crate) pending_word: felt252,
    pub(crate) pending_word_len: usize,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearrayiter"><a class="header" href="#bytearrayiter">ByteArrayIter</a></h1>
<p>An iterator struct over a ByteArray.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayIter</code></p>
<pre><code class="language-rust">#[derive(Drop, Clone)]
pub struct ByteArrayIter {
    ba: ByteArray,
    current_index: crate::ops::RangeIterator&lt;usize&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-7"><a class="header" href="#enums-7">Enums</a></h1>
<ul>
<li>
<p><a href="./core-bool.html">bool</a></p>
</li>
<li>
<p><a href="./core-never.html">never</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResult.html">AddInputResult</a></p>
</li>
<li>
<p><a href="./core-nullable-FromNullableResult.html">FromNullableResult</a></p>
</li>
<li>
<p><a href="./core-result-Result.html">Result</a></p>
</li>
<li>
<p><a href="./core-option-Option.html">Option</a></p>
</li>
<li>
<p><a href="./core-panics-PanicResult.html">PanicResult</a></p>
</li>
<li>
<p><a href="./core-internal-OptionRev.html">OptionRev</a></p>
</li>
<li>
<p><a href="./core-internal-LoopResult.html">LoopResult</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">bool</a></h1>
<p><code>bool</code> enum representing either <code>false</code> or <code>true</code>.</p>
<p>Fully qualified path: <code>core::bool</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Default)]
pub enum bool {
    #[default]
    False,
    True,
}</code></pre>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<h3 id="false"><a class="header" href="#false">False</a></h3>
<p>Fully qualified path: <code>core::bool::False</code></p>
<pre><code class="language-rust">#[default]
False</code></pre>
<h3 id="true"><a class="header" href="#true">True</a></h3>
<p>Fully qualified path: <code>core::bool::True</code></p>
<pre><code class="language-rust">True</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never"><a class="header" href="#never">never</a></h1>
<p>Fully qualified path: <code>core::never</code></p>
<pre><code class="language-rust">pub enum never {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addinputresult"><a class="header" href="#addinputresult">AddInputResult</a></h1>
<p>The result of filling an input in the circuit instance's data.This enum represents the state of input filling process, indicating whether all inputs have been provided or more are needed.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult</code></p>
<pre><code class="language-rust">pub enum AddInputResult&lt;C&gt; {
    Done: CircuitData&lt;C&gt;,
    More: CircuitInputAccumulator&lt;C&gt;,
}</code></pre>
<h2 id="variants-1"><a class="header" href="#variants-1">Variants</a></h2>
<h3 id="done"><a class="header" href="#done">Done</a></h3>
<p>All inputs have been filled and the circuit data is complete.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult::Done</code></p>
<pre><code class="language-rust">Done : CircuitData &lt; C &gt;</code></pre>
<h3 id="more"><a class="header" href="#more">More</a></h3>
<p>More inputs are needed to complete the circuit instance's data.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult::More</code></p>
<pre><code class="language-rust">More : CircuitInputAccumulator &lt; C &gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromnullableresult"><a class="header" href="#fromnullableresult">FromNullableResult</a></h1>
<p>Represents the result of matching a <code>Nullable</code> value.Used to safely handle both null and non-null cases when using <code>match_nullable</code> on a <code>Nullable</code>.</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult</code></p>
<pre><code class="language-rust">pub enum FromNullableResult&lt;T&gt; {
    Null,
    NotNull: Box&lt;T&gt;,
}</code></pre>
<h2 id="variants-2"><a class="header" href="#variants-2">Variants</a></h2>
<h3 id="null"><a class="header" href="#null">Null</a></h3>
<p>Represents a null value</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult::Null</code></p>
<pre><code class="language-rust">Null</code></pre>
<h3 id="notnull"><a class="header" href="#notnull">NotNull</a></h3>
<p>The boxed value when not null</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult::NotNull</code></p>
<pre><code class="language-rust">NotNull : Box &lt; T &gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1">Result</a></h1>
<p>The type used for returning and propagating errors. It is an enum with the variants <code>Ok: T</code>, representing success and containing a value, and <code>Err: E</code>, representing error and containing an error value.</p>
<p>Fully qualified path: <code>core::result::Result</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, Serde, PartialEq)]
pub enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}</code></pre>
<h2 id="variants-3"><a class="header" href="#variants-3">Variants</a></h2>
<h3 id="ok"><a class="header" href="#ok">Ok</a></h3>
<p>Fully qualified path: <code>core::result::Result::Ok</code></p>
<pre><code class="language-rust">Ok : T</code></pre>
<h3 id="err"><a class="header" href="#err">Err</a></h3>
<p>Fully qualified path: <code>core::result::Result::Err</code></p>
<pre><code class="language-rust">Err : E</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-1"><a class="header" href="#option-1">Option</a></h1>
<p>The <code>Option&lt;T&gt;</code> enum representing either <code>Some(value)</code> or <code>None</code>.</p>
<p>Fully qualified path: <code>core::option::Option</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, Serde, PartialEq)]
pub enum Option&lt;T&gt; {
    Some: T,
    None,
}</code></pre>
<h2 id="variants-4"><a class="header" href="#variants-4">Variants</a></h2>
<h3 id="some"><a class="header" href="#some">Some</a></h3>
<p>Fully qualified path: <code>core::option::Option::Some</code></p>
<pre><code class="language-rust">Some : T</code></pre>
<h3 id="none"><a class="header" href="#none">None</a></h3>
<p>Fully qualified path: <code>core::option::Option::None</code></p>
<pre><code class="language-rust">None</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicresult"><a class="header" href="#panicresult">PanicResult</a></h1>
<p>Result type for operations that can trigger a panic.</p>
<p>Fully qualified path: <code>core::panics::PanicResult</code></p>
<pre><code class="language-rust">pub enum PanicResult&lt;T&gt; {
    Ok: T,
    Err: (Panic, Array&lt;felt252&gt;),
}</code></pre>
<h2 id="variants-5"><a class="header" href="#variants-5">Variants</a></h2>
<h3 id="ok-1"><a class="header" href="#ok-1">Ok</a></h3>
<p>Fully qualified path: <code>core::panics::PanicResult::Ok</code></p>
<pre><code class="language-rust">Ok : T</code></pre>
<h3 id="err-1"><a class="header" href="#err-1">Err</a></h3>
<p>Fully qualified path: <code>core::panics::PanicResult::Err</code></p>
<pre><code class="language-rust">Err : ( Panic , Array &lt; felt252 &gt; )</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optionrev"><a class="header" href="#optionrev">OptionRev</a></h1>
<p>Same as <code>Option</code>, except that the order of the variants is reversed. This is used as the return type of some libfuncs for efficiency reasons.</p>
<p>Fully qualified path: <code>core::internal::OptionRev</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, PartialEq)]
pub enum OptionRev&lt;T&gt; {
    None,
    Some: T,
}</code></pre>
<h2 id="variants-6"><a class="header" href="#variants-6">Variants</a></h2>
<h3 id="none-1"><a class="header" href="#none-1">None</a></h3>
<p>Fully qualified path: <code>core::internal::OptionRev::None</code></p>
<pre><code class="language-rust">None</code></pre>
<h3 id="some-1"><a class="header" href="#some-1">Some</a></h3>
<p>Fully qualified path: <code>core::internal::OptionRev::Some</code></p>
<pre><code class="language-rust">Some : T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loopresult"><a class="header" href="#loopresult">LoopResult</a></h1>
<p>The return type for loops with an early return.</p>
<p>Fully qualified path: <code>core::internal::LoopResult</code></p>
<pre><code class="language-rust">pub enum LoopResult&lt;N, E&gt; {
    Normal: N,
    EarlyReturn: E,
}</code></pre>
<h2 id="variants-7"><a class="header" href="#variants-7">Variants</a></h2>
<h3 id="normal"><a class="header" href="#normal">Normal</a></h3>
<p>Fully qualified path: <code>core::internal::LoopResult::Normal</code></p>
<pre><code class="language-rust">Normal : N</code></pre>
<h3 id="earlyreturn"><a class="header" href="#earlyreturn">EarlyReturn</a></h3>
<p>Fully qualified path: <code>core::internal::LoopResult::EarlyReturn</code></p>
<pre><code class="language-rust">EarlyReturn : E</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aliases-4"><a class="header" href="#type-aliases-4">Type aliases</a></h1>
<ul>
<li>
<p><a href="./core-usize.html">usize</a></p>
</li>
<li>
<p><a href="./core-circuit-u96.html">u96</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstZero.html">ConstZero</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstOne.html">ConstOne</a></p>
</li>
<li>
<p><a href="./core-ec-NonZeroEcPoint.html">NonZeroEcPoint</a></p>
</li>
<li>
<p><a href="./core-starknet-SyscallResult.html">SyscallResult</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usize"><a class="header" href="#usize">usize</a></h1>
<p><code>usize</code> is an alias for <code>u32</code> type.</p>
<p>Fully qualified path: <code>core::usize</code></p>
<pre><code class="language-rust">pub type usize = u32;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u96"><a class="header" href="#u96">u96</a></h1>
<p>A 96-bit unsigned integer type used as the basic building block for multi-limb arithmetic.</p>
<p>Fully qualified path: <code>core::circuit::u96</code></p>
<pre><code class="language-rust">pub type u96 = crate::internal::bounded_int::BoundedInt&lt;0, 79228162514264337593543950335&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constzero"><a class="header" href="#constzero">ConstZero</a></h1>
<p>Expose the const required by the libfunc to allow the compiler const reusage.</p>
<p>Fully qualified path: <code>core::circuit::ConstZero</code></p>
<pre><code class="language-rust">pub type ConstZero = crate::internal::bounded_int::UnitInt&lt;0&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constone"><a class="header" href="#constone">ConstOne</a></h1>
<p>Fully qualified path: <code>core::circuit::ConstOne</code></p>
<pre><code class="language-rust">pub type ConstOne = crate::internal::bounded_int::UnitInt&lt;1&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonzeroecpoint"><a class="header" href="#nonzeroecpoint">NonZeroEcPoint</a></h1>
<p>A non-zero point on the STARK curve (cannot be the point at infinity).</p>
<p>Fully qualified path: <code>core::ec::NonZeroEcPoint</code></p>
<pre><code class="language-rust">pub type NonZeroEcPoint = NonZero&lt;EcPoint&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscallresult"><a class="header" href="#syscallresult">SyscallResult</a></h1>
<p>The <code>Result</code> type for a syscall.</p>
<p>Fully qualified path: <code>core::starknet::SyscallResult</code></p>
<pre><code class="language-rust">pub type SyscallResult&lt;T&gt; = Result&lt;T, Array&lt;felt252&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-42"><a class="header" href="#traits-42">Traits</a></h1>
<ul>
<li>
<p><a href="./core-traits-Copy.html">Copy</a></p>
</li>
<li>
<p><a href="./core-traits-Drop.html">Drop</a></p>
</li>
<li>
<p><a href="./core-traits-Add.html">Add</a></p>
</li>
<li>
<p><a href="./core-traits-AddEq.html">AddEq</a></p>
</li>
<li>
<p><a href="./core-traits-Sub.html">Sub</a></p>
</li>
<li>
<p><a href="./core-traits-SubEq.html">SubEq</a></p>
</li>
<li>
<p><a href="./core-traits-Mul.html">Mul</a></p>
</li>
<li>
<p><a href="./core-traits-MulEq.html">MulEq</a></p>
</li>
<li>
<p><a href="./core-traits-Div.html">Div</a></p>
</li>
<li>
<p><a href="./core-traits-DivEq.html">DivEq</a></p>
</li>
<li>
<p><a href="./core-traits-Rem.html">Rem</a></p>
</li>
<li>
<p><a href="./core-traits-RemEq.html">RemEq</a></p>
</li>
<li>
<p><a href="./core-traits-DivRem.html">DivRem</a></p>
</li>
<li>
<p><a href="./core-traits-PartialEq.html">PartialEq</a></p>
</li>
<li>
<p><a href="./core-traits-BitAnd.html">BitAnd</a></p>
</li>
<li>
<p><a href="./core-traits-BitOr.html">BitOr</a></p>
</li>
<li>
<p><a href="./core-traits-BitXor.html">BitXor</a></p>
</li>
<li>
<p><a href="./core-traits-BitNot.html">BitNot</a></p>
</li>
<li>
<p><a href="./core-traits-PartialOrd.html">PartialOrd</a></p>
</li>
<li>
<p><a href="./core-traits-Into.html">Into</a></p>
</li>
<li>
<p><a href="./core-traits-TryInto.html">TryInto</a></p>
</li>
<li>
<p><a href="./core-traits-Neg.html">Neg</a></p>
</li>
<li>
<p><a href="./core-traits-Not.html">Not</a></p>
</li>
<li>
<p><a href="./core-traits-IndexView.html">traits::IndexView</a></p>
</li>
<li>
<p><a href="./core-traits-Index.html">traits::Index</a></p>
</li>
<li>
<p><a href="./core-traits-Destruct.html">Destruct</a></p>
</li>
<li>
<p><a href="./core-traits-PanicDestruct.html">PanicDestruct</a></p>
</li>
<li>
<p><a href="./core-traits-Default.html">Default</a></p>
</li>
<li>
<p><a href="./core-traits-Felt252DictValue.html">Felt252DictValue</a></p>
</li>
<li>
<p><a href="./core-boolean-BoolTrait.html">BoolTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementTrait.html">CircuitElementTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitDefinition.html">CircuitDefinition</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitOutputsTrait.html">CircuitOutputsTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInputs.html">CircuitInputs</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResultTrait.html">AddInputResultTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-EvalCircuitTrait.html">EvalCircuitTrait</a></p>
</li>
<li>
<p><a href="./core-box-BoxTrait.html">BoxTrait</a></p>
</li>
<li>
<p><a href="./core-nullable-NullableTrait.html">NullableTrait</a></p>
</li>
<li>
<p><a href="./core-array-ToSpanTrait.html">ToSpanTrait</a></p>
</li>
<li>
<p><a href="./core-array-ArrayTrait.html">ArrayTrait</a></p>
</li>
<li>
<p><a href="./core-array-SpanTrait.html">SpanTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictTrait.html">Felt252DictTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntryTrait.html">Felt252DictEntryTrait</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252DictTrait.html">SquashedFelt252DictTrait</a></p>
</li>
<li>
<p><a href="./core-result-ResultTrait.html">ResultTrait</a></p>
</li>
<li>
<p><a href="./core-option-OptionTrait.html">OptionTrait</a></p>
</li>
<li>
<p><a href="./core-clone-Clone.html">Clone</a></p>
</li>
<li>
<p><a href="./core-ec-EcStateTrait.html">EcStateTrait</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointTrait.html">EcPointTrait</a></p>
</li>
<li>
<p><a href="./core-integer-NumericLiteral.html">NumericLiteral</a></p>
</li>
<li>
<p><a href="./core-integer-BoundedInt.html">BoundedInt</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero-Zero.html">num::traits::zero::Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">num::traits::one::One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">num::traits::bit_size::BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-bounded-Bounded.html">Bounded</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">num::traits::ops::checked::CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">num::traits::ops::checked::CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">num::traits::ops::checked::CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">num::traits::ops::overflowing::OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">num::traits::ops::overflowing::OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">num::traits::ops::overflowing::OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">num::traits::ops::pow::Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">num::traits::ops::saturating::SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">num::traits::ops::saturating::SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">num::traits::ops::saturating::SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt-Sqrt.html">Sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul-WideMul.html">WideMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare-WideSquare.html">WideSquare</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">num::traits::ops::wrapping::WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">num::traits::ops::wrapping::WrappingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">num::traits::ops::wrapping::WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero-Zero.html">num::traits::zero::Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">num::traits::one::One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">num::traits::bit_size::BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">num::traits::ops::checked::CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">num::traits::ops::checked::CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">num::traits::ops::checked::CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">num::traits::ops::overflowing::OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">num::traits::ops::overflowing::OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">num::traits::ops::overflowing::OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">num::traits::ops::pow::Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">num::traits::ops::saturating::SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">num::traits::ops::saturating::SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">num::traits::ops::saturating::SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">num::traits::ops::wrapping::WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">num::traits::ops::wrapping::WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">num::traits::ops::wrapping::WrappingMul</a></p>
</li>
<li>
<p><a href="./core-ops-arith-AddAssign.html">AddAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-DivAssign.html">DivAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-MulAssign.html">MulAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-RemAssign.html">RemAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-SubAssign.html">SubAssign</a></p>
</li>
<li>
<p><a href="./core-ops-deref-Deref.html">Deref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-DerefMut.html">DerefMut</a></p>
</li>
<li>
<p><a href="./core-ops-function-Fn.html">Fn</a></p>
</li>
<li>
<p><a href="./core-ops-function-FnOnce.html">FnOnce</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">ops::index::Index</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">ops::index::IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeInclusiveTrait.html">RangeInclusiveTrait</a></p>
</li>
<li>
<p><a href="./core-ops-range-RangeTrait.html">RangeTrait</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">ops::index::IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">ops::index::Index</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateTrait.html">HashStateTrait</a></p>
</li>
<li>
<p><a href="./core-hash-Hash.html">Hash</a></p>
</li>
<li>
<p><a href="./core-hash-LegacyHash.html">LegacyHash</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateExTrait.html">HashStateExTrait</a></p>
</li>
<li>
<p><a href="./core-pedersen-PedersenTrait.html">PedersenTrait</a></p>
</li>
<li>
<p><a href="./core-serde-Serde.html">Serde</a></p>
</li>
<li>
<p><a href="./core-poseidon-PoseidonTrait.html">PoseidonTrait</a></p>
</li>
<li>
<p><a href="./core-fmt-Display.html">Display</a></p>
</li>
<li>
<p><a href="./core-fmt-Debug.html">Debug</a></p>
</li>
<li>
<p><a href="./core-fmt-LowerHex.html">LowerHex</a></p>
</li>
<li>
<p><a href="./core-starknet-SyscallResultTrait.html">SyscallResultTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">starknet::storage_access::Store</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">starknet::event::Event</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">starknet::account::AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">starknet::storage_access::Store</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorePacking.html">StorePacking</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256Trait.html">Secp256Trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256PointTrait.html">Secp256PointTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">starknet::event::Event</a></p>
</li>
<li>
<p><a href="./core-starknet-event-EventEmitter.html">EventEmitter</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">starknet::account::AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcherTrait.html">AccountContractDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcherTrait.html">AccountContractSafeDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPointer.html">StorageAsPointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerReadAccess.html">StoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerWriteAccess.html">StoragePointerWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPath.html">StorageAsPath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePathTrait.html">PendingStoragePathTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-IntoIterRange.html">IntoIterRange</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-ValidStorageTypeTrait.html">ValidStorageTypeTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapReadAccess.html">StorageMapReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapWriteAccess.html">StorageMapWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StoragePathEntry.html">StoragePathEntry</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTrait.html">StorageTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTraitMut.html">StorageTraitMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNode.html">StorageNode</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNodeMut.html">StorageNodeMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointers.html">SubPointers</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersForward.html">SubPointersForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMut.html">SubPointersMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMutForward.html">SubPointersMutForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-MutableVecTrait.html">MutableVecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-VecTrait.html">VecTrait</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31Trait.html">Bytes31Trait</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayTrait.html">ByteArrayTrait</a></p>
</li>
<li>
<p><a href="./core-string-StringLiteral.html">StringLiteral</a></p>
</li>
<li>
<p><a href="./core-iter-adapters-peekable-PeekableTrait.html">PeekableTrait</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-Extend.html">Extend</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-FromIterator.html">FromIterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-collect-IntoIterator.html">IntoIterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-iterator-Iterator.html">Iterator</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TypeEqual.html">TypeEqual</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-AppendFormattedToByteArray.html">AppendFormattedToByteArray</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-FormatAsByteArray.html">FormatAsByteArray</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy"><a class="header" href="#copy">Copy</a></h1>
<p>A trait for copying values.By default, variables in Cairo have 'move semantics', meaning they are moved when used. However, types implementing <code>Copy</code> have 'copy semantics', allowing the value to be duplicated instead of moved.  # DerivingThis trait can be automatically derived using <code>#[derive(Copy)]</code>. Most basic types implement <code>Copy</code> by default.  # ExamplesWithout <code>Copy</code> (move semantics):</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop)]
</span>struct Point {
    x: u128,
    y: u128,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1); // error: Variable was previously moved.
}

fn foo(p: Point) {}
</code></pre>
<p>With <code>Copy</code> (copy semantics):</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop)]
</span>struct Point {
    x: u128,
    y: u128,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1); // works: `p1` is copied when passed to `foo`
}

fn foo(p: Point) {}
</code></pre>
<p>Fully qualified path: <code>core::traits::Copy</code></p>
<pre><code class="language-rust">pub trait Copy&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p>A trait for types that can be safely dropped.Types implementing <code>Drop</code> can be automatically discarded when they go out of scope. The drop operation is a no-op - it simply indicates to the compiler that this type can be safely discarded.  # DerivingThis trait can be automatically derived using <code>#[derive(Drop)]</code>. All basic types implement <code>Drop</code> by default, except for <code>Felt252Dict</code>.  # ExamplesWithout <code>Drop</code>:</p>
<pre><code class="language-cairo">struct Point {
    x: u128,
    y: u128,
}

fn foo(p: Point) {} // Error: `p` cannot be dropped
</code></pre>
<p>With <code>Drop</code>:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop)]
</span>struct Point {
    x: u128,
    y: u128,
}

fn foo(p: Point) {} // OK: `p` is dropped at the end of the function
</code></pre>
<p>Fully qualified path: <code>core::traits::Drop</code></p>
<pre><code class="language-rust">pub trait Drop&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add"><a class="header" href="#add">Add</a></h1>
<p>The addition operator <code>+</code>.  # Examples<code>Add</code>able types:</p>
<pre><code class="language-cairo">assert!(1_u8 + 2_u8 == 3_u8);
</code></pre>
<p>Implementing <code>Add</code> for a type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Point {
    x: u32,
    y: u32,
}

impl PointAdd of Add&lt;Point&gt; {
    fn add(lhs: Point, rhs: Point) -&gt; Point {
        Point {
            x: lhs.x + rhs.x,
            y: lhs.y + rhs.y,
        }
    }
}

let p1 = Point { x: 1, y: 0 };
let p2 = Point { x: 2, y: 3 };
let p3 = p1 + p2;
assert!(p3 == Point { x: 3, y: 3 });
</code></pre>
<p>Fully qualified path: <code>core::traits::Add</code></p>
<pre><code class="language-rust">pub trait Add&lt;T&gt;</code></pre>
<h2 id="trait-functions"><a class="header" href="#trait-functions">Trait functions</a></h2>
<h3 id="add-1"><a class="header" href="#add-1">add</a></h3>
<p>Performs the <code>+</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(12 + 1 == 13);
</code></pre>
<p>Fully qualified path: <code>core::traits::Add::add</code></p>
<pre><code class="language-rust">fn add(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addeq"><a class="header" href="#addeq">AddEq</a></h1>
<p>Fully qualified path: <code>core::traits::AddEq</code></p>
<pre><code class="language-rust">pub trait AddEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-1"><a class="header" href="#trait-functions-1">Trait functions</a></h2>
<h3 id="add_eq"><a class="header" href="#add_eq">add_eq</a></h3>
<p>Fully qualified path: <code>core::traits::AddEq::add_eq</code></p>
<pre><code class="language-rust">fn add_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub"><a class="header" href="#sub">Sub</a></h1>
<p>The subtraction operator <code>-</code>.  # Examples<code>Sub</code>tractable types:</p>
<pre><code class="language-cairo">assert!(3_u8 - 2_u8 == 1_u8);
</code></pre>
<p>Implementing <code>Sub</code> for a type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Point {
    x: u32,
    y: u32,
}

impl PointSub of Sub&lt;Point&gt; {
    fn sub(lhs: Point, rhs: Point) -&gt; Point {
        Point {
            x: lhs.x - rhs.x,
            y: lhs.y - rhs.y,
        }
    }
}

let p1 = Point { x: 2, y: 3 };
let p2 = Point { x: 1, y: 0 };
let p3 = p1 - p2;
assert!(p3 == Point { x: 1, y: 3 });
</code></pre>
<p>Fully qualified path: <code>core::traits::Sub</code></p>
<pre><code class="language-rust">pub trait Sub&lt;T&gt;</code></pre>
<h2 id="trait-functions-2"><a class="header" href="#trait-functions-2">Trait functions</a></h2>
<h3 id="sub-1"><a class="header" href="#sub-1">sub</a></h3>
<p>Performs the <code>-</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(12 - 1 == 11);
</code></pre>
<p>Fully qualified path: <code>core::traits::Sub::sub</code></p>
<pre><code class="language-rust">fn sub(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subeq"><a class="header" href="#subeq">SubEq</a></h1>
<p>Fully qualified path: <code>core::traits::SubEq</code></p>
<pre><code class="language-rust">pub trait SubEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-3"><a class="header" href="#trait-functions-3">Trait functions</a></h2>
<h3 id="sub_eq"><a class="header" href="#sub_eq">sub_eq</a></h3>
<p>Fully qualified path: <code>core::traits::SubEq::sub_eq</code></p>
<pre><code class="language-rust">fn sub_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mul"><a class="header" href="#mul">Mul</a></h1>
<p>The multiplication operator <code>*</code>.  # Examples<code>Mul</code>tipliable types:</p>
<pre><code class="language-cairo">assert!(3_u8 * 2_u8 == 6_u8);
</code></pre>
<p>Implementing <code>Mul</code> for a type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Point {
    x: u32,
    y: u32,
}

impl PointMul of Mul&lt;Point&gt; {
    fn mul(lhs: Point, rhs: Point) -&gt; Point {
        Point {
            x: lhs.x * rhs.x,
            y: lhs.y * rhs.y,
        }
    }
}

let p1 = Point { x: 2, y: 3 };
let p2 = Point { x: 1, y: 0 };
let p3 = p1 * p2;
assert!(p3 == Point { x: 2, y: 0 });
</code></pre>
<p>Fully qualified path: <code>core::traits::Mul</code></p>
<pre><code class="language-rust">pub trait Mul&lt;T&gt;</code></pre>
<h2 id="trait-functions-4"><a class="header" href="#trait-functions-4">Trait functions</a></h2>
<h3 id="mul-1"><a class="header" href="#mul-1">mul</a></h3>
<p>Performs the <code>*</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(12 * 2 == 24);
</code></pre>
<p>Fully qualified path: <code>core::traits::Mul::mul</code></p>
<pre><code class="language-rust">fn mul(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="muleq"><a class="header" href="#muleq">MulEq</a></h1>
<p>Fully qualified path: <code>core::traits::MulEq</code></p>
<pre><code class="language-rust">pub trait MulEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-5"><a class="header" href="#trait-functions-5">Trait functions</a></h2>
<h3 id="mul_eq"><a class="header" href="#mul_eq">mul_eq</a></h3>
<p>Fully qualified path: <code>core::traits::MulEq::mul_eq</code></p>
<pre><code class="language-rust">fn mul_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="div"><a class="header" href="#div">Div</a></h1>
<p>The division operator <code>/</code>.Types implementing this trait support the division operation via the <code>/</code> operator.  # Examples<code>Div</code>isible types:</p>
<pre><code class="language-cairo">assert!(4_u8 / 2_u8 == 2_u8);
</code></pre>
<p>Implementing <code>Div</code> for a type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Point {
    x: u32,
    y: u32,
}

impl PointDiv of Div&lt;Point&gt; {
    fn div(lhs: Point, rhs: Point) -&gt; Point {
        Point {
            x: lhs.x / rhs.x,
            y: lhs.y / rhs.y,
        }
    }
}

let p1 = Point { x: 2, y: 4 };
let p2 = Point { x: 2, y: 2 };
let p3 = p1 / p2;
assert!(p3 == Point { x: 1, y: 2 });
</code></pre>
<p>Fully qualified path: <code>core::traits::Div</code></p>
<pre><code class="language-rust">pub trait Div&lt;T&gt;</code></pre>
<h2 id="trait-functions-6"><a class="header" href="#trait-functions-6">Trait functions</a></h2>
<h3 id="div-1"><a class="header" href="#div-1">div</a></h3>
<p>Performs the <code>/</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(12 / 2 == 6);
</code></pre>
<p>Fully qualified path: <code>core::traits::Div::div</code></p>
<pre><code class="language-rust">fn div(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diveq"><a class="header" href="#diveq">DivEq</a></h1>
<p>Fully qualified path: <code>core::traits::DivEq</code></p>
<pre><code class="language-rust">pub trait DivEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-7"><a class="header" href="#trait-functions-7">Trait functions</a></h2>
<h3 id="div_eq"><a class="header" href="#div_eq">div_eq</a></h3>
<p>Fully qualified path: <code>core::traits::DivEq::div_eq</code></p>
<pre><code class="language-rust">fn div_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rem"><a class="header" href="#rem">Rem</a></h1>
<p>The remainder operator <code>%</code>.Types implementing this trait support the remainder operation via the <code>%</code> operator.  # Examples</p>
<pre><code class="language-cairo">assert!(3_u8 % 2_u8 == 1_u8);
</code></pre>
<p>Fully qualified path: <code>core::traits::Rem</code></p>
<pre><code class="language-rust">pub trait Rem&lt;T&gt;</code></pre>
<h2 id="trait-functions-8"><a class="header" href="#trait-functions-8">Trait functions</a></h2>
<h3 id="rem-1"><a class="header" href="#rem-1">rem</a></h3>
<p>Performs the <code>%</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(12_u8 % 10_u8 == 2_u8);
</code></pre>
<p>Fully qualified path: <code>core::traits::Rem::rem</code></p>
<pre><code class="language-rust">fn rem(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remeq"><a class="header" href="#remeq">RemEq</a></h1>
<p>Fully qualified path: <code>core::traits::RemEq</code></p>
<pre><code class="language-rust">pub trait RemEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-9"><a class="header" href="#trait-functions-9">Trait functions</a></h2>
<h3 id="rem_eq"><a class="header" href="#rem_eq">rem_eq</a></h3>
<p>Fully qualified path: <code>core::traits::RemEq::rem_eq</code></p>
<pre><code class="language-rust">fn rem_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divrem"><a class="header" href="#divrem">DivRem</a></h1>
<p>Performs truncated division and remainder.This trait provides a way to efficiently compute both the quotient and remainder in a single operation. The division truncates towards zero, matching the behavior of the <code>/</code> and <code>%</code> operators.  # Examples</p>
<pre><code class="language-cairo">assert!(DivRem::div_rem(7_u32, 3) == (2, 1));
</code></pre>
<p>Fully qualified path: <code>core::traits::DivRem</code></p>
<pre><code class="language-rust">pub trait DivRem&lt;T&gt;</code></pre>
<h2 id="trait-functions-10"><a class="header" href="#trait-functions-10">Trait functions</a></h2>
<h3 id="div_rem"><a class="header" href="#div_rem">div_rem</a></h3>
<p>Performs the <code>/</code> and the <code>%</code> operations, returning both the quotient and remainder.  # Examples</p>
<pre><code class="language-cairo">assert!(DivRem::div_rem(12_u32, 10) == (1, 2));
</code></pre>
<p>Fully qualified path: <code>core::traits::DivRem::div_rem</code></p>
<pre><code class="language-rust">fn div_rem(lhs: T, rhs: NonZero&lt;T&gt;) -&gt; (T, T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partialeq"><a class="header" href="#partialeq">PartialEq</a></h1>
<p>Trait for comparisons using the equality operator.Implementing this trait for types provides the <code>==</code> and <code>!=</code> operators for those types.  # DerivableThis trait can be used with <code>#[derive]</code>. When <code>derive</code>d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When <code>derive</code>d on enums, two instances are equal if they are the same variant and all fields are equal.  # Implementing <code>PartialEq</code>An example in which two points are equal if their x and y coordinates are equal.</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop)]
</span>struct Point {
    x: u32,
    y: u32
}

impl PointEq of PartialEq&lt;Point&gt; {
    fn eq(lhs: @Point, rhs: @Point) -&gt; bool {
        lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y
    }
}

let p1 = Point { x: 1, y: 2 };
let p2 = Point { x: 1, y: 2 };
assert!(p1 == p2);
assert!(!(p1 != p2));
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialEq</code></p>
<pre><code class="language-rust">pub trait PartialEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-11"><a class="header" href="#trait-functions-11">Trait functions</a></h2>
<h3 id="eq"><a class="header" href="#eq">eq</a></h3>
<p>Returns whether <code>lhs</code> and <code>rhs</code> equal, and is used by <code>==</code>.  # Examples</p>
<pre><code class="language-cairo">assert!(1 == 1);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialEq::eq</code></p>
<pre><code class="language-rust">fn eq(lhs: @T, rhs: @T) -&gt; bool</code></pre>
<h3 id="ne"><a class="header" href="#ne">ne</a></h3>
<p>Returns whether <code>lhs</code> and <code>rhs</code> are not equal, and is used by <code>!=</code>.  # Examples</p>
<pre><code class="language-cairo">assert!(0 != 1);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialEq::ne</code></p>
<pre><code class="language-rust">fn ne(lhs: @T, rhs: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitand"><a class="header" href="#bitand">BitAnd</a></h1>
<p>The bitwise AND operator <code>&amp;</code>.  # ExamplesAn implementation of <code>BitAnd</code> for a wrapper around <code>bool</code>.</p>
<pre><code class="language-cairo">use core::traits::BitAnd;

<span class="boring">[derive(Drop, PartialEq)]
</span>struct Scalar {
    inner: bool,
}

impl BitAndScalar of BitAnd&lt;Scalar&gt; {
    fn bitand(lhs: Scalar, rhs: Scalar) -&gt; Scalar {
       Scalar { inner: lhs.inner &amp; rhs.inner }
    }
}

assert!(Scalar { inner: true } &amp; Scalar { inner: true } == Scalar { inner: true });
assert!(Scalar { inner: true } &amp; Scalar { inner: false } == Scalar { inner: false });
assert!(Scalar { inner: false } &amp; Scalar { inner: true } == Scalar { inner: false });
assert!(Scalar { inner: false } &amp; Scalar { inner: false } == Scalar { inner: false });
</code></pre>
<p>Fully qualified path: <code>core::traits::BitAnd</code></p>
<pre><code class="language-rust">pub trait BitAnd&lt;T&gt;</code></pre>
<h2 id="trait-functions-12"><a class="header" href="#trait-functions-12">Trait functions</a></h2>
<h3 id="bitand-1"><a class="header" href="#bitand-1">bitand</a></h3>
<p>Performs the <code>&amp;</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(true &amp; false, false);
assert_eq!(5_u8 &amp; 1_u8, 1);
assert_eq!(true &amp; true, true);
assert_eq!(5_u8 &amp; 2_u8, 0);
</code></pre>
<p>Fully qualified path: <code>core::traits::BitAnd::bitand</code></p>
<pre><code class="language-rust">fn bitand(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitor"><a class="header" href="#bitor">BitOr</a></h1>
<p>The bitwise OR operator <code>|</code>.  # ExamplesAn implementation of <code>BitOr</code> for a wrapper around <code>bool</code>.</p>
<pre><code class="language-cairo">use core::traits::BitOr;

<span class="boring">[derive(Drop, PartialEq)]
</span>struct Scalar {
    inner: bool,
}

impl BitOrScalar of BitOr&lt;Scalar&gt; {
    fn bitor(lhs: Scalar, rhs: Scalar) -&gt; Scalar {
        Scalar { inner: lhs.inner | rhs.inner }
    }
}

assert!(Scalar { inner: true } | Scalar { inner: true } == Scalar { inner: true });
assert!(Scalar { inner: true } | Scalar { inner: false } == Scalar { inner: true });
assert!(Scalar { inner: false } | Scalar { inner: true } == Scalar { inner: true });
assert!(Scalar { inner: false } | Scalar { inner: false } == Scalar { inner: false });
</code></pre>
<p>Fully qualified path: <code>core::traits::BitOr</code></p>
<pre><code class="language-rust">pub trait BitOr&lt;T&gt;</code></pre>
<h2 id="trait-functions-13"><a class="header" href="#trait-functions-13">Trait functions</a></h2>
<h3 id="bitor-1"><a class="header" href="#bitor-1">bitor</a></h3>
<p>Performs the <code>|</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(1_u8 | 2_u8 == 3);
</code></pre>
<p>Fully qualified path: <code>core::traits::BitOr::bitor</code></p>
<pre><code class="language-rust">fn bitor(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitxor"><a class="header" href="#bitxor">BitXor</a></h1>
<p>The bitwise XOR operator <code>^</code>.  # ExamplesAn implementation of <code>BitXor</code> for a wrapper around <code>bool</code>.</p>
<pre><code class="language-cairo">use core::traits::BitXor;

<span class="boring">[derive(Drop, PartialEq)]
</span>struct Scalar {
    inner: bool,
}

impl BitXorScalar of BitXor&lt;Scalar&gt; {
    fn bitxor(lhs: Scalar, rhs: Scalar) -&gt; Scalar {
        Scalar { inner: lhs.inner ^ rhs.inner }
    }
}

assert!(Scalar { inner: true } ^ Scalar { inner: true } == Scalar { inner: false });
assert!(Scalar { inner: true } ^ Scalar { inner: false } == Scalar { inner: true });
assert!(Scalar { inner: false } ^ Scalar { inner: true } == Scalar { inner: true });
assert!(Scalar { inner: false } ^ Scalar { inner: false } == Scalar { inner: false });
</code></pre>
<p>Fully qualified path: <code>core::traits::BitXor</code></p>
<pre><code class="language-rust">pub trait BitXor&lt;T&gt;</code></pre>
<h2 id="trait-functions-14"><a class="header" href="#trait-functions-14">Trait functions</a></h2>
<h3 id="bitxor-1"><a class="header" href="#bitxor-1">bitxor</a></h3>
<p>Performs the <code>^</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(1_u8 ^ 2_u8 == 3);
</code></pre>
<p>Fully qualified path: <code>core::traits::BitXor::bitxor</code></p>
<pre><code class="language-rust">fn bitxor(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitnot"><a class="header" href="#bitnot">BitNot</a></h1>
<p>The bitwise NOT operator <code>~</code>.  # ExamplesAn implementation of <code>BitNot</code> for a wrapper around <code>u8</code>.</p>
<pre><code class="language-cairo">use core::traits::BitNot;

<span class="boring">[derive(Drop, PartialEq)]
</span>struct Wrapper {
    u8: u8,
}

impl BitNotWrapper of BitNot&lt;Wrapper&gt; {
    fn bitnot(a: Wrapper) -&gt; Wrapper {
        Wrapper { u8: ~a.u8 }
    }
}

assert!(~Wrapper { u8: 0 } == Wrapper { u8 : 255 });
assert!(~Wrapper { u8: 1 } == Wrapper { u8 : 254 });
</code></pre>
<p>Fully qualified path: <code>core::traits::BitNot</code></p>
<pre><code class="language-rust">pub trait BitNot&lt;T&gt;</code></pre>
<h2 id="trait-functions-15"><a class="header" href="#trait-functions-15">Trait functions</a></h2>
<h3 id="bitnot-1"><a class="header" href="#bitnot-1">bitnot</a></h3>
<p>Performs the <code>~</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(~1_u8 == 254);
</code></pre>
<p>Fully qualified path: <code>core::traits::BitNot::bitnot</code></p>
<pre><code class="language-rust">fn bitnot(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partialord"><a class="header" href="#partialord">PartialOrd</a></h1>
<p>Trait for comparing types that form a <a href="https://en.wikipedia.org/wiki/Partial_order">partial order</a>.The <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> methods of this trait can be called using the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators, respectively.PartialOrd is not derivable, but can be implemented manually  # Implementing <code>PartialOrd</code>Here's how to implement <code>PartialOrd</code> for a custom type. This example implements comparison operations for a 2D point where points are compared based on their squared Euclidean distance from the origin (0,0):</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Point {
    x: u32,
    y: u32,
}

impl PointPartialOrd of PartialOrd&lt;Point&gt; {
    fn lt(lhs: Point, rhs: Point) -&gt; bool {
        let lhs_dist = lhs.x * lhs.x + lhs.y * lhs.y;
        let rhs_dist = rhs.x * rhs.x + rhs.y * rhs.y;
        lhs_dist &lt; rhs_dist
    }
}

let p1 = Point { x: 1, y: 1 }; // distance = 2
let p2 = Point { x: 2, y: 2 }; // distance = 8

assert!(p1 &lt; p2);
assert!(p1 &lt;= p2);
assert!(p2 &gt; p1);
assert!(p2 &gt;= p1);
</code></pre>
<p>Note that only the <code>lt</code> method needs to be implemented. The other comparison operations (<code>le</code>, <code>gt</code>, <code>ge</code>) are automatically derived from <code>lt</code>. However, you can override them for better performance if needed.</p>
<p>Fully qualified path: <code>core::traits::PartialOrd</code></p>
<pre><code class="language-rust">pub trait PartialOrd&lt;T&gt;</code></pre>
<h2 id="trait-functions-16"><a class="header" href="#trait-functions-16">Trait functions</a></h2>
<h3 id="lt"><a class="header" href="#lt">lt</a></h3>
<p>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(1 &lt; 1, false);
assert_eq!(1 &lt; 2, true);
assert_eq!(2 &lt; 1, false);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialOrd::lt</code></p>
<pre><code class="language-rust">fn lt(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="ge"><a class="header" href="#ge">ge</a></h3>
<p>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(1 &lt;= 1, true);
assert_eq!(1 &lt;= 2, true);
assert_eq!(2 &lt;= 1, false);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialOrd::ge</code></p>
<pre><code class="language-rust">fn ge(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="gt"><a class="header" href="#gt">gt</a></h3>
<p>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(1 &gt; 1, false);
assert_eq!(1 &gt; 2, false);
assert_eq!(2 &gt; 1, true);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialOrd::gt</code></p>
<pre><code class="language-rust">fn gt(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="le"><a class="header" href="#le">le</a></h3>
<p>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(1 &gt;= 1, true);
assert_eq!(1 &gt;= 2, false);
assert_eq!(2 &gt;= 1, true);
</code></pre>
<p>Fully qualified path: <code>core::traits::PartialOrd::le</code></p>
<pre><code class="language-rust">fn le(lhs: T, rhs: T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into"><a class="header" href="#into">Into</a></h1>
<p>A value-to-value conversion that consumes the input value.Note: This trait must not fail. If the conversion can fail, use <a href="./core-traits-TryInto.html"><code>TryInto</code></a>.  # Generic Implementations<a href="./core-traits-Into.html"><code>Into</code></a> is reflexive, which means that <code>Into&lt;T, T&gt;</code> is implemented  # ExamplesConverting from RGB components to a packed color value:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>struct Color {
    // Packed as 0x00RRGGBB
    value: u32,
}

impl RGBIntoColor of Into&lt;(u8, u8, u8), Color&gt; {
    fn into(self: (u8, u8, u8)) -&gt; Color {
        let (r, g, b) = self;
        let value = (r.into() * 0x10000_u32) +
                   (g.into() * 0x100_u32) +
                   b.into();
        Color { value }
    }
}

// Convert RGB(255, 128, 0) to 0x00FF8000
let orange: Color = (255_u8, 128_u8, 0_u8).into();
assert!(orange == Color { value: 0x00FF8000_u32 });
</code></pre>
<p>Fully qualified path: <code>core::traits::Into</code></p>
<pre><code class="language-rust">pub trait Into&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-17"><a class="header" href="#trait-functions-17">Trait functions</a></h2>
<h3 id="into-1"><a class="header" href="#into-1">into</a></h3>
<p>Converts the input type T into the output type S.  # Examples</p>
<pre><code class="language-cairo">let a: u8 = 1;
let b: u16 = a.into();
</code></pre>
<p>Fully qualified path: <code>core::traits::Into::into</code></p>
<pre><code class="language-rust">fn into(self: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryinto"><a class="header" href="#tryinto">TryInto</a></h1>
<p>Simple and safe type conversions that may fail in a controlled way under some circumstances.This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an <a href="./core-integer-i64.html"><code>i64</code></a> into an <a href="./core-integer-i32.html"><code>i32</code></a> using the <a href="./core-traits-Into.html"><code>Into</code></a> trait, because an <a href="./core-integer-i64.html"><code>i64</code></a> may contain a value that an <a href="./core-integer-i32.html"><code>i32</code></a> cannot represent and so the conversion would lose data.  This might be handled by truncating the <a href="./core-integer-i64.html"><code>i64</code></a> to an <a href="./core-integer-i32.html"><code>i32</code></a> or by simply returning <a href="%60Bounded::%3Ci32%3E::MAX%60"><code>Bounded::&lt;i32&gt;::MAX</code></a>, or by some other method. The <a href="./core-traits-Into.html"><code>Into</code></a> trait is intended for perfect conversions, so the <code>TryInto</code> trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.  # Generic Implementations<a href="./core-traits-TryInto.html"><code>TryInto</code></a> is reflexive, which means that <code>TryInto&lt;T, T&gt;</code> is implemented - <a href="./core-traits-TryInto.html"><code>TryInto</code></a> is implemented for all types that implement <a href="./core-traits-Into.html"><code>Into</code></a>  # ExamplesConverting chess coordinates (like 'e4') into a validated position:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span> struct Position {
     file: u8, // Column a-h (0-7)
     rank: u8, // Row 1-8 (0-7)
 }

 impl TupleTryIntoPosition of TryInto&lt;(u8, u8), Position&gt; {
    fn try_into(self: (u8, u8)) -&gt; Option&lt;Position&gt; {
        let (file_char, rank) = self;

        // Validate rank is between 1 and 8
        if rank &lt; 1 || rank &gt; 8 {
            return None;
        }

        // Validate and convert file character (a-h) to number (0-7)
        if file_char &lt; 'a' || file_char &gt; 'h' {
            return None;
        }
        let file = file_char - 'a';

        Some(Position {
            file,
            rank: rank - 1 // Convert 1-8 (chess notation) to 0-7 (internal index)
        })
    }
}

// Valid positions
let e4 = ('e', 4).try_into();
assert!(e4 == Some(Position { file: 4, rank: 3 }));

// Invalid positions
let invalid_file = ('x', 4).try_into();
let invalid_rank = ('a', 9).try_into();
assert!(invalid_file == None);
assert!(invalid_rank == None);
</code></pre>
<p>Fully qualified path: <code>core::traits::TryInto</code></p>
<pre><code class="language-rust">pub trait TryInto&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-18"><a class="header" href="#trait-functions-18">Trait functions</a></h2>
<h3 id="try_into"><a class="header" href="#try_into">try_into</a></h3>
<p>Attempts to convert the input type T into the output type S. In the event of a conversion error, returns <a href="./core-option.html#none"><code>None</code></a>.  # Examples</p>
<pre><code class="language-cairo">let a: Option&lt;u8&gt; = 1_u16.try_into();
assert!(a == Some(1));
let b: Option&lt;u8&gt; = 256_u16.try_into();
assert!(b == None);
</code></pre>
<p>Fully qualified path: <code>core::traits::TryInto::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: T) -&gt; Option&lt;S&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neg"><a class="header" href="#neg">Neg</a></h1>
<p>The unary negation operator <code>-</code>.  # ExamplesAn implementation of <code>Neg</code> for <code>Sign</code>, which allows the use of <code>-</code> to negate its value.</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, PartialEq)]
</span>enum Sign {
    Negative,
    Zero,
    Positive,
}

impl SignNeg of Neg&lt;Sign&gt; {
    fn neg(a: Sign) -&gt; Sign {
        match a {
            Sign::Negative =&gt; Sign::Positive,
            Sign::Zero =&gt; Sign::Zero,
            Sign::Positive =&gt; Sign::Negative,
        }
    }
}

// A negative positive is a negative
assert!(-Sign::Positive == Sign::Negative);
// A double negative is a positive
assert!(-Sign::Negative == Sign::Positive);
// Zero is its own negation
assert!(-Sign::Zero == Sign::Zero);
</code></pre>
<p>Fully qualified path: <code>core::traits::Neg</code></p>
<pre><code class="language-rust">pub trait Neg&lt;T&gt;</code></pre>
<h2 id="trait-functions-19"><a class="header" href="#trait-functions-19">Trait functions</a></h2>
<h3 id="neg-1"><a class="header" href="#neg-1">neg</a></h3>
<p>Performs the unary <code>-</code> operation.  # Examples</p>
<pre><code class="language-cairo">let x: i8 = 1;
assert!(-x == -1);
</code></pre>
<p>Fully qualified path: <code>core::traits::Neg::neg</code></p>
<pre><code class="language-rust">fn neg(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="not"><a class="header" href="#not">Not</a></h1>
<p>The unary logical negation operator <code>!</code>.  # ExamplesAn implementation of <code>Not</code> for <code>Answer</code>, which enables the use of <code>!</code> to invert its value.</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, PartialEq)]
</span>enum Answer {
    Yes,
    No,
}

impl AnswerNot of Not&lt;Answer&gt; {
    fn not(a: Answer) -&gt; Answer {
        match a {
            Answer::Yes =&gt; Answer::No,
            Answer::No =&gt; Answer::Yes,
        }
    }
}

assert!(!Answer::Yes == Answer::No);
assert!(!Answer::No == Answer::Yes);
</code></pre>
<p>Fully qualified path: <code>core::traits::Not</code></p>
<pre><code class="language-rust">pub trait Not&lt;T&gt;</code></pre>
<h2 id="trait-functions-20"><a class="header" href="#trait-functions-20">Trait functions</a></h2>
<h3 id="not-1"><a class="header" href="#not-1">not</a></h3>
<p>Performs the unary <code>!</code> operation.  # Examples</p>
<pre><code class="language-cairo">assert!(!true == false);
assert!(!false == true);
</code></pre>
<p>Fully qualified path: <code>core::traits::Not::not</code></p>
<pre><code class="language-rust">fn not(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview"><a class="header" href="#indexview">IndexView</a></h1>
<p>Fully qualified path: <code>core::traits::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I, V&gt;</code></pre>
<h2 id="trait-functions-21"><a class="header" href="#trait-functions-21">Trait functions</a></h2>
<h3 id="index-1"><a class="header" href="#index-1">index</a></h3>
<p>Fully qualified path: <code>core::traits::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; V</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-2"><a class="header" href="#index-2">Index</a></h1>
<p>Fully qualified path: <code>core::traits::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I, V&gt;</code></pre>
<h2 id="trait-functions-22"><a class="header" href="#trait-functions-22">Trait functions</a></h2>
<h3 id="index-3"><a class="header" href="#index-3">index</a></h3>
<p>Fully qualified path: <code>core::traits::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; V</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destruct"><a class="header" href="#destruct">Destruct</a></h1>
<p>A trait that allows for custom destruction behavior of a type.In Cairo, values must be explicitly handled - they cannot be silently dropped. Types can only go out of scope in two ways: 1. Implement <code>Drop</code> - for types that can be discarded trivially 2. Implement <code>Destruct</code> - for types that need cleanup when destroyed. Typically, any type that contains a <code>Felt252Dict</code> must implement <code>Destruct</code>, as the <code>Felt252Dict</code> needs to be "squashed" when going out of scope to ensure a program is sound.Generally, <code>Destruct</code> does not need to be implemented manually. It can be derived from the <code>Drop</code> and <code>Destruct</code> implementations of the type's fields.  # ExamplesHere's a simple type that wraps a <code>Felt252Dict</code> and needs to be destructed:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

// A struct containing a Felt252Dict must implement Destruct
<span class="boring">[derive(Destruct, Default)]
</span>struct ResourceManager {
    resources: Felt252Dict&lt;u32&gt;,
    count: u32,
}

<span class="boring">[generate_trait]
</span>impl ResourceManagerImpl of ResourceManagerTrait{
   fn add_resource(ref self: ResourceManager, resource_id: felt252, amount: u32){
       assert!(self.resources.get(resource_id) == 0, "Resource already exists");
       self.resources.insert(resource_id, amount);
       self.count += amount;
   }
}

let mut manager = Default::default();

// Add some resources
manager.add_resource(1, 100);

// When manager goes out of scope here, Destruct is automatically called,
// which ensures the dictionary is properly squashed
</code></pre>
<p>Fully qualified path: <code>core::traits::Destruct</code></p>
<pre><code class="language-rust">pub trait Destruct&lt;T&gt;</code></pre>
<h2 id="trait-functions-23"><a class="header" href="#trait-functions-23">Trait functions</a></h2>
<h3 id="destruct-1"><a class="header" href="#destruct-1">destruct</a></h3>
<p>Fully qualified path: <code>core::traits::Destruct::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: T) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicdestruct"><a class="header" href="#panicdestruct">PanicDestruct</a></h1>
<p>A trait that allows for destruction of a value in case of a panic.This trait is automatically implemented from the <code>Destruct</code> implementation for a type.</p>
<p>Fully qualified path: <code>core::traits::PanicDestruct</code></p>
<pre><code class="language-rust">pub trait PanicDestruct&lt;T&gt;</code></pre>
<h2 id="trait-functions-24"><a class="header" href="#trait-functions-24">Trait functions</a></h2>
<h3 id="panic_destruct"><a class="header" href="#panic_destruct">panic_destruct</a></h3>
<p>Fully qualified path: <code>core::traits::PanicDestruct::panic_destruct</code></p>
<pre><code class="language-rust">fn panic_destruct(self: T, ref panic: Panic) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default"><a class="header" href="#default">Default</a></h1>
<p>A trait for giving a type a useful default value.Cairo implements <code>Default</code> for various primitives types.  # DerivableThis trait can be used with <code>#[derive]</code> if all of the type's fields implement <code>Default</code>. When <code>derive</code>d, it will use the default value for each field's type.  ## <code>enum</code>sWhen using <code>#[derive(Default)]</code> on an <code>enum</code>, you need to choose which unit variant will be default. You do this by placing the <code>#[default]</code> attribute on the variant.</p>
<pre><code class="language-cairo"><span class="boring">[derive(Default)]
</span>enum Kind {
<span class="boring">    [default]
</span>    A,
    B,
    C,
}
</code></pre>
<p>You can even use the <code>#[default]</code> attribute even on non-unit variants, provided that the associated type implements <code>Default</code>.  # How can I implement <code>Default</code>?Provide an implementation for the <code>default()</code> method that returns the value of your type that should be the default:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop)]
</span>enum Kind {
    A,
    B,
    C,
}

impl DefaultKind of Default&lt;Kind&gt; {
    fn default() -&gt; Kind { Kind::A }
}
</code></pre>
<h1 id="examplesderivedrop-default-partialeqderivedrop-default-partialeq-struct-someoptions-foo-i32bar-u32assertdefaultdefault--someoptions--foo-0-bar-0-"><a class="header" href="#examplesderivedrop-default-partialeqderivedrop-default-partialeq-struct-someoptions-foo-i32bar-u32assertdefaultdefault--someoptions--foo-0-bar-0-">Examples#[derive(Drop, Default, PartialEq)](derive(Drop, Default, PartialEq)) struct SomeOptions {foo: i32,bar: u32,}assert!(Default::default() == SomeOptions { foo: 0, bar: 0 });</a></h1>
<p>Fully qualified path: <code>core::traits::Default</code></p>
<pre><code class="language-rust">pub trait Default&lt;T&gt;</code></pre>
<h2 id="trait-functions-25"><a class="header" href="#trait-functions-25">Trait functions</a></h2>
<h3 id="default-1"><a class="header" href="#default-1">default</a></h3>
<p>Returns the "default value" for a type.Default values are often some kind of initial value, identity value, or anything else that may make sense as a default.  # Examples</p>
<pre><code class="language-cairo">let i: i8 = Default::default();
let (x, y): (Option&lt;ByteArray&gt;, u64) = Default::default();
let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();
</code></pre>
<p>Fully qualified path: <code>core::traits::Default::default</code></p>
<pre><code class="language-rust">fn default() -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictvalue"><a class="header" href="#felt252dictvalue">Felt252DictValue</a></h1>
<p>A trait that must be implemented for any type that will be stored as a value in a <code>Felt252Dict</code>.When working with dictionaries in Cairo, we need a way to represent "empty" or "uninitialized" slots. This trait provides a zero-like default value that is returned when accessing a key that hasn't been explicitly set.  # Why is this needed?The <code>Felt252Dict</code> implementation needs to handle cases where a key hasn't been assigned a value yet. Instead of using <code>Option</code> or similar constructs, it uses a zero-like value specific to each type.This trait is only implemented for primitive scalar types and <code>Nullable&lt;T&gt;</code>. It cannot be implemented manually. Instead, if you want to use a custom type as a value in a dictionary, you can wrap your type in a <a href="./core-nullable-Nullable.html"><code>Nullable</code></a>, which implements <code>Felt252DictValue</code> for any wrapped type.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

<span class="boring">[derive(Copy, Drop, Default)]
</span>struct Counter {
    value: u32,
}

 // u8 already implements Felt252DictValue
 let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
 assert!(dict.get(123) == 0);

 // Counter is wrapped in a Nullable, as it doesn't implement Felt252DictValue
 let mut counters: Felt252Dict&lt;Nullable&lt;Counter&gt;&gt; = Default::default();

 // If the key is not set, `deref` would panic. `deref_or` returns the default value.
 let maybe_counter: Nullable&lt;Counter&gt; = counters.get(123);
 assert!(maybe_counter.deref_or(Default::default()).value == 0);
</code></pre>
<p>Fully qualified path: <code>core::traits::Felt252DictValue</code></p>
<pre><code class="language-rust">pub trait Felt252DictValue&lt;T&gt;</code></pre>
<h2 id="trait-functions-26"><a class="header" href="#trait-functions-26">Trait functions</a></h2>
<h3 id="zero_default"><a class="header" href="#zero_default">zero_default</a></h3>
<p>Returns the default value for this type when used in a <code>Felt252Dict</code>. This value should be logically equivalent to zero or an "empty" state.</p>
<p>Fully qualified path: <code>core::traits::Felt252DictValue::zero_default</code></p>
<pre><code class="language-rust">fn zero_default() -&gt; T nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booltrait"><a class="header" href="#booltrait">BoolTrait</a></h1>
<p>Fully qualified path: <code>core::boolean::BoolTrait</code></p>
<pre><code class="language-rust">pub trait BoolTrait&lt;T, +Drop&lt;T&gt;&gt;</code></pre>
<h2 id="trait-functions-27"><a class="header" href="#trait-functions-27">Trait functions</a></h2>
<h3 id="then_some"><a class="header" href="#then_some">then_some</a></h3>
<p>Returns <code>Some(t)</code> if the <code>bool</code> is <code>true</code>, <code>None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">assert!(false.then_some(0) == None);
assert!(true.then_some(0) == Some(0));
</code></pre>
<p>Fully qualified path: <code>core::boolean::BoolTrait::then_some</code></p>
<pre><code class="language-rust">fn then_some(self: bool, t: T) -&gt; Option&lt;T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementtrait"><a class="header" href="#circuitelementtrait">CircuitElementTrait</a></h1>
<p>A marker trait for keeping track of which types are valid circuit elements.This trait is implemented for all valid circuit components including inputs and gates. It provides type safety when composing circuit elements.</p>
<p>Fully qualified path: <code>core::circuit::CircuitElementTrait</code></p>
<pre><code class="language-rust">pub trait CircuitElementTrait&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitdefinition"><a class="header" href="#circuitdefinition">CircuitDefinition</a></h1>
<p>A trait for defining a circuit's structure and behavior.This trait is used to define the structure of a circuit, including its inputs, gates, and outputs. It provides the foundation for circuit evaluation. The <code>CES</code> type parameter represents a tuple of <code>CircuitElement</code>s that together define the circuit's structure.</p>
<p>Fully qualified path: <code>core::circuit::CircuitDefinition</code></p>
<pre><code class="language-rust">pub trait CircuitDefinition&lt;CES&gt;</code></pre>
<h2 id="trait-types"><a class="header" href="#trait-types">Trait types</a></h2>
<h3 id="circuittype"><a class="header" href="#circuittype">CircuitType</a></h3>
<p>The internal circuit type representing a tuple of <code>CircuitElement</code>s.</p>
<p>Fully qualified path: <code>core::circuit::CircuitDefinition::CircuitType</code></p>
<pre><code class="language-rust">type CircuitType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitoutputstrait"><a class="header" href="#circuitoutputstrait">CircuitOutputsTrait</a></h1>
<p>A trait for retrieving output values from a circuit evaluation.This trait provides methods to access the output values of a circuit after successful evaluation.  # Examples</p>
<pre><code class="language-cairo">let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
let modulus = TryInto::&lt;_, CircuitModulus&gt;::try_into([2, 0, 0, 0]).unwrap();
let circuit = (a,b).new_inputs()
    .next([10, 0, 0, 0])
    .next([11, 0, 0, 0])
    .done()
    .eval(modulus)
    .unwrap();
let a_mod_2 = circuit.get_output(a); // Returns the output value of `a mod 2`
let b_mod_2 = circuit.get_output(b); // Returns the output value of `b mod 2`
assert!(a_mod_2 == 0.into());
assert!(b_mod_2 == 1.into());
</code></pre>
<p>Fully qualified path: <code>core::circuit::CircuitOutputsTrait</code></p>
<pre><code class="language-rust">pub trait CircuitOutputsTrait&lt;Outputs, OutputElement&gt;</code></pre>
<h2 id="trait-functions-28"><a class="header" href="#trait-functions-28">Trait functions</a></h2>
<h3 id="get_output"><a class="header" href="#get_output">get_output</a></h3>
<p>Gets the output value for a specific circuit element.  # Arguments<code>output</code> - The circuit element to get the output for  # ReturnsThe output value as a u384</p>
<p>Fully qualified path: <code>core::circuit::CircuitOutputsTrait::get_output</code></p>
<pre><code class="language-rust">fn get_output(self: Outputs, output: OutputElement) -&gt; u384</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitinputs"><a class="header" href="#circuitinputs">CircuitInputs</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitInputs</code></p>
<pre><code class="language-rust">pub trait CircuitInputs&lt;CES&gt;</code></pre>
<h2 id="trait-functions-29"><a class="header" href="#trait-functions-29">Trait functions</a></h2>
<h3 id="new_inputs"><a class="header" href="#new_inputs">new_inputs</a></h3>
<p>Initializes a new circuit instance with inputs.This function creates a new input accumulator for the circuit, which can then be used to add input values sequentially.  # ReturnsAn <code>AddInputResult</code> that can be used to add input values to the circuit</p>
<p>Fully qualified path: <code>core::circuit::CircuitInputs::new_inputs</code></p>
<pre><code class="language-rust">fn new_inputs&lt;impl CD: CircuitDefinition&lt;CES&gt;, +Drop&lt;CES&gt;&gt;(
    self: CES,
) -&gt; AddInputResult&lt;CD::CircuitType&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addinputresulttrait"><a class="header" href="#addinputresulttrait">AddInputResultTrait</a></h1>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait</code></p>
<pre><code class="language-rust">pub trait AddInputResultTrait&lt;C&gt;</code></pre>
<h2 id="trait-functions-30"><a class="header" href="#trait-functions-30">Trait functions</a></h2>
<h3 id="next"><a class="header" href="#next">next</a></h3>
<p>Adds an input value to the circuit instance.  # Arguments<code>value</code> - The value to add as input, must be convertible to circuit input value  # ReturnsA new <code>AddInputResult</code> that can be used to add more inputs or finalize  # PanicsPanics if all inputs have already been filled</p>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait::next</code></p>
<pre><code class="language-rust">fn next&lt;Value, +IntoCircuitInputValue&lt;Value&gt;, +Drop&lt;Value&gt;&gt;(
    self: AddInputResult&lt;C&gt;, value: Value,
) -&gt; AddInputResult&lt;C&gt;</code></pre>
<h3 id="done-1"><a class="header" href="#done-1">done</a></h3>
<p>Finalizes the input process and returns the circuit data.  # ReturnsThe complete circuit data ready for evaluation  # PanicsPanics if not all required inputs have been filled</p>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait::done</code></p>
<pre><code class="language-rust">fn done(self: AddInputResult&lt;C&gt;) -&gt; CircuitData&lt;C&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evalcircuittrait"><a class="header" href="#evalcircuittrait">EvalCircuitTrait</a></h1>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait</code></p>
<pre><code class="language-rust">pub trait EvalCircuitTrait&lt;C&gt;</code></pre>
<h2 id="trait-functions-31"><a class="header" href="#trait-functions-31">Trait functions</a></h2>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p>Evaluates the circuit with the given modulus.  # Arguments<code>modulus</code> - The modulus to use for arithmetic operations  # ReturnsResult containing either the circuit outputs or a failure indication</p>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait::eval</code></p>
<pre><code class="language-rust">fn eval(self: CircuitData&lt;C&gt;, modulus: CircuitModulus) -&gt; crate::circuit::EvalCircuitResult&lt;C&gt;</code></pre>
<h3 id="eval_ex"><a class="header" href="#eval_ex">eval_ex</a></h3>
<p>Evaluates the circuit with an explicit descriptor and modulus.  # Arguments<code>descriptor</code> - The circuit descriptor * <code>modulus</code> - The modulus to use for arithmetic operations  # ReturnsResult containing either the circuit outputs or a failure indication</p>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait::eval_ex</code></p>
<pre><code class="language-rust">fn eval_ex(
    self: CircuitData&lt;C&gt;, descriptor: CircuitDescriptor&lt;C&gt;, modulus: CircuitModulus,
) -&gt; crate::circuit::EvalCircuitResult&lt;C&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxtrait"><a class="header" href="#boxtrait">BoxTrait</a></h1>
<p>Fully qualified path: <code>core::box::BoxTrait</code></p>
<pre><code class="language-rust">pub trait BoxTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-32"><a class="header" href="#trait-functions-32">Trait functions</a></h2>
<h3 id="new"><a class="header" href="#new">new</a></h3>
<p>Creates a new <code>Box</code> with the given value.Allocates space in the boxed segment for the provided value and returns a <code>Box&lt;T&gt;</code> that points to it. # Examples</p>
<pre><code class="language-cairo">let x = 42;
let boxed_x = BoxTrait::new(x);
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::new</code></p>
<pre><code class="language-rust">fn new(value: T) -&gt; Box&lt;T&gt; nopanic</code></pre>
<h3 id="unbox"><a class="header" href="#unbox">unbox</a></h3>
<p>Unboxes the given <code>Box</code> and returns the wrapped value.  # Examples</p>
<pre><code class="language-cairo">let boxed = BoxTrait::new(42);
assert!(boxed.unbox() == 42);
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::unbox</code></p>
<pre><code class="language-rust">fn unbox(self: Box&lt;T&gt;) -&gt; T nopanic</code></pre>
<h3 id="as_snapshot"><a class="header" href="#as_snapshot">as_snapshot</a></h3>
<p>Converts the given snapshot of a <code>Box</code> into a <code>Box</code> of a snapshot. Useful for structures that aren't copyable.  # Examples</p>
<pre><code class="language-cairo">let snap_boxed_arr = @BoxTraits::new(array![1, 2, 3]);
let boxed_snap_arr = snap_boxed_arr.as_snapshot();
let snap_arr = boxed_snap_arr.unbox();
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::as_snapshot</code></p>
<pre><code class="language-rust">fn as_snapshot(self: @Box&lt;T&gt;) -&gt; Box&lt;@T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullabletrait"><a class="header" href="#nullabletrait">NullableTrait</a></h1>
<p>Fully qualified path: <code>core::nullable::NullableTrait</code></p>
<pre><code class="language-rust">pub trait NullableTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-33"><a class="header" href="#trait-functions-33">Trait functions</a></h2>
<h3 id="deref"><a class="header" href="#deref">deref</a></h3>
<p>Wrapper for <code>Deref::deref</code>. Prefer using <code>Deref::deref</code> directly.This function exists for backwards compatibility.  # ExamplesPreferred way:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
let unwrapped = value.deref();
</code></pre>
<p>This function method does the same thing:</p>
<pre><code class="language-cairo">use core::nullable::NullableTrait;
let also_unwrapped = NullableTrait::deref(value);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::deref</code></p>
<pre><code class="language-rust">fn deref(nullable: Nullable&lt;T&gt;) -&gt; T</code></pre>
<h3 id="deref_or"><a class="header" href="#deref_or">deref_or</a></h3>
<p>Returns the contained value if not null, or returns the provided default value.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(value.deref_or(0) == 42);

let null_value: Nullable&lt;u32&gt; = Default::default();
assert!(null_value.deref_or(0) == 0);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::deref_or</code></p>
<pre><code class="language-rust">fn deref_or&lt;+Drop&lt;T&gt;&gt;(self: Nullable&lt;T&gt;, default: T) -&gt; T</code></pre>
<h3 id="new-1"><a class="header" href="#new-1">new</a></h3>
<p>Creates a new non-null <code>Nullable</code> with the given value.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(!value.is_null());
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::new</code></p>
<pre><code class="language-rust">fn new(value: T) -&gt; Nullable&lt;T&gt;</code></pre>
<h3 id="is_null"><a class="header" href="#is_null">is_null</a></h3>
<p>Returns <code>true</code> if the value is null.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(!value.is_null());

let null_value: Nullable&lt;u32&gt; = Default::default();
assert!(null_value.is_null());
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::is_null</code></p>
<pre><code class="language-rust">fn is_null(self: @Nullable&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="as_snapshot-1"><a class="header" href="#as_snapshot-1">as_snapshot</a></h3>
<p>Creates a new <code>Nullable</code> containing a snapshot of the value.This is useful when working with non-copyable types inside a <code>Nullable</code>. This allows you to keep using the original value while also having access to a snapshot of it, preventing the original value from being moved.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;Array&lt;u32&gt;&gt; = NullableTrait::new(array![1, 2, 3]);
let res = (@value).as_snapshot();
assert!(res.deref() == @array![1, 2, 3]);
assert!(value.deref() == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::as_snapshot</code></p>
<pre><code class="language-rust">fn as_snapshot(self: @Nullable&lt;T&gt;) -&gt; Nullable&lt;@T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tospantrait"><a class="header" href="#tospantrait">ToSpanTrait</a></h1>
<p><code>ToSpanTrait</code> converts a data structure into a span of its data.</p>
<p>Fully qualified path: <code>core::array::ToSpanTrait</code></p>
<pre><code class="language-rust">pub trait ToSpanTrait&lt;C, T&gt;</code></pre>
<h2 id="trait-functions-34"><a class="header" href="#trait-functions-34">Trait functions</a></h2>
<h3 id="span-1"><a class="header" href="#span-1">span</a></h3>
<p>Returns a span pointing to the data in the input.</p>
<p>Fully qualified path: <code>core::array::ToSpanTrait::span</code></p>
<pre><code class="language-rust">fn span(self: @C) -&gt; Span&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraytrait"><a class="header" href="#arraytrait">ArrayTrait</a></h1>
<p>Fully qualified path: <code>core::array::ArrayTrait</code></p>
<pre><code class="language-rust">pub trait ArrayTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-35"><a class="header" href="#trait-functions-35">Trait functions</a></h2>
<h3 id="new-2"><a class="header" href="#new-2">new</a></h3>
<p>Constructs a new, empty <code>Array&lt;T&gt;</code>.  # Examples</p>
<pre><code class="language-cairo">let arr: Array&lt;u32&gt; = ArrayTrait::new();

let arr = ArrayTrait::&lt;u128&gt;::new();
</code></pre>
<p>It is also possible to use the <code>array!</code> macro to create a new array.</p>
<pre><code class="language-cairo">let arr: Array&lt;bool&gt; = array![];
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::new</code></p>
<pre><code class="language-rust">fn new() -&gt; Array&lt;T&gt; nopanic</code></pre>
<h3 id="append"><a class="header" href="#append">append</a></h3>
<p>Adds a value of type <code>T</code> to the end of the array.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;u8&gt; = array![1, 2];
arr.append(3);
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::append</code></p>
<pre><code class="language-rust">fn append(ref self: Array&lt;T&gt;, value: T) nopanic</code></pre>
<h3 id="append_span"><a class="header" href="#append_span">append_span</a></h3>
<p>Adds a span to the end of the array.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;u8&gt; = array![];
arr.append_span(array![1, 2, 3].span());
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::append_span</code></p>
<pre><code class="language-rust">fn append_span&lt;+Clone&lt;T&gt;, +Drop&lt;T&gt;&gt;(ref self: Array&lt;T&gt;, span: Span&lt;T&gt;)</code></pre>
<h3 id="pop_front"><a class="header" href="#pop_front">pop_front</a></h3>
<p>Pops a value from the front of the array. Returns <code>Some(value)</code> if the array is not empty, <code>None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut arr = array![2, 3, 4];
assert!(arr.pop_front() == Some(2));
assert!(arr.pop_front() == Some(3));
assert!(arr.pop_front() == Some(4));
assert!(arr.pop_front().is_none());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::pop_front</code></p>
<pre><code class="language-rust">fn pop_front(ref self: Array&lt;T&gt;) -&gt; Option&lt;T&gt; nopanic</code></pre>
<h3 id="pop_front_consume"><a class="header" href="#pop_front_consume">pop_front_consume</a></h3>
<p>Pops a value from the front of the array. Returns an option containing the remaining array and the value removed if the array is not empty, otherwise <code>None</code> and drops the array.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.pop_front_consume() == Some((array![3, 4], 2)));

let arr: Array&lt;u8&gt; = array![];
assert!(arr.pop_front_consume().is_none());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::pop_front_consume</code></p>
<pre><code class="language-rust">fn pop_front_consume(self: Array&lt;T&gt;) -&gt; Option&lt;(Array&lt;T&gt;, T)&gt; nopanic</code></pre>
<h3 id="get"><a class="header" href="#get">get</a></h3>
<p>Returns an option containing a box of a snapshot of the element at the given 'index' if the array contains this index, 'None' otherwise.Element at index 0 is the front of the array.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.get(1).unwrap().unbox() == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::get</code></p>
<pre><code class="language-rust">fn get(self: @Array&lt;T&gt;, index: usize) -&gt; Option&lt;Box&lt;@T&gt;&gt;</code></pre>
<h3 id="at"><a class="header" href="#at">at</a></h3>
<p>Returns a snapshot of the element at the given index.Element at index 0 is the front of the array.  # PanicsPanics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;usize&gt; = array![3,4,5,6];
assert!(arr.at(1) == @4);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::at</code></p>
<pre><code class="language-rust">fn at(self: @Array&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<h3 id="len"><a class="header" href="#len">len</a></h3>
<p>Returns the length of the array as a <code>usize</code> value.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.len() == 3);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::len</code></p>
<pre><code class="language-rust">fn len(self: @Array&lt;T&gt;) -&gt; usize</code></pre>
<h3 id="is_empty"><a class="header" href="#is_empty">is_empty</a></h3>
<p>Returns whether the array is empty or not.  # Examples</p>
<pre><code class="language-cairo">let mut arr = array![];
assert!(arr.is_empty());
arr.append(1);
assert!(!arr.is_empty());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: @Array&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="span-2"><a class="header" href="#span-2">span</a></h3>
<p>Returns a span of the array.  # Examples</p>
<pre><code class="language-cairo">let arr: Array&lt;u8&gt; = array![1, 2, 3];
let span: Span&lt;u8&gt; = arr.span();
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::span</code></p>
<pre><code class="language-rust">fn span(snapshot: @Array&lt;T&gt;) -&gt; Span&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spantrait"><a class="header" href="#spantrait">SpanTrait</a></h1>
<p>Fully qualified path: <code>core::array::SpanTrait</code></p>
<pre><code class="language-rust">pub trait SpanTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-36"><a class="header" href="#trait-functions-36">Trait functions</a></h2>
<h3 id="pop_front-1"><a class="header" href="#pop_front-1">pop_front</a></h3>
<p>Pops a value from the front of the span. Returns <code>Some(@value)</code> if the array is not empty, <code>None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
assert!(span.pop_front() == Some(@1));
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::pop_front</code></p>
<pre><code class="language-rust">fn pop_front(ref self: Span&lt;T&gt;) -&gt; Option&lt;@T&gt;</code></pre>
<h3 id="pop_back"><a class="header" href="#pop_back">pop_back</a></h3>
<p>Pops a value from the back of the span. Returns <code>Some(@value)</code> if the array is not empty, <code>None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
assert!(span.pop_back() == Some(@3));
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::pop_back</code></p>
<pre><code class="language-rust">fn pop_back(ref self: Span&lt;T&gt;) -&gt; Option&lt;@T&gt;</code></pre>
<h3 id="multi_pop_front"><a class="header" href="#multi_pop_front">multi_pop_front</a></h3>
<p>Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if the action completed successfully, 'None' otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
let result = *(span.multi_pop_front::&lt;2&gt;().unwrap());
let unboxed_result = result.unbox();
assert!(unboxed_result == [1, 2]);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::multi_pop_front</code></p>
<pre><code class="language-rust">fn multi_pop_front&lt;const SIZE: usize&gt;(ref self: Span&lt;T&gt;) -&gt; Option&lt;@Box&lt;[T; SIZE]&gt;&gt;</code></pre>
<h3 id="multi_pop_back"><a class="header" href="#multi_pop_back">multi_pop_back</a></h3>
<p>Pops multiple values from the back of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if the action completed successfully, 'None' otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
let result = *(span.multi_pop_back::&lt;2&gt;().unwrap());
let unboxed_result = result.unbox();
assert!(unboxed_result == [2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::multi_pop_back</code></p>
<pre><code class="language-rust">fn multi_pop_back&lt;const SIZE: usize&gt;(ref self: Span&lt;T&gt;) -&gt; Option&lt;@Box&lt;[T; SIZE]&gt;&gt;</code></pre>
<h3 id="get-1"><a class="header" href="#get-1">get</a></h3>
<p>Returns an option containing a box of a snapshot of the element at the given 'index' if the span contains this index, 'None' otherwise.Element at index 0 is the front of the array.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4];
assert!(span.get(1).unwrap().unbox() == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::get</code></p>
<pre><code class="language-rust">fn get(self: Span&lt;T&gt;, index: usize) -&gt; Option&lt;Box&lt;@T&gt;&gt;</code></pre>
<h3 id="at-1"><a class="header" href="#at-1">at</a></h3>
<p>Returns a snapshot of the element at the given index.Element at index 0 is the front of the array.  # PanicsPanics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4].span();
assert!(span.at(1) == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::at</code></p>
<pre><code class="language-rust">fn at(self: Span&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<h3 id="slice"><a class="header" href="#slice">slice</a></h3>
<p>Returns a span containing values from the 'start' index, with amount equal to 'length'.  # Examples</p>
<pre><code class="language-cairo">let span = array![1, 2, 3].span();
assert!(span.slice(1, 2) == array![2, 3].span());
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::slice</code></p>
<pre><code class="language-rust">fn slice(self: Span&lt;T&gt;, start: usize, length: usize) -&gt; Span&lt;T&gt;</code></pre>
<h3 id="len-1"><a class="header" href="#len-1">len</a></h3>
<p>Returns the length of the span as a <code>usize</code> value.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4].span();
assert!(span.len() == 3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::len</code></p>
<pre><code class="language-rust">fn len(self: Span&lt;T&gt;) -&gt; usize</code></pre>
<h3 id="is_empty-1"><a class="header" href="#is_empty-1">is_empty</a></h3>
<p>Returns whether the span is empty or not.  # Examples</p>
<pre><code class="language-cairo">let span: Span&lt;felt252&gt; = array![].span();
assert!(span.is_empty());
let span = array![1, 2, 3].span();
assert!(!span.is_empty());
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: Span&lt;T&gt;) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dicttrait"><a class="header" href="#felt252dicttrait">Felt252DictTrait</a></h1>
<p>Basic trait for the <code>Felt252Dict</code> type.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait</code></p>
<pre><code class="language-rust">pub trait Felt252DictTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-37"><a class="header" href="#trait-functions-37">Trait functions</a></h2>
<h3 id="insert"><a class="header" href="#insert">insert</a></h3>
<p>Inserts the given value for the given key.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::insert</code></p>
<pre><code class="language-rust">fn insert&lt;+Destruct&lt;T&gt;&gt;(ref self: Felt252Dict&lt;T&gt;, key: felt252, value: T)</code></pre>
<h3 id="get-2"><a class="header" href="#get-2">get</a></h3>
<p>Returns the value stored at the given key. If no value was previously inserted at this key, returns the default value for type T.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let value = dict.get(0);
assert!(value == 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::get</code></p>
<pre><code class="language-rust">fn get&lt;+Copy&lt;T&gt;&gt;(ref self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; T</code></pre>
<h3 id="squash"><a class="header" href="#squash">squash</a></h3>
<p>Squashes a dictionary and returns the associated <code>SquashedFelt252Dict</code>.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let squashed_dict = dict.squash();
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::squash</code></p>
<pre><code class="language-rust">fn squash(self: Felt252Dict&lt;T&gt;) -&gt; SquashedFelt252Dict&lt;T&gt; nopanic</code></pre>
<h3 id="entry"><a class="header" href="#entry">entry</a></h3>
<p>Retrieves the last entry for a certain key. This method takes ownership of the dictionary and returns the entry to update, as well as the previous value at the given key.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let (entry, prev_value) = dict.entry(0);
assert!(prev_value == 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::entry</code></p>
<pre><code class="language-rust">fn entry(self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; (Felt252DictEntry&lt;T&gt;, T) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictentrytrait"><a class="header" href="#felt252dictentrytrait">Felt252DictEntryTrait</a></h1>
<p>Basic trait for the <code>Felt252DictEntryTrait</code> type.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictEntryTrait</code></p>
<pre><code class="language-rust">pub trait Felt252DictEntryTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-38"><a class="header" href="#trait-functions-38">Trait functions</a></h2>
<h3 id="finalize"><a class="header" href="#finalize">finalize</a></h3>
<p>Finalizes the changes made to a dictionary entry and gives back the ownership of the dictionary.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252DictEntryTrait;

// Create a dictionary that stores arrays
let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;felt252&gt;&gt;&gt; = Default::default();

let a = array![1, 2, 3];
dict.insert(0, NullableTrait::new(a));

let (entry, prev_value) = dict.entry(0);
let new_value = NullableTrait::new(array![4, 5, 6]);
dict = entry.finalize(new_value);
assert!(prev_value == a);
assert!(dict.get(0) == new_value);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictEntryTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: Felt252DictEntry&lt;T&gt;, new_value: T) -&gt; Felt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="squashedfelt252dicttrait"><a class="header" href="#squashedfelt252dicttrait">SquashedFelt252DictTrait</a></h1>
<p>Fully qualified path: <code>core::dict::SquashedFelt252DictTrait</code></p>
<pre><code class="language-rust">pub trait SquashedFelt252DictTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-39"><a class="header" href="#trait-functions-39">Trait functions</a></h2>
<h3 id="into_entries"><a class="header" href="#into_entries">into_entries</a></h3>
<p>Returns an array of <code>(key, first_value, last_value)</code> tuples. The first value is always 0.  # Example</p>
<pre><code class="language-cairo">let squashed_dict = dict.squash();
let entries = squashed_dict.entries();
</code></pre>
<p>Fully qualified path: <code>core::dict::SquashedFelt252DictTrait::into_entries</code></p>
<pre><code class="language-rust">fn into_entries(self: SquashedFelt252Dict&lt;T&gt;) -&gt; Array&lt;(felt252, T, T)&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resulttrait"><a class="header" href="#resulttrait">ResultTrait</a></h1>
<p>Fully qualified path: <code>core::result::ResultTrait</code></p>
<pre><code class="language-rust">pub trait ResultTrait&lt;T, E&gt;</code></pre>
<h2 id="trait-functions-40"><a class="header" href="#trait-functions-40">Trait functions</a></h2>
<h3 id="expect"><a class="header" href="#expect">expect</a></h3>
<p>Returns the contained <code>Ok</code> value, consuming the <code>self</code> value.  # PanicsPanics if the value is an <code>Err</code>, with the provided <code>felt252</code> panic message.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.expect('no value') == 123);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::expect</code></p>
<pre><code class="language-rust">const fn expect&lt;+PanicDestruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; T</code></pre>
<h3 id="unwrap"><a class="header" href="#unwrap">unwrap</a></h3>
<p>Returns the contained <code>Ok</code> value, consuming the <code>self</code> value.  # PanicsPanics if the value is an <code>Err</code>, with a standard <code>Result::unwrap failed</code> panic message.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.unwrap() == 123);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap</code></p>
<pre><code class="language-rust">const fn unwrap&lt;+Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T</code></pre>
<h3 id="unwrap_or"><a class="header" href="#unwrap_or">unwrap_or</a></h3>
<p>Returns the contained <code>Ok</code> value or a provided default.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.unwrap_or(456) == 123);

let result: Result&lt;felt252, felt252&gt; = Err('no value');
assert!(result.unwrap_or(456) == 456);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_or</code></p>
<pre><code class="language-rust">const fn unwrap_or&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, default: T) -&gt; T</code></pre>
<h3 id="unwrap_or_default"><a class="header" href="#unwrap_or_default">unwrap_or_default</a></h3>
<p>Returns the contained <code>Ok</code> value or <code>Default::&lt;T&gt;::default()</code>.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.unwrap_or_default() == 123);

let result: Result&lt;felt252, felt252&gt; = Err('no value');
assert!(result.unwrap_or_default() == 0);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_or_default</code></p>
<pre><code class="language-rust">fn unwrap_or_default&lt;+Destruct&lt;E&gt;, +Default&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T</code></pre>
<h3 id="unwrap_or_else"><a class="header" href="#unwrap_or_else">unwrap_or_else</a></h3>
<p>Returns the contained <a href="./core-result.html#ok"><code>Ok</code></a> value or computes it from a closure.  # Examples</p>
<pre><code class="language-cairo">assert!(Ok(2).unwrap_or_else(|e: ByteArray| e.len()) == 2);
assert!(Err("foo").unwrap_or_else(|e: ByteArray| e.len()) == 3);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_or_else</code></p>
<pre><code class="language-rust">fn unwrap_or_else&lt;F, +Destruct&lt;E&gt;, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (E,)&gt;[Output: T]&gt;(
    self: Result&lt;T, E&gt;, f: F,
) -&gt; T</code></pre>
<h3 id="and"><a class="header" href="#and">and</a></h3>
<p>Returns <code>other</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Ok(2);
let y: Result&lt;ByteArray, ByteArray&gt; = Err("late error");
assert!(x.and(y) == Err("late error"));

let x: Result&lt;u32, ByteArray&gt; = Err("early error");
let y: Result&lt;ByteArray, ByteArray&gt; = Ok("foo");
assert!(x.and(y) == Err("early error"));

let x: Result&lt;u32, ByteArray&gt; = Err("not a 2");
let y: Result&lt;ByteArray, ByteArray&gt; = Err("late error");
assert!(x.and(y) == Err("not a 2"));

let x: Result&lt;u32, ByteArray&gt; = Ok(2);
let y: Result&lt;ByteArray, ByteArray&gt; = Ok("different result type");
assert!(x.and(y) == Ok("different result type"));
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::and</code></p>
<pre><code class="language-rust">fn and&lt;U, +Destruct&lt;T&gt;, +Drop&lt;E&gt;, +Drop&lt;U&gt;&gt;(self: Result&lt;T, E&gt;, other: Result&lt;U, E&gt;) -&gt; Result&lt;U, E&gt;</code></pre>
<h3 id="and_then"><a class="header" href="#and_then">and_then</a></h3>
<p>Calls <code>op</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value of <code>self</code>.This function can be used for control flow based on <code>Result</code> values.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedMul;

fn sq_then_string(x: u32) -&gt; Result&lt;ByteArray, ByteArray&gt; {
    let res = x.checked_mul(x).ok_or("overflowed");
    res.and_then(|v| Ok(format!("{}", v)))
}

let x = sq_then_string(4);
assert!(x == Ok("16"));

let y = sq_then_string(65536);
assert!(y == Err("overflowed"));
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::and_then</code></p>
<pre><code class="language-rust">fn and_then&lt;U, F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: Result&lt;U, E&gt;]&gt;(
    self: Result&lt;T, E&gt;, op: F,
) -&gt; Result&lt;U, E&gt;</code></pre>
<h3 id="or"><a class="header" href="#or">or</a></h3>
<p>Returns <code>other</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Ok(2);
let y: Result&lt;u32, ByteArray&gt; = Err("late error");
assert!(x.or(y) == Ok(2));

let x: Result&lt;u32, ByteArray&gt; = Err("early error");
let y: Result&lt;u32, ByteArray&gt; = Ok(2);
assert!(x.or(y) == Ok(2));

let x: Result&lt;u32, ByteArray&gt; = Err("not a 2");
let y: Result&lt;u32, ByteArray&gt; = Err("late error");
assert!(x.or(y) == Err("late error"));

let x: Result&lt;u32, ByteArray&gt; = Ok(2);
let y: Result&lt;u32, ByteArray&gt; = Ok(100);
assert!(x.or(y) == Ok(2));
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::or</code></p>
<pre><code class="language-rust">fn or&lt;F, +Drop&lt;T&gt;, +Drop&lt;F&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, other: Result&lt;T, F&gt;) -&gt; Result&lt;T, F&gt;</code></pre>
<h3 id="or_else"><a class="header" href="#or_else">or_else</a></h3>
<p>Calls <code>op</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value of <code>self</code>.This function can be used for control flow based on result values.  # Examples</p>
<pre><code class="language-cairo">let x: Result::&lt;u32, ByteArray&gt; = Result::&lt;u32, ByteArray&gt;::Err("bad input")
    .or_else(|_e| Ok(42));
assert!(x == Ok(42));

let y: Result::&lt;u32, ByteArray&gt; = Result::&lt;u32, ByteArray&gt;::Err("bad input")
    .or_else(|_e| Err("not 42"));
assert!(y == Err("not 42"));

let z: Result::&lt;u32, ByteArray&gt; = Result::&lt;u32, ByteArray&gt;::Ok(100)
    .or_else(|_e| Ok(42));
assert!(z == Ok(100));
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::or_else</code></p>
<pre><code class="language-rust">fn or_else&lt;F, O, +Drop&lt;O&gt;, +core::ops::FnOnce&lt;O, (E,)&gt;[Output: Result&lt;T, F&gt;]&gt;(
    self: Result&lt;T, E&gt;, op: O,
) -&gt; Result&lt;T, F&gt;</code></pre>
<h3 id="expect_err"><a class="header" href="#expect_err">expect_err</a></h3>
<p>Returns the contained <code>Err</code> value, consuming the <code>self</code> value.  # PanicsPanics if the value is an <code>Ok</code>, with the provided <code>felt252</code> panic message.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Err('no value');
assert!(result.expect_err('result is ok') == 'no value');
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::expect_err</code></p>
<pre><code class="language-rust">const fn expect_err&lt;+PanicDestruct&lt;T&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; E</code></pre>
<h3 id="unwrap_err"><a class="header" href="#unwrap_err">unwrap_err</a></h3>
<p>Returns the contained <code>Err</code> value, consuming the <code>self</code> value.  # PanicsPanics if the value is an <code>Ok</code>, with a standard <code>Result::unwrap_err failed.</code> panic message.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Err('no value');
assert!(result.unwrap_err() == 'no value');
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_err</code></p>
<pre><code class="language-rust">const fn unwrap_err&lt;+PanicDestruct&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; E</code></pre>
<h3 id="is_ok"><a class="header" href="#is_ok">is_ok</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Ok</code>.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.is_ok());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::is_ok</code></p>
<pre><code class="language-rust">fn is_ok(self: @Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="is_err"><a class="header" href="#is_err">is_err</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Err</code>.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(!result.is_err());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::is_err</code></p>
<pre><code class="language-rust">fn is_err(self: @Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="into_is_ok"><a class="header" href="#into_is_ok">into_is_ok</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Ok</code>, and consumes the value.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(result.into_is_ok());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::into_is_ok</code></p>
<pre><code class="language-rust">fn into_is_ok&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="into_is_err"><a class="header" href="#into_is_err">into_is_err</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Err</code>, and consumes the value.  # Examples</p>
<pre><code class="language-cairo">let result: Result&lt;felt252, felt252&gt; = Ok(123);
assert!(!result.into_is_err());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::into_is_err</code></p>
<pre><code class="language-rust">fn into_is_err&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="ok-2"><a class="header" href="#ok-2">ok</a></h3>
<p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.Converts <code>self</code> into an <code>Option&lt;T&gt;</code>, consuming <code>self</code>, and discarding the error, if any.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Ok(2);
assert!(x.ok() == Some(2));

let x: Result&lt;u32, ByteArray&gt; = Err("Nothing here");
assert!(x.ok().is_none());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::ok</code></p>
<pre><code class="language-rust">fn ok&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="err-2"><a class="header" href="#err-2">err</a></h3>
<p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;E&gt;</code>.Converts <code>self</code> into an <code>Option&lt;E&gt;</code>, consuming <code>self</code>, and discarding the success value, if any.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Err("Nothing here");
assert!(x.err() == Some("Nothing here"));

let x: Result&lt;u32, ByteArray&gt; = Ok(2);
assert!(x.err().is_none());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::err</code></p>
<pre><code class="language-rust">fn err&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; Option&lt;E&gt;</code></pre>
<h3 id="map-1"><a class="header" href="#map-1">map</a></h3>
<p>Maps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code> by applying a function to a contained <a href="./core-result.html#ok"><code>Ok</code></a> value, leaving an <a href="./core-result.html#err"><code>Err</code></a> value untouched.This function can be used to compose the results of two functions.  # ExamplesPrint the square of the number contained in the <code>Result</code>, otherwise print the error.</p>
<pre><code class="language-cairo">let inputs: Array&lt;Result&lt;u32, ByteArray&gt;&gt; = array![
    Ok(1), Err("error"), Ok(3), Ok(4),
];
for i in inputs {
    match i.map(|i| i * 2) {
        Ok(x) =&gt; println!("{x}"),
        Err(e) =&gt; println!("{e}"),
    }
}
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::map</code></p>
<pre><code class="language-rust">fn map&lt;U, F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U]&gt;(
    self: Result&lt;T, E&gt;, f: F,
) -&gt; Result&lt;U, E&gt;</code></pre>
<h3 id="map_or"><a class="header" href="#map_or">map_or</a></h3>
<p>Returns the provided default (if <a href="./core-result.html#err"><code>Err</code></a>), or applies a function to the contained value (if <a href="./core-result.html#ok"><code>Ok</code></a>).  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;_, ByteArray&gt; = Ok("foo");
assert!(x.map_or(42, |v: ByteArray| v.len()) == 3);

let x: Result&lt;_, ByteArray&gt; = Err("bar");
assert!(x.map_or(42, |v: ByteArray| v.len()) == 42);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::map_or</code></p>
<pre><code class="language-rust">fn map_or&lt;U, F, +Destruct&lt;E&gt;, +Destruct&lt;U&gt;, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U]&gt;(
    self: Result&lt;T, E&gt;, default: U, f: F,
) -&gt; U</code></pre>
<h3 id="map_or_else"><a class="header" href="#map_or_else">map_or_else</a></h3>
<p>Maps a <code>Result&lt;T, E&gt;</code> to <code>U</code> by applying fallback function <code>default</code> to a contained <a href="./core-result.html#err"><code>Err</code></a> value, or function <code>f</code> to a contained <a href="./core-result.html#ok"><code>Ok</code></a> value.This function can be used to unpack a successful result while handling an error.  # Examples</p>
<pre><code class="language-cairo">let k = 21;

let x: Result&lt;ByteArray, _&gt; = Ok("foo");
assert!(x.map_or_else(|_e: ByteArray| k * 2, |v: ByteArray| v.len()) == 3);

let x: Result&lt;_, ByteArray&gt; = Err("bar");
assert!(x.map_or_else(|_e: ByteArray| k * 2, |v: ByteArray| v.len()) == 42);
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::map_or_else</code></p>
<pre><code class="language-rust">fn map_or_else&lt;
    U,
    D,
    F,
    +Drop&lt;D&gt;,
    +Drop&lt;F&gt;,
    +core::ops::FnOnce&lt;D, (E,)&gt;[Output: U],
    +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U],
&gt;(
    self: Result&lt;T, E&gt;, default: D, f: F,
) -&gt; U</code></pre>
<h3 id="map_err"><a class="header" href="#map_err">map_err</a></h3>
<p>Maps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code> by applying a function to a contained <a href="./core-result.html#err"><code>Err</code></a> value, leaving an <a href="./core-result.html#ok"><code>Ok</code></a> value untouched.This function can be used to pass through a successful result while handling an error.  # Examples</p>
<pre><code class="language-cairo">let stringify  = |x: u32| -&gt; ByteArray { format!("error code: {x}") };
let x: Result&lt;u32, u32&gt; = Ok(2);
assert!(x.map_err(stringify) == Result::&lt;u32, ByteArray&gt;::Ok(2));

let x: Result&lt;u32, u32&gt; = Err(13);
assert!(x.map_err(stringify) == Err("error code: 13"));
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::map_err</code></p>
<pre><code class="language-rust">fn map_err&lt;F, O, +Drop&lt;O&gt;, +core::ops::FnOnce&lt;O, (E,)&gt;[Output: F]&gt;(
    self: Result&lt;T, E&gt;, op: O,
) -&gt; Result&lt;T, F&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optiontrait"><a class="header" href="#optiontrait">OptionTrait</a></h1>
<p>A trait for handling <code>Option&lt;T&gt;</code> related operations.</p>
<p>Fully qualified path: <code>core::option::OptionTrait</code></p>
<pre><code class="language-rust">pub trait OptionTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-41"><a class="header" href="#trait-functions-41">Trait functions</a></h2>
<h3 id="expect-1"><a class="header" href="#expect-1">expect</a></h3>
<p>Returns the contained <code>Some</code> value, consuming the <code>self</code> value.  # PanicsPanics if the option value is <code>None</code> with a custom <code>felt252</code> panic message <code>err</code>.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
let value = option.expect('no value');
assert!(value == 123);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::expect</code></p>
<pre><code class="language-rust">const fn expect(self: Option&lt;T&gt;, err: felt252) -&gt; T</code></pre>
<h3 id="unwrap-1"><a class="header" href="#unwrap-1">unwrap</a></h3>
<p>Returns the contained <code>Some</code> value, consuming the <code>self</code> value.  # PanicsPanics if the <code>self</code> value equals <code>None</code>.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
let value = option.unwrap();
assert!(value == 123);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap</code></p>
<pre><code class="language-rust">const fn unwrap(self: Option&lt;T&gt;) -&gt; T</code></pre>
<h3 id="ok_or"><a class="header" href="#ok_or">ok_or</a></h3>
<p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping <code>Some(v)</code> to <code>Ok(v)</code> and <code>None</code> to <code>Err(err)</code>.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(Some('foo').ok_or(0), Ok('foo'));

let option: Option&lt;felt252&gt; = None;
assert_eq!(option.ok_or(0), Err(0));
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::ok_or</code></p>
<pre><code class="language-rust">fn ok_or&lt;E, +Destruct&lt;E&gt;&gt;(self: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt;</code></pre>
<h3 id="ok_or_else"><a class="header" href="#ok_or_else">ok_or_else</a></h3>
<p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping <code>Some(v)</code> to <code>Ok(v)</code> and <code>None</code> to <code>Err(err())</code>.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(Some('foo').ok_or_else(|| 0), Ok('foo'));

let option: Option&lt;felt252&gt; = None;
assert_eq!(option.ok_or_else(|| 0), Err(0));
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::ok_or_else</code></p>
<pre><code class="language-rust">fn ok_or_else&lt;E, F, +Destruct&lt;E&gt;, +core::ops::FnOnce&lt;F, ()&gt;[Output: E], +Drop&lt;F&gt;&gt;(
    self: Option&lt;T&gt;, err: F,
) -&gt; Result&lt;T, E&gt;</code></pre>
<h3 id="and-1"><a class="header" href="#and-1">and</a></h3>
<p>Returns <a href="./core-option.html#none"><code>None</code></a> if the option is <a href="./core-option.html#none"><code>None</code></a>, otherwise returns <code>optb</code>.Arguments passed to <code>and</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <a href="%60and_then%60"><code>and_then</code></a>, which is lazily evaluated.  # Examples</p>
<pre><code class="language-cairo">let x = Some(2);
let y: Option&lt;ByteArray&gt; = None;
assert_eq!(x.and(y), None);

let x: Option&lt;u32&gt; = None;
let y: Option&lt;ByteArray&gt; = Some("foo");
assert_eq!(x.and(y), None);

let x = Some(2);
let y: Option&lt;ByteArray&gt; = Some("foo");
assert_eq!(x.and(y), Some("foo"));

let x: Option&lt;u32&gt; = None;
let y: Option&lt;ByteArray&gt; = None;
assert_eq!(x.and(y), None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::and</code></p>
<pre><code class="language-rust">fn and&lt;U, +Drop&lt;T&gt;, +Drop&lt;U&gt;&gt;(self: Option&lt;T&gt;, optb: Option&lt;U&gt;) -&gt; Option&lt;U&gt;</code></pre>
<h3 id="and_then-1"><a class="header" href="#and_then-1">and_then</a></h3>
<p>Returns <a href="./core-option.html#none"><code>None</code></a> if the option is <a href="./core-option.html#none"><code>None</code></a>, otherwise calls <code>f</code> with the wrapped value and returns the result.Some languages call this operation flatmap.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedMul;

let option: Option&lt;ByteArray&gt; = checked_mul(2_u32, 2_u32)
    .and_then(|v| Some(format!("{}", v)));
assert_eq!(option, Some("4"));

let option: Option&lt;ByteArray&gt; = checked_mul(65536_u32, 65536_u32)
    .and_then(|v| Some(format!("{}", v)));
assert_eq!(option, None); // overflowed!

let option: Option&lt;ByteArray&gt; = Option::&lt;u32&gt;::None
    .and_then(|v| Some(format!("{}", v)));
assert_eq!(option, None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::and_then</code></p>
<pre><code class="language-rust">fn and_then&lt;U, F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: Option&lt;U&gt;]&gt;(
    self: Option&lt;T&gt;, f: F,
) -&gt; Option&lt;U&gt;</code></pre>
<h3 id="or-1"><a class="header" href="#or-1">or</a></h3>
<p>Returns the option if it contains a value, otherwise returns <code>optb</code>.Arguments passed to <code>or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <a href="%60or_else%60"><code>or_else</code></a>, which is lazily evaluated.  # Examples</p>
<pre><code class="language-cairo">let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));

let x = Some(2);
let y = Some(100);
assert_eq!(x.or(y), Some(2));

let x: Option&lt;u32&gt; = None;
let y = None;
assert_eq!(x.or(y), None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::or</code></p>
<pre><code class="language-rust">fn or&lt;+Drop&lt;T&gt;&gt;(self: Option&lt;T&gt;, optb: Option&lt;T&gt;) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="or_else-1"><a class="header" href="#or_else-1">or_else</a></h3>
<p>Returns the option if it contains a value, otherwise calls <code>f</code> and returns the result.  # Examples</p>
<pre><code class="language-cairo">let nobody = || Option::&lt;ByteArray&gt;::None;
let vikings = || Option::&lt;ByteArray&gt;::Some("vikings");

assert_eq!(Some("barbarians").or_else(vikings), Some("barbarians"));
assert_eq!(None.or_else(vikings), Some("vikings"));
assert_eq!(None.or_else(nobody), None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::or_else</code></p>
<pre><code class="language-rust">fn or_else&lt;F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, ()&gt;[Output: Option&lt;T&gt;]&gt;(
    self: Option&lt;T&gt;, f: F,
) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="xor"><a class="header" href="#xor">xor</a></h3>
<p>Returns <a href="./core-option.html#some"><code>Some</code></a> if exactly one of <code>self</code>, <code>optb</code> is <a href="./core-option.html#some"><code>Some</code></a>, otherwise returns <a href="./core-option.html#none"><code>None</code></a>.  # Examples</p>
<pre><code class="language-cairo">let x = Some(2);
let y: Option&lt;u32&gt; = None;
assert_eq!(x.xor(y), Some(2));

let x: Option&lt;u32&gt; = None;
let y = Some(2);
assert_eq!(x.xor(y), Some(2));

let x = Some(2);
let y = Some(2);
assert_eq!(x.xor(y), None);

let x: Option&lt;u32&gt; = None;
let y: Option&lt;u32&gt; = None;
assert_eq!(x.xor(y), None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::xor</code></p>
<pre><code class="language-rust">fn xor&lt;+Drop&lt;T&gt;&gt;(self: Option&lt;T&gt;, optb: Option&lt;T&gt;) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="is_some"><a class="header" href="#is_some">is_some</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>Some</code>, <code>false</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
assert!(option.is_some());
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::is_some</code></p>
<pre><code class="language-rust">fn is_some(self: @Option&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="is_some_and"><a class="header" href="#is_some_and">is_some_and</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>Some</code> and the value inside of it matches a predicate.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(Some(2_u8).is_some_and(|x| x &gt; 1), true);
assert_eq!(Some(0_u8).is_some_and(|x| x &gt; 1), false);

let option: Option&lt;u8&gt; = None;
assert_eq!(option.is_some_and(|x| x &gt; 1), false);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::is_some_and</code></p>
<pre><code class="language-rust">fn is_some_and&lt;F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: bool]&gt;(
    self: Option&lt;T&gt;, f: F,
) -&gt; bool</code></pre>
<h3 id="is_none"><a class="header" href="#is_none">is_none</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>None</code>, <code>false</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
assert!(!option.is_none());
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::is_none</code></p>
<pre><code class="language-rust">fn is_none(self: @Option&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="is_none_or"><a class="header" href="#is_none_or">is_none_or</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>None</code> or the value inside of it matches a predicate.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(Some(2_u8).is_none_or(|x| x &gt; 1), true);
assert_eq!(Some(0_u8).is_none_or(|x| x &gt; 1), false);

let option: Option&lt;u8&gt; = None;
assert_eq!(option.is_none_or(|x| x &gt; 1), true);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::is_none_or</code></p>
<pre><code class="language-rust">fn is_none_or&lt;F, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: bool]&gt;(self: Option&lt;T&gt;, f: F) -&gt; bool</code></pre>
<h3 id="unwrap_or-1"><a class="header" href="#unwrap_or-1">unwrap_or</a></h3>
<p>Returns the contained <code>Some</code> value if <code>self</code> is <code>Some(x)</code>. Otherwise, returns the provided default.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
assert!(option.unwrap_or(456) == 123);

let option = None;
assert!(option.unwrap_or(456) == 456);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap_or</code></p>
<pre><code class="language-rust">const fn unwrap_or&lt;+Destruct&lt;T&gt;&gt;(self: Option&lt;T&gt;, default: T) -&gt; T</code></pre>
<h3 id="unwrap_or_default-1"><a class="header" href="#unwrap_or_default-1">unwrap_or_default</a></h3>
<p>Returns the contained <code>Some</code> value if <code>self</code> is <code>Some(x)</code>. Otherwise, returns <code>Default::&lt;T&gt;::default()</code>.  # Examples</p>
<pre><code class="language-cairo">let option = Some(123);
assert!(option.unwrap_or_default() == 123);

let option: Option&lt;felt252&gt; = None;
assert!(option.unwrap_or_default() == Default::default());
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap_or_default</code></p>
<pre><code class="language-rust">fn unwrap_or_default&lt;+Default&lt;T&gt;&gt;(self: Option&lt;T&gt;) -&gt; T</code></pre>
<h3 id="unwrap_or_else-1"><a class="header" href="#unwrap_or_else-1">unwrap_or_else</a></h3>
<p>Returns the contained <a href="./core-option.html#some"><code>Some</code></a> value or computes it from a closure.  # Examples</p>
<pre><code class="language-cairo">let k = 10;
assert!(Some(4).unwrap_or_else(|| 2 * k) == 4);
assert!(None.unwrap_or_else(|| 2 * k) == 20);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap_or_else</code></p>
<pre><code class="language-rust">fn unwrap_or_else&lt;F, +Drop&lt;F&gt;, impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T], +Drop&lt;func::Output&gt;&gt;(
    self: Option&lt;T&gt;, f: F,
) -&gt; T</code></pre>
<h3 id="map-2"><a class="header" href="#map-2">map</a></h3>
<p>Maps an <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function to a contained value (if <code>Some</code>) or returns <code>None</code> (if <code>None</code>).  # Examples</p>
<pre><code class="language-cairo">let maybe_some_string: Option&lt;ByteArray&gt; = Some("Hello, World!");
// `Option::map` takes self *by value*, consuming `maybe_some_string`
let maybe_some_len = maybe_some_string.map(|s: ByteArray| s.len());
assert!(maybe_some_len == Some(13));

let x: Option&lt;ByteArray&gt; = None;
assert!(x.map(|s: ByteArray| s.len()) == None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::map</code></p>
<pre><code class="language-rust">fn map&lt;U, F, +Destruct&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U]&gt;(
    self: Option&lt;T&gt;, f: F,
) -&gt; Option&lt;U&gt;</code></pre>
<h3 id="map_or-1"><a class="header" href="#map_or-1">map_or</a></h3>
<p>Returns the provided default result (if none), or applies a function to the contained value (if any).Arguments passed to <code>map_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <a href="%60map_or_else%60"><code>map_or_else</code></a>, which is lazily evaluated.  # Examples</p>
<pre><code class="language-cairo">assert_eq!(Some("foo").map_or(42, |v: ByteArray| v.len()), 3);

let x: Option&lt;ByteArray&gt; = None;
assert_eq!(x.map_or(42, |v: ByteArray| v.len()), 42);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::map_or</code></p>
<pre><code class="language-rust">fn map_or&lt;U, F, +Drop&lt;U&gt;, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U]&gt;(
    self: Option&lt;T&gt;, default: U, f: F,
) -&gt; U</code></pre>
<h3 id="map_or_else-1"><a class="header" href="#map_or_else-1">map_or_else</a></h3>
<p>Computes a default function result (if none), or applies a different function to the contained value (if any).  # Basic examples</p>
<pre><code class="language-cairo">let k = 21;

let x = Some("foo");
assert_eq!(x.map_or_else( || 2 * k, |v: ByteArray| v.len()), 3);

let x: Option&lt;ByteArray&gt; = None;
assert_eq!(x.map_or_else( || 2 * k, |v: ByteArray| v.len()), 42);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::map_or_else</code></p>
<pre><code class="language-rust">fn map_or_else&lt;
    U,
    D,
    F,
    +Drop&lt;U&gt;,
    +Drop&lt;D&gt;,
    +Drop&lt;F&gt;,
    +core::ops::FnOnce&lt;D, ()&gt;[Output: U],
    +core::ops::FnOnce&lt;F, (T,)&gt;[Output: U],
&gt;(
    self: Option&lt;T&gt;, default: D, f: F,
) -&gt; U</code></pre>
<h3 id="take"><a class="header" href="#take">take</a></h3>
<p>Takes the value out of the option, leaving a <a href="./core-option.html#none"><code>None</code></a> in its place.  # Examples</p>
<pre><code class="language-cairo">let mut x = Some(2);
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, Some(2));

let mut x: Option&lt;u32&gt; = None;
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, None);
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::take</code></p>
<pre><code class="language-rust">fn take(ref self: Option&lt;T&gt;) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="filter"><a class="header" href="#filter">filter</a></h3>
<p>Returns <a href="./core-option.html#none"><code>None</code></a> if the option is <a href="./core-option.html#none"><code>None</code></a>, otherwise calls <code>predicate</code> with the wrapped value and returns:<a href="%60Some(t)%60"><code>Some(t)</code></a> if <code>predicate</code> returns <code>true</code> (where <code>t</code> is the wrapped value), and - <a href="./core-option.html#none"><code>None</code></a> if <code>predicate</code> returns <code>false</code>.  # Example</p>
<pre><code class="language-cairo">let is_even = |n: @u32| -&gt; bool {
    *n % 2 == 0
};

assert_eq!(None.filter(is_even), None);
assert_eq!(Some(3).filter(is_even), None);
assert_eq!(Some(4).filter(is_even), Some(4));
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::filter</code></p>
<pre><code class="language-rust">fn filter&lt;P, +core::ops::FnOnce&lt;P, (@T,)&gt;[Output: bool], +Destruct&lt;T&gt;, +Destruct&lt;P&gt;&gt;(
    self: Option&lt;T&gt;, predicate: P,
) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="flatten"><a class="header" href="#flatten">flatten</a></h3>
<p>Converts from <code>Option&lt;Option&lt;T&gt;&gt;</code> to <code>Option&lt;T&gt;</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let x: Option&lt;Option&lt;u32&gt;&gt; = Some(Some(6));
assert_eq!(Some(6), x.flatten());

let x: Option&lt;Option&lt;u32&gt;&gt; = Some(None);
assert_eq!(None, x.flatten());

let x: Option&lt;Option&lt;u32&gt;&gt; = None;
assert_eq!(None, x.flatten());
</code></pre>
<p>Flattening only removes one level of nesting at a time:</p>
<pre><code class="language-cairo">let x: Option&lt;Option&lt;Option&lt;u32&gt;&gt;&gt; = Some(Some(Some(6)));
assert_eq!(Some(Some(6)), x.flatten());
assert_eq!(Some(6), x.flatten().flatten());
</code></pre>
<p>Fully qualified path: <code>core::option::OptionTrait::flatten</code></p>
<pre><code class="language-rust">fn flatten(self: Option&lt;Option&lt;T&gt;&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone-1"><a class="header" href="#clone-1">Clone</a></h1>
<p>A common trait for the ability to explicitly duplicate an object.Differs from <code>Copy</code> in that <code>Copy</code> is implicit and inexpensive, while <code>Clone</code> is always explicit and may or may not be expensive.Since <code>Clone</code> is more general than <code>Copy</code>, you can automatically make anything <code>Copy</code> be <code>Clone</code> as well.  ## DerivableThis trait can be used with <code>#[derive]</code> if all fields are <code>Clone</code>. The <code>derive</code>d implementation of <code>Clone</code> calls <code>clone</code> on each field.</p>
<p>Fully qualified path: <code>core::clone::Clone</code></p>
<pre><code class="language-rust">pub trait Clone&lt;T&gt;</code></pre>
<h2 id="trait-functions-42"><a class="header" href="#trait-functions-42">Trait functions</a></h2>
<h3 id="clone-2"><a class="header" href="#clone-2">clone</a></h3>
<p>Returns a copy of the value.  # Examples</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
assert!(arr == arr.clone());
</code></pre>
<p>Fully qualified path: <code>core::clone::Clone::clone</code></p>
<pre><code class="language-rust">fn clone(self: @T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstatetrait"><a class="header" href="#ecstatetrait">EcStateTrait</a></h1>
<p>Fully qualified path: <code>core::ec::EcStateTrait</code></p>
<pre><code class="language-rust">pub trait EcStateTrait</code></pre>
<h2 id="trait-functions-43"><a class="header" href="#trait-functions-43">Trait functions</a></h2>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<p>Initializes an EC computation with the zero point.  # Examples</p>
<pre><code class="language-cairo">let mut state = EcStateTrait::init();
</code></pre>
<p>Fully qualified path: <code>core::ec::EcStateTrait::init</code></p>
<pre><code class="language-rust">fn init() -&gt; EcState nopanic</code></pre>
<h3 id="add-2"><a class="header" href="#add-2">add</a></h3>
<p>Adds a point to the computation.  # Arguments<code>p</code> - The non-zero point to add</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::add</code></p>
<pre><code class="language-rust">fn add(ref self: EcState, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="sub-2"><a class="header" href="#sub-2">sub</a></h3>
<p>Subtracts a point to the computation.  # Arguments<code>p</code> - The non-zero point to subtract</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::sub</code></p>
<pre><code class="language-rust">fn sub(ref self: EcState, p: NonZeroEcPoint)</code></pre>
<h3 id="add_mul"><a class="header" href="#add_mul">add_mul</a></h3>
<p>Adds the product <code>p * scalar</code> to the state.  # Arguments<code>scalar</code> - The scalar to multiply the point by * <code>p</code> - The non-zero point to multiply and add</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::add_mul</code></p>
<pre><code class="language-rust">fn add_mul(ref self: EcState, scalar: felt252, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="finalize_nz"><a class="header" href="#finalize_nz">finalize_nz</a></h3>
<p>Finalizes the EC computation and returns the result as a non-zero point.  # Returns<code>Option&lt;NonZeroEcPoint&gt;</code> - The resulting point, or None if the result is the zero point  # PanicsPanics if the result is the point at infinity.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::finalize_nz</code></p>
<pre><code class="language-rust">fn finalize_nz(self: EcState) -&gt; Option&lt;NonZeroEcPoint&gt; nopanic</code></pre>
<h3 id="finalize-1"><a class="header" href="#finalize-1">finalize</a></h3>
<p>Finalizes the EC computation and returns the result.Returns the zero point if the computation results in the point at infinity.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: EcState) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpointtrait"><a class="header" href="#ecpointtrait">EcPointTrait</a></h1>
<p>Fully qualified path: <code>core::ec::EcPointTrait</code></p>
<pre><code class="language-rust">pub trait EcPointTrait</code></pre>
<h2 id="trait-functions-44"><a class="header" href="#trait-functions-44">Trait functions</a></h2>
<h3 id="new-3"><a class="header" href="#new-3">new</a></h3>
<p>Creates a new EC point from its (x, y) coordinates.  # Arguments<code>x</code> - The x-coordinate of the point * <code>y</code> - The y-coordinate of the point  # ReturnsReturns <code>None</code> if the point (x, y) is not on the curve.  # Examples</p>
<pre><code class="language-cairo">let point = EcPointTrait::new(
    x: 336742005567258698661916498343089167447076063081786685068305785816009957563,
    y: 1706004133033694959518200210163451614294041810778629639790706933324248611779,
).unwrap();
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new</code></p>
<pre><code class="language-rust">fn new(x: felt252, y: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz"><a class="header" href="#new_nz">new_nz</a></h3>
<p>Creates a new NonZero EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_nz</code></p>
<pre><code class="language-rust">fn new_nz(x: felt252, y: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="new_from_x"><a class="header" href="#new_from_x">new_from_x</a></h3>
<p>Creates a new EC point from its x coordinate.  # Arguments<code>x</code> - The x-coordinate of the point  # ReturnsReturns <code>None</code> if no point with the given x-coordinate exists on the curve.  # PanicsPanics if <code>x</code> is 0, as this would be the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let valid = EcPointTrait::new_from_x(1);
assert!(valid.is_some());
let invalid = EcPointTrait::new_from_x(0);
assert!(invalid.is_none());
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_from_x</code></p>
<pre><code class="language-rust">fn new_from_x(x: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz_from_x"><a class="header" href="#new_nz_from_x">new_nz_from_x</a></h3>
<p>Creates a new NonZero EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_nz_from_x</code></p>
<pre><code class="language-rust">fn new_nz_from_x(x: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="coordinates"><a class="header" href="#coordinates">coordinates</a></h3>
<p>Returns the coordinates of the EC point.  # ReturnsA tuple containing the (x, y) coordinates of the point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let point_nz = EcPointTrait::new_nz_from_x(1).unwrap();
let (x, _y) = point_nz.coordinates();
assert!(x == 1);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointTrait::coordinates</code></p>
<pre><code class="language-rust">fn coordinates(self: NonZeroEcPoint) -&gt; (felt252, felt252)</code></pre>
<h3 id="x"><a class="header" href="#x">x</a></h3>
<p>Returns the x coordinate of the EC point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let point_nz = EcPointTrait::new_nz_from_x(1).unwrap();
let x = point_nz.x();
assert!(x == 1);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointTrait::x</code></p>
<pre><code class="language-rust">fn x(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="y"><a class="header" href="#y">y</a></h3>
<p>Returns the y coordinate of the EC point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let gen_point =
EcPointTrait::new_nz_from_x(0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca).unwrap();
let y = gen_point.y();
assert!(y == 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointTrait::y</code></p>
<pre><code class="language-rust">fn y(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="mul-2"><a class="header" href="#mul-2">mul</a></h3>
<p>Computes the product of an EC point by the given scalar.  # Arguments<code>scalar</code> - The scalar to multiply the point by  # ReturnsThe resulting point after scalar multiplication.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::mul</code></p>
<pre><code class="language-rust">fn mul(self: EcPoint, scalar: felt252) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numericliteral"><a class="header" href="#numericliteral">NumericLiteral</a></h1>
<p>Fully qualified path: <code>core::integer::NumericLiteral</code></p>
<pre><code class="language-rust">pub trait NumericLiteral&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boundedint"><a class="header" href="#boundedint">BoundedInt</a></h1>
<p>Trait for getting the maximal and minimal values of an integer type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt</code></p>
<pre><code class="language-rust">pub trait BoundedInt&lt;T&gt;</code></pre>
<h2 id="trait-functions-45"><a class="header" href="#trait-functions-45">Trait functions</a></h2>
<h3 id="min-1"><a class="header" href="#min-1">min</a></h3>
<p>Returns the minimal value of the type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt::min</code></p>
<pre><code class="language-rust">fn min() -&gt; T nopanic</code></pre>
<h3 id="max-1"><a class="header" href="#max-1">max</a></h3>
<p>Returns the maximal value of the type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt::max</code></p>
<pre><code class="language-rust">fn max() -&gt; T nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-1"><a class="header" href="#zero-1">Zero</a></h1>
<p>Defines an additive identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a + 0 = a       âˆ€ a âˆˆ T
0 + a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero</code></p>
<pre><code class="language-rust">pub trait Zero&lt;T&gt;</code></pre>
<h2 id="trait-functions-46"><a class="header" href="#trait-functions-46">Trait functions</a></h2>
<h3 id="zero-2"><a class="header" href="#zero-2">zero</a></h3>
<p>Returns the additive identity element of <code>T</code>, <code>0</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(Zero::&lt;u32&gt;::zero() == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; T</code></pre>
<h3 id="is_zero"><a class="header" href="#is_zero">is_zero</a></h3>
<p>Returns true if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(0.is_zero());
assert!(!5.is_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_zero"><a class="header" href="#is_non_zero">is_non_zero</a></h3>
<p>Returns false if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(5.is_non_zero());
assert!(!0.is_non_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-1"><a class="header" href="#one-1">One</a></h1>
<p>Defines a multiplicative identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a * 1 = a       âˆ€ a âˆˆ T
1 * a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One</code></p>
<pre><code class="language-rust">pub trait One&lt;T&gt;</code></pre>
<h2 id="trait-functions-47"><a class="header" href="#trait-functions-47">Trait functions</a></h2>
<h3 id="one-2"><a class="header" href="#one-2">one</a></h3>
<p>Returns the multiplicative identity element of <code>T</code>, <code>1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(One::&lt;u32&gt;::one() == 1);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::one</code></p>
<pre><code class="language-rust">fn one() -&gt; T</code></pre>
<h3 id="is_one"><a class="header" href="#is_one">is_one</a></h3>
<p>Returns true if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(1.is_one());
assert!(!0.is_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_one</code></p>
<pre><code class="language-rust">fn is_one(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_one"><a class="header" href="#is_non_one">is_non_one</a></h3>
<p>Returns false if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(0.is_non_one());
assert!(!1.is_non_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_non_one</code></p>
<pre><code class="language-rust">fn is_non_one(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitsize"><a class="header" href="#bitsize">BitSize</a></h1>
<p>A trait used to retrieve the size of a type in bits.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize</code></p>
<pre><code class="language-rust">pub trait BitSize&lt;T&gt;</code></pre>
<h2 id="trait-functions-48"><a class="header" href="#trait-functions-48">Trait functions</a></h2>
<h3 id="bits"><a class="header" href="#bits">bits</a></h3>
<p>Returns the bit size of <code>T</code> as a <code>usize</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

let bits = BitSize::&lt;u8&gt;::bits();
assert!(bits == 8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize::bits</code></p>
<pre><code class="language-rust">fn bits() -&gt; usize</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded"><a class="header" href="#bounded">Bounded</a></h1>
<p>A trait defining minimum and maximum bounds for numeric types.This trait only supports types that can have constant values.</p>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded</code></p>
<pre><code class="language-rust">pub trait Bounded&lt;T&gt;</code></pre>
<h2 id="trait-constants"><a class="header" href="#trait-constants">Trait constants</a></h2>
<h3 id="min-2"><a class="header" href="#min-2">MIN</a></h3>
<p>Returns the minimum value for type <code>T</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Bounded;

let min = Bounded::&lt;u8&gt;::MIN;
assert!(min == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded::MIN</code></p>
<pre><code class="language-rust">const MIN: T;</code></pre>
<h3 id="max-2"><a class="header" href="#max-2">MAX</a></h3>
<p>Returns the maximum value for type <code>T</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Bounded;

let max = Bounded::&lt;u8&gt;::MAX;
assert!(max == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded::MAX</code></p>
<pre><code class="language-rust">const MAX: T;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedadd"><a class="header" href="#checkedadd">CheckedAdd</a></h1>
<p>Performs addition that returns <code>None</code> instead of wrapping around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedAdd;

let result = 1_u8.checked_add(2);
assert!(result == Some(3));

let result = 255_u8.checked_add(1);
assert!(result == None); // Overflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd</code></p>
<pre><code class="language-rust">pub trait CheckedAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-49"><a class="header" href="#trait-functions-49">Trait functions</a></h2>
<h3 id="checked_add"><a class="header" href="#checked_add">checked_add</a></h3>
<p>Adds two numbers, checking for overflow. If overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd::checked_add</code></p>
<pre><code class="language-rust">fn checked_add(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedmul"><a class="header" href="#checkedmul">CheckedMul</a></h1>
<p>Performs multiplication that returns <code>None</code> instead of wrapping around on underflow or overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedMul;

let result = 10_u8.checked_mul(20);
assert!(result == Some(200));

let result = 10_u8.checked_mul(30);
assert!(result == None); // Overflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul</code></p>
<pre><code class="language-rust">pub trait CheckedMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-50"><a class="header" href="#trait-functions-50">Trait functions</a></h2>
<h3 id="checked_mul"><a class="header" href="#checked_mul">checked_mul</a></h3>
<p>Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul::checked_mul</code></p>
<pre><code class="language-rust">fn checked_mul(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedsub"><a class="header" href="#checkedsub">CheckedSub</a></h1>
<p>Performs subtraction that returns <code>None</code> instead of wrapping around on underflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedSub;

let result = 1_u8.checked_sub(1);
assert!(result == Some(0));

let result = 1_u8.checked_sub(2);
assert!(result == None); // Underflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub</code></p>
<pre><code class="language-rust">pub trait CheckedSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-51"><a class="header" href="#trait-functions-51">Trait functions</a></h2>
<h3 id="checked_sub"><a class="header" href="#checked_sub">checked_sub</a></h3>
<p>Subtracts two numbers, checking for underflow. If underflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub::checked_sub</code></p>
<pre><code class="language-rust">fn checked_sub(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingadd"><a class="header" href="#overflowingadd">OverflowingAdd</a></h1>
<p>Performs addition with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingAdd;

let (result, is_overflow) = 1_u8.overflowing_add(255_u8);
assert!(result == 0);
assert!(is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd</code></p>
<pre><code class="language-rust">pub trait OverflowingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-52"><a class="header" href="#trait-functions-52">Trait functions</a></h2>
<h3 id="overflowing_add"><a class="header" href="#overflowing_add">overflowing_add</a></h3>
<p>Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd::overflowing_add</code></p>
<pre><code class="language-rust">fn overflowing_add(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingmul"><a class="header" href="#overflowingmul">OverflowingMul</a></h1>
<p>Performs multiplication with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingMul;

let (result, is_overflow) = 1_u8.overflowing_mul(2_u8);
assert!(result == 2);
assert!(!is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul</code></p>
<pre><code class="language-rust">pub trait OverflowingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-53"><a class="header" href="#trait-functions-53">Trait functions</a></h2>
<h3 id="overflowing_mul"><a class="header" href="#overflowing_mul">overflowing_mul</a></h3>
<p>Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul::overflowing_mul</code></p>
<pre><code class="language-rust">fn overflowing_mul(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingsub"><a class="header" href="#overflowingsub">OverflowingSub</a></h1>
<p>Performs subtraction with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingSub;

let (result, is_underflow) = 1_u8.overflowing_sub(2_u8);
assert!(result == 255);
assert!(is_underflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub</code></p>
<pre><code class="language-rust">pub trait OverflowingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-54"><a class="header" href="#trait-functions-54">Trait functions</a></h2>
<h3 id="overflowing_sub"><a class="header" href="#overflowing_sub">overflowing_sub</a></h3>
<p>Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub::overflowing_sub</code></p>
<pre><code class="language-rust">fn overflowing_sub(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow-1"><a class="header" href="#pow-1">Pow</a></h1>
<p>Raises a value to the power of <code>exp</code>.Note that <code>0â°</code> (<code>pow(0, 0)</code>) returns <code>1</code>. Mathematically this is undefined.  # PanicsPanics if the result of the exponentiation operation overflows the output type.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

assert!(2_i8.pow(4_usize) == 16_i8);
assert!(6_u8.pow(3_usize) == 216_u8);
assert!(0_u8.pow(0_usize) == 1_u8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow</code></p>
<pre><code class="language-rust">pub trait Pow&lt;Base, Exp&gt;</code></pre>
<h2 id="trait-functions-55"><a class="header" href="#trait-functions-55">Trait functions</a></h2>
<h3 id="pow-2"><a class="header" href="#pow-2">pow</a></h3>
<p>Returns <code>self</code> to the power <code>exp</code>.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::pow</code></p>
<pre><code class="language-rust">fn pow(self: Base, exp: Exp) -&gt; Self::Output</code></pre>
<h2 id="trait-types-1"><a class="header" href="#trait-types-1">Trait types</a></h2>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>The type of the result of the power calculation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingadd"><a class="header" href="#saturatingadd">SaturatingAdd</a></h1>
<p>Performs addition that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingAdd;

assert!(255_u8.saturating_add(1_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd</code></p>
<pre><code class="language-rust">pub trait SaturatingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-56"><a class="header" href="#trait-functions-56">Trait functions</a></h2>
<h3 id="saturating_add"><a class="header" href="#saturating_add">saturating_add</a></h3>
<p>Saturating addition. Computes <code>self + other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd::saturating_add</code></p>
<pre><code class="language-rust">fn saturating_add(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingmul"><a class="header" href="#saturatingmul">SaturatingMul</a></h1>
<p>Performs multiplication that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingMul;

assert!(100_u8.saturating_mul(3_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul</code></p>
<pre><code class="language-rust">pub trait SaturatingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-57"><a class="header" href="#trait-functions-57">Trait functions</a></h2>
<h3 id="saturating_mul"><a class="header" href="#saturating_mul">saturating_mul</a></h3>
<p>Saturating multiplication. Computes <code>self * other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul::saturating_mul</code></p>
<pre><code class="language-rust">fn saturating_mul(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingsub"><a class="header" href="#saturatingsub">SaturatingSub</a></h1>
<p>Performs subtraction that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingSub;

assert!(1_u8.saturating_sub(2_u8) == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub</code></p>
<pre><code class="language-rust">pub trait SaturatingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-58"><a class="header" href="#trait-functions-58">Trait functions</a></h2>
<h3 id="saturating_sub"><a class="header" href="#saturating_sub">saturating_sub</a></h3>
<p>Saturating subtraction. Computes <code>self - other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub::saturating_sub</code></p>
<pre><code class="language-rust">fn saturating_sub(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqrt"><a class="header" href="#sqrt">Sqrt</a></h1>
<p>A trait for computing the square root of a number.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Sqrt;

assert!(9_u8.sqrt() == 3);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt</code></p>
<pre><code class="language-rust">pub trait Sqrt&lt;T&gt;</code></pre>
<h2 id="trait-functions-59"><a class="header" href="#trait-functions-59">Trait functions</a></h2>
<h3 id="sqrt-1"><a class="header" href="#sqrt-1">sqrt</a></h3>
<p>Computes the square root of a number.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::sqrt</code></p>
<pre><code class="language-rust">fn sqrt(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-2"><a class="header" href="#trait-types-2">Trait types</a></h2>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>The type of the result of the square root operation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widemul"><a class="header" href="#widemul">WideMul</a></h1>
<p>A trait for types that can be multiplied together to produce a wider type.This trait enables multiplication operations where the result type has double the bit width of the input types, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideMul;

let a: u8 = 255; // maximum value for u8
let b: u8 = 255;
let result: u16 = a.wide_mul(b);
assert!(result == 65025);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul</code></p>
<pre><code class="language-rust">pub trait WideMul&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-60"><a class="header" href="#trait-functions-60">Trait functions</a></h2>
<h3 id="wide_mul"><a class="header" href="#wide_mul">wide_mul</a></h3>
<p>Multiply two values together, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::wide_mul</code></p>
<pre><code class="language-rust">fn wide_mul(self: Lhs, other: Rhs) -&gt; Self::Target</code></pre>
<h2 id="trait-types-3"><a class="header" href="#trait-types-3">Trait types</a></h2>
<h3 id="target-1"><a class="header" href="#target-1">Target</a></h3>
<p>The type of the result of the multiplication.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widesquare"><a class="header" href="#widesquare">WideSquare</a></h1>
<p>A trait for a type that can be squared to produce a wider type.This trait enables squaring operations where the result type has double the bit width of the input type, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideSquare;

let a: u8 = 16;
let result: u16 = a.wide_square();
assert!(result == 256);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare</code></p>
<pre><code class="language-rust">pub trait WideSquare&lt;T&gt;</code></pre>
<h2 id="trait-functions-61"><a class="header" href="#trait-functions-61">Trait functions</a></h2>
<h3 id="wide_square"><a class="header" href="#wide_square">wide_square</a></h3>
<p>Calculates the square, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::wide_square</code></p>
<pre><code class="language-rust">fn wide_square(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-4"><a class="header" href="#trait-types-4">Trait types</a></h2>
<h3 id="target-2"><a class="header" href="#target-2">Target</a></h3>
<p>The type of the result of the square.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingadd"><a class="header" href="#wrappingadd">WrappingAdd</a></h1>
<p>Performs addition that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingAdd;

let result = 255_u8.wrapping_add(1);
assert!(result == 0);

let result = 100_u8.wrapping_add(200);
assert!(result == 44); // (100 + 200) % 256 = 44
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd</code></p>
<pre><code class="language-rust">pub trait WrappingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-62"><a class="header" href="#trait-functions-62">Trait functions</a></h2>
<h3 id="wrapping_add"><a class="header" href="#wrapping_add">wrapping_add</a></h3>
<p>Wrapping (modular) addition. Computes <code>self + other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd::wrapping_add</code></p>
<pre><code class="language-rust">fn wrapping_add(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingmul"><a class="header" href="#wrappingmul">WrappingMul</a></h1>
<p>Performs multiplication that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingMul;

let result = 10_u8.wrapping_mul(30);
assert!(result == 44); // (10 * 30) % 256 = 44

let result = 200_u8.wrapping_mul(2);
assert!(result == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul</code></p>
<pre><code class="language-rust">pub trait WrappingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-63"><a class="header" href="#trait-functions-63">Trait functions</a></h2>
<h3 id="wrapping_mul"><a class="header" href="#wrapping_mul">wrapping_mul</a></h3>
<p>Wrapping (modular) multiplication. Computes <code>self * other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul::wrapping_mul</code></p>
<pre><code class="language-rust">fn wrapping_mul(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingsub"><a class="header" href="#wrappingsub">WrappingSub</a></h1>
<p>Performs subtraction that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingSub;

let result = 0_u8.wrapping_sub(1);
assert!(result == 255);

let result = 100_u8.wrapping_sub(150);
assert!(result == 206);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub</code></p>
<pre><code class="language-rust">pub trait WrappingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-64"><a class="header" href="#trait-functions-64">Trait functions</a></h2>
<h3 id="wrapping_sub"><a class="header" href="#wrapping_sub">wrapping_sub</a></h3>
<p>Wrapping (modular) subtraction. Computes <code>self - other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub::wrapping_sub</code></p>
<pre><code class="language-rust">fn wrapping_sub(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-3"><a class="header" href="#zero-3">Zero</a></h1>
<p>Defines an additive identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a + 0 = a       âˆ€ a âˆˆ T
0 + a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero</code></p>
<pre><code class="language-rust">pub trait Zero&lt;T&gt;</code></pre>
<h2 id="trait-functions-65"><a class="header" href="#trait-functions-65">Trait functions</a></h2>
<h3 id="zero-4"><a class="header" href="#zero-4">zero</a></h3>
<p>Returns the additive identity element of <code>T</code>, <code>0</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(Zero::&lt;u32&gt;::zero() == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; T</code></pre>
<h3 id="is_zero-1"><a class="header" href="#is_zero-1">is_zero</a></h3>
<p>Returns true if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(0.is_zero());
assert!(!5.is_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_zero-1"><a class="header" href="#is_non_zero-1">is_non_zero</a></h3>
<p>Returns false if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(5.is_non_zero());
assert!(!0.is_non_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-3"><a class="header" href="#one-3">One</a></h1>
<p>Defines a multiplicative identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a * 1 = a       âˆ€ a âˆˆ T
1 * a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One</code></p>
<pre><code class="language-rust">pub trait One&lt;T&gt;</code></pre>
<h2 id="trait-functions-66"><a class="header" href="#trait-functions-66">Trait functions</a></h2>
<h3 id="one-4"><a class="header" href="#one-4">one</a></h3>
<p>Returns the multiplicative identity element of <code>T</code>, <code>1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(One::&lt;u32&gt;::one() == 1);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::one</code></p>
<pre><code class="language-rust">fn one() -&gt; T</code></pre>
<h3 id="is_one-1"><a class="header" href="#is_one-1">is_one</a></h3>
<p>Returns true if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(1.is_one());
assert!(!0.is_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_one</code></p>
<pre><code class="language-rust">fn is_one(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_one-1"><a class="header" href="#is_non_one-1">is_non_one</a></h3>
<p>Returns false if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(0.is_non_one());
assert!(!1.is_non_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_non_one</code></p>
<pre><code class="language-rust">fn is_non_one(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitsize-1"><a class="header" href="#bitsize-1">BitSize</a></h1>
<p>A trait used to retrieve the size of a type in bits.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize</code></p>
<pre><code class="language-rust">pub trait BitSize&lt;T&gt;</code></pre>
<h2 id="trait-functions-67"><a class="header" href="#trait-functions-67">Trait functions</a></h2>
<h3 id="bits-1"><a class="header" href="#bits-1">bits</a></h3>
<p>Returns the bit size of <code>T</code> as a <code>usize</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

let bits = BitSize::&lt;u8&gt;::bits();
assert!(bits == 8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize::bits</code></p>
<pre><code class="language-rust">fn bits() -&gt; usize</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedadd-1"><a class="header" href="#checkedadd-1">CheckedAdd</a></h1>
<p>Performs addition that returns <code>None</code> instead of wrapping around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedAdd;

let result = 1_u8.checked_add(2);
assert!(result == Some(3));

let result = 255_u8.checked_add(1);
assert!(result == None); // Overflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd</code></p>
<pre><code class="language-rust">pub trait CheckedAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-68"><a class="header" href="#trait-functions-68">Trait functions</a></h2>
<h3 id="checked_add-1"><a class="header" href="#checked_add-1">checked_add</a></h3>
<p>Adds two numbers, checking for overflow. If overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd::checked_add</code></p>
<pre><code class="language-rust">fn checked_add(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedsub-1"><a class="header" href="#checkedsub-1">CheckedSub</a></h1>
<p>Performs subtraction that returns <code>None</code> instead of wrapping around on underflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedSub;

let result = 1_u8.checked_sub(1);
assert!(result == Some(0));

let result = 1_u8.checked_sub(2);
assert!(result == None); // Underflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub</code></p>
<pre><code class="language-rust">pub trait CheckedSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-69"><a class="header" href="#trait-functions-69">Trait functions</a></h2>
<h3 id="checked_sub-1"><a class="header" href="#checked_sub-1">checked_sub</a></h3>
<p>Subtracts two numbers, checking for underflow. If underflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub::checked_sub</code></p>
<pre><code class="language-rust">fn checked_sub(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedmul-1"><a class="header" href="#checkedmul-1">CheckedMul</a></h1>
<p>Performs multiplication that returns <code>None</code> instead of wrapping around on underflow or overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::CheckedMul;

let result = 10_u8.checked_mul(20);
assert!(result == Some(200));

let result = 10_u8.checked_mul(30);
assert!(result == None); // Overflow
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul</code></p>
<pre><code class="language-rust">pub trait CheckedMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-70"><a class="header" href="#trait-functions-70">Trait functions</a></h2>
<h3 id="checked_mul-1"><a class="header" href="#checked_mul-1">checked_mul</a></h3>
<p>Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul::checked_mul</code></p>
<pre><code class="language-rust">fn checked_mul(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingadd-1"><a class="header" href="#overflowingadd-1">OverflowingAdd</a></h1>
<p>Performs addition with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingAdd;

let (result, is_overflow) = 1_u8.overflowing_add(255_u8);
assert!(result == 0);
assert!(is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd</code></p>
<pre><code class="language-rust">pub trait OverflowingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-71"><a class="header" href="#trait-functions-71">Trait functions</a></h2>
<h3 id="overflowing_add-1"><a class="header" href="#overflowing_add-1">overflowing_add</a></h3>
<p>Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd::overflowing_add</code></p>
<pre><code class="language-rust">fn overflowing_add(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingsub-1"><a class="header" href="#overflowingsub-1">OverflowingSub</a></h1>
<p>Performs subtraction with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingSub;

let (result, is_underflow) = 1_u8.overflowing_sub(2_u8);
assert!(result == 255);
assert!(is_underflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub</code></p>
<pre><code class="language-rust">pub trait OverflowingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-72"><a class="header" href="#trait-functions-72">Trait functions</a></h2>
<h3 id="overflowing_sub-1"><a class="header" href="#overflowing_sub-1">overflowing_sub</a></h3>
<p>Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub::overflowing_sub</code></p>
<pre><code class="language-rust">fn overflowing_sub(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingmul-1"><a class="header" href="#overflowingmul-1">OverflowingMul</a></h1>
<p>Performs multiplication with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingMul;

let (result, is_overflow) = 1_u8.overflowing_mul(2_u8);
assert!(result == 2);
assert!(!is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul</code></p>
<pre><code class="language-rust">pub trait OverflowingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-73"><a class="header" href="#trait-functions-73">Trait functions</a></h2>
<h3 id="overflowing_mul-1"><a class="header" href="#overflowing_mul-1">overflowing_mul</a></h3>
<p>Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul::overflowing_mul</code></p>
<pre><code class="language-rust">fn overflowing_mul(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow-3"><a class="header" href="#pow-3">Pow</a></h1>
<p>Raises a value to the power of <code>exp</code>.Note that <code>0â°</code> (<code>pow(0, 0)</code>) returns <code>1</code>. Mathematically this is undefined.  # PanicsPanics if the result of the exponentiation operation overflows the output type.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

assert!(2_i8.pow(4_usize) == 16_i8);
assert!(6_u8.pow(3_usize) == 216_u8);
assert!(0_u8.pow(0_usize) == 1_u8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow</code></p>
<pre><code class="language-rust">pub trait Pow&lt;Base, Exp&gt;</code></pre>
<h2 id="trait-functions-74"><a class="header" href="#trait-functions-74">Trait functions</a></h2>
<h3 id="pow-4"><a class="header" href="#pow-4">pow</a></h3>
<p>Returns <code>self</code> to the power <code>exp</code>.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::pow</code></p>
<pre><code class="language-rust">fn pow(self: Base, exp: Exp) -&gt; Self::Output</code></pre>
<h2 id="trait-types-5"><a class="header" href="#trait-types-5">Trait types</a></h2>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>The type of the result of the power calculation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingadd-1"><a class="header" href="#saturatingadd-1">SaturatingAdd</a></h1>
<p>Performs addition that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingAdd;

assert!(255_u8.saturating_add(1_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd</code></p>
<pre><code class="language-rust">pub trait SaturatingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-75"><a class="header" href="#trait-functions-75">Trait functions</a></h2>
<h3 id="saturating_add-1"><a class="header" href="#saturating_add-1">saturating_add</a></h3>
<p>Saturating addition. Computes <code>self + other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd::saturating_add</code></p>
<pre><code class="language-rust">fn saturating_add(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingsub-1"><a class="header" href="#saturatingsub-1">SaturatingSub</a></h1>
<p>Performs subtraction that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingSub;

assert!(1_u8.saturating_sub(2_u8) == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub</code></p>
<pre><code class="language-rust">pub trait SaturatingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-76"><a class="header" href="#trait-functions-76">Trait functions</a></h2>
<h3 id="saturating_sub-1"><a class="header" href="#saturating_sub-1">saturating_sub</a></h3>
<p>Saturating subtraction. Computes <code>self - other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub::saturating_sub</code></p>
<pre><code class="language-rust">fn saturating_sub(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingmul-1"><a class="header" href="#saturatingmul-1">SaturatingMul</a></h1>
<p>Performs multiplication that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingMul;

assert!(100_u8.saturating_mul(3_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul</code></p>
<pre><code class="language-rust">pub trait SaturatingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-77"><a class="header" href="#trait-functions-77">Trait functions</a></h2>
<h3 id="saturating_mul-1"><a class="header" href="#saturating_mul-1">saturating_mul</a></h3>
<p>Saturating multiplication. Computes <code>self * other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul::saturating_mul</code></p>
<pre><code class="language-rust">fn saturating_mul(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingadd-1"><a class="header" href="#wrappingadd-1">WrappingAdd</a></h1>
<p>Performs addition that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingAdd;

let result = 255_u8.wrapping_add(1);
assert!(result == 0);

let result = 100_u8.wrapping_add(200);
assert!(result == 44); // (100 + 200) % 256 = 44
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd</code></p>
<pre><code class="language-rust">pub trait WrappingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-78"><a class="header" href="#trait-functions-78">Trait functions</a></h2>
<h3 id="wrapping_add-1"><a class="header" href="#wrapping_add-1">wrapping_add</a></h3>
<p>Wrapping (modular) addition. Computes <code>self + other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd::wrapping_add</code></p>
<pre><code class="language-rust">fn wrapping_add(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingsub-1"><a class="header" href="#wrappingsub-1">WrappingSub</a></h1>
<p>Performs subtraction that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingSub;

let result = 0_u8.wrapping_sub(1);
assert!(result == 255);

let result = 100_u8.wrapping_sub(150);
assert!(result == 206);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub</code></p>
<pre><code class="language-rust">pub trait WrappingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-79"><a class="header" href="#trait-functions-79">Trait functions</a></h2>
<h3 id="wrapping_sub-1"><a class="header" href="#wrapping_sub-1">wrapping_sub</a></h3>
<p>Wrapping (modular) subtraction. Computes <code>self - other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub::wrapping_sub</code></p>
<pre><code class="language-rust">fn wrapping_sub(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingmul-1"><a class="header" href="#wrappingmul-1">WrappingMul</a></h1>
<p>Performs multiplication that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingMul;

let result = 10_u8.wrapping_mul(30);
assert!(result == 44); // (10 * 30) % 256 = 44

let result = 200_u8.wrapping_mul(2);
assert!(result == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul</code></p>
<pre><code class="language-rust">pub trait WrappingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-80"><a class="header" href="#trait-functions-80">Trait functions</a></h2>
<h3 id="wrapping_mul-1"><a class="header" href="#wrapping_mul-1">wrapping_mul</a></h3>
<p>Wrapping (modular) multiplication. Computes <code>self * other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul::wrapping_mul</code></p>
<pre><code class="language-rust">fn wrapping_mul(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addassign"><a class="header" href="#addassign">AddAssign</a></h1>
<p>The addition assignment operator <code>+=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::AddAssign</code></p>
<pre><code class="language-rust">pub trait AddAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-81"><a class="header" href="#trait-functions-81">Trait functions</a></h2>
<h3 id="add_assign"><a class="header" href="#add_assign">add_assign</a></h3>
<p>Performs the <code>+=</code> operation.  # Examples</p>
<pre><code class="language-cairo">let mut x: u8 = 3;
x += x;
assert!(x == 6);
</code></pre>
<p>Fully qualified path: <code>core::ops::arith::AddAssign::add_assign</code></p>
<pre><code class="language-rust">fn add_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divassign"><a class="header" href="#divassign">DivAssign</a></h1>
<p>The division assignment operator <code>/=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::DivAssign</code></p>
<pre><code class="language-rust">pub trait DivAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-82"><a class="header" href="#trait-functions-82">Trait functions</a></h2>
<h3 id="div_assign"><a class="header" href="#div_assign">div_assign</a></h3>
<p>Performs the <code>/=</code> operation.  # Examples</p>
<pre><code class="language-cairo">let mut x: u8 = 3;
x /= x;
assert!(x == 1);
</code></pre>
<p>Fully qualified path: <code>core::ops::arith::DivAssign::div_assign</code></p>
<pre><code class="language-rust">fn div_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mulassign"><a class="header" href="#mulassign">MulAssign</a></h1>
<p>The multiplication assignment operator <code>*=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::MulAssign</code></p>
<pre><code class="language-rust">pub trait MulAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-83"><a class="header" href="#trait-functions-83">Trait functions</a></h2>
<h3 id="mul_assign"><a class="header" href="#mul_assign">mul_assign</a></h3>
<p>Performs the <code>*=</code> operation.  # Examples</p>
<pre><code class="language-cairo">let mut x: u8 = 3;
x *= x;
assert!(x == 9);
</code></pre>
<p>Fully qualified path: <code>core::ops::arith::MulAssign::mul_assign</code></p>
<pre><code class="language-rust">fn mul_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remassign"><a class="header" href="#remassign">RemAssign</a></h1>
<p>The remainder assignment operator <code>%=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::RemAssign</code></p>
<pre><code class="language-rust">pub trait RemAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-84"><a class="header" href="#trait-functions-84">Trait functions</a></h2>
<h3 id="rem_assign"><a class="header" href="#rem_assign">rem_assign</a></h3>
<p>Performs the <code>%=</code> operation.  # Examples</p>
<pre><code class="language-cairo">let mut x: u8 = 3;
x %= x;
assert!(x == 0);
</code></pre>
<p>Fully qualified path: <code>core::ops::arith::RemAssign::rem_assign</code></p>
<pre><code class="language-rust">fn rem_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subassign"><a class="header" href="#subassign">SubAssign</a></h1>
<p>The subtraction assignment operator <code>-=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::SubAssign</code></p>
<pre><code class="language-rust">pub trait SubAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-85"><a class="header" href="#trait-functions-85">Trait functions</a></h2>
<h3 id="sub_assign"><a class="header" href="#sub_assign">sub_assign</a></h3>
<p>Performs the <code>-=</code> operation.  # Examples</p>
<pre><code class="language-cairo">let mut x: u8 = 3;
x -= x;
assert!(x == 0);
</code></pre>
<p>Fully qualified path: <code>core::ops::arith::SubAssign::sub_assign</code></p>
<pre><code class="language-rust">fn sub_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-1"><a class="header" href="#deref-1">Deref</a></h1>
<p>A trait for dereferencing a value to provide transparent access to its contents.Implementing this trait allows a type to behave like its inner type, enabling direct access to the inner type's fields.Note: The <code>Deref</code> mechanism is limited and cannot be used to implicitly convert a type to its target type when passing arguments to functions. For example, if you have a function that takes an <code>Inner</code>, you cannot pass an <code>Outer</code> to it even if <code>Outer</code> implements <code>Deref</code>.  # Examples</p>
<pre><code class="language-cairo">struct Wrapper&lt;T&gt; { inner: T }

impl WrapperDeref&lt;T&gt; of Deref&lt;Wrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref(self: Wrapper&lt;T&gt;) -&gt; T { self.inner }
}

let wrapped = Wrapper { inner: 42 };
assert!(wrapped.deref() == 42);
</code></pre>
<p>Fully qualified path: <code>core::ops::deref::Deref</code></p>
<pre><code class="language-rust">pub trait Deref&lt;T&gt;</code></pre>
<h2 id="trait-functions-86"><a class="header" href="#trait-functions-86">Trait functions</a></h2>
<h3 id="deref-2"><a class="header" href="#deref-2">deref</a></h3>
<p>Returns the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::Deref::deref</code></p>
<pre><code class="language-rust">fn deref(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-6"><a class="header" href="#trait-types-6">Trait types</a></h2>
<h3 id="target-3"><a class="header" href="#target-3">Target</a></h3>
<p>The type of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::Deref::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derefmut"><a class="header" href="#derefmut">DerefMut</a></h1>
<p>A trait for dereferencing in mutable contexts.This trait is similar to <code>Deref</code> but specifically handles cases where the value accessed is mutable. Despite its name, <code>DerefMut</code> does NOT allow modifying the inner value - it only indicates that the container itself is mutable.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop)]
</span>struct MutWrapper&lt;T&gt; {
    value: T
}

impl MutWrapperDerefMut&lt;T, +Copy&lt;T&gt;&gt; of DerefMut&lt;MutWrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref_mut(ref self: MutWrapper&lt;T&gt;) -&gt; T {
        self.value
    }
}

// This will work since x is mutable
let mut x = MutWrapper { value: 42 };
let val = x.deref_mut();
assert!(val == 42);

// This would fail to compile since y is not mutable
let y = MutWrapper { value: 42 };
let val = y.deref_mut(); // Compile error
</code></pre>
<p>Fully qualified path: <code>core::ops::deref::DerefMut</code></p>
<pre><code class="language-rust">pub trait DerefMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-87"><a class="header" href="#trait-functions-87">Trait functions</a></h2>
<h3 id="deref_mut"><a class="header" href="#deref_mut">deref_mut</a></h3>
<p>Returns the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::DerefMut::deref_mut</code></p>
<pre><code class="language-rust">fn deref_mut(ref self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-7"><a class="header" href="#trait-types-7">Trait types</a></h2>
<h3 id="target-4"><a class="header" href="#target-4">Target</a></h3>
<p>The type of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::DerefMut::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fn"><a class="header" href="#fn">Fn</a></h1>
<p>The version of the call operator that takes a by-snapshot receiver.Instances of <code>Fn</code> can be called repeatedly.<code>Fn</code> is implemented automatically by closures which only whose captured variable are all <code>Copy</code>. Additionally, for any type <code>F</code> that implements <code>Fn</code>, <code>@F</code> implements <code>Fn</code>, too.Since <a href="./core-ops-function-FnOnce.html"><code>FnOnce</code></a> is implemented for all implementers  of <code>Fn</code>, any instance of <code>Fn</code> can be used as a parameter where a <a href="./core-ops-function-FnOnce.html"><code>FnOnce</code></a> is expected.Use <code>Fn</code> as a bound when you want to accept a parameter of function-like type and need to call it repeatedly. If you do not need such strict requirements, use <a href="./core-ops-function-FnOnce.html"><code>FnOnce</code></a> as bounds.  # Examples  ## Calling a closure</p>
<pre><code class="language-cairo">let square = |x| x * x;
assert_eq!(square(5), 25);
</code></pre>
<h2 id="using-a-fn-parameter"><a class="header" href="#using-a-fn-parameter">Using a <code>Fn</code> parameter</a></h2>
<pre><code class="language-cairo">fn call_with_one&lt;F, +Drop&lt;F&gt;, +core::ops::Fn&lt;F, (usize,)&gt;[Output: usize]&gt;(func: F) -&gt; usize {
   func(1)
}

let double = |x| x * 2;
assert_eq!(call_with_one(double), 2);
</code></pre>
<p>Fully qualified path: <code>core::ops::function::Fn</code></p>
<pre><code class="language-rust">pub trait Fn&lt;T, Args&gt;</code></pre>
<h2 id="trait-functions-88"><a class="header" href="#trait-functions-88">Trait functions</a></h2>
<h3 id="call-1"><a class="header" href="#call-1">call</a></h3>
<p>Performs the call operation.</p>
<p>Fully qualified path: <code>core::ops::function::Fn::call</code></p>
<pre><code class="language-rust">fn call(self: @T, args: Args) -&gt; Self::Output</code></pre>
<h2 id="trait-types-8"><a class="header" href="#trait-types-8">Trait types</a></h2>
<h3 id="output-2"><a class="header" href="#output-2">Output</a></h3>
<p>The returned type after the call operator is used.</p>
<p>Fully qualified path: <code>core::ops::function::Fn::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h1>
<p>The version of the call operator that takes a by-value receiver.Instances of <code>FnOnce</code> can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements <code>FnOnce</code>, it can only be called once.<code>FnOnce</code> is implemented automatically by closures that might consume captured variables.</p>
<pre><code class="language-cairo"><span class="boring"> Examples
</span>
fn consume_with_relish&lt;
    F, O, +Drop&lt;F&gt;, +core::ops::FnOnce&lt;F, ()&gt;[Output: O], +core::fmt::Display&lt;O&gt;, +Drop&lt;O&gt;,
&gt;(
    func: F,
) {
    // `func` consumes its captured variables, so it cannot be run more
    // than once.
    println!("Consumed: {}", func());

    println!("Delicious!");
    // Attempting to invoke `func()` again will throw a `Variable was previously moved.`
    // error for `func`.
}

  let x: ByteArray = "x";
  let consume_and_return_x = || x;
  consume_with_relish(consume_and_return_x);
  // `consume_and_return_x` can no longer be invoked at this point
</code></pre>
<p>Fully qualified path: <code>core::ops::function::FnOnce</code></p>
<pre><code class="language-rust">pub trait FnOnce&lt;T, Args&gt;</code></pre>
<h2 id="trait-functions-89"><a class="header" href="#trait-functions-89">Trait functions</a></h2>
<h3 id="call-2"><a class="header" href="#call-2">call</a></h3>
<p>Performs the call operation.</p>
<p>Fully qualified path: <code>core::ops::function::FnOnce::call</code></p>
<pre><code class="language-rust">fn call(self: T, args: Args) -&gt; Self::Output</code></pre>
<h2 id="trait-types-9"><a class="header" href="#trait-types-9">Trait types</a></h2>
<h3 id="output-3"><a class="header" href="#output-3">Output</a></h3>
<p>The returned type after the call operator is used.</p>
<p>Fully qualified path: <code>core::ops::function::FnOnce::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-4"><a class="header" href="#index-4">Index</a></h1>
<p>A trait for indexing operations (<code>container[index]</code>) where the input type is mutated.This trait should be implemented when you want to implement indexing operations on a type that's mutated by a read access. This is useful for any type depending on a <a href="./core-dict-Felt252Dict.html"><code>Felt252Dict</code></a>, where dictionary accesses are modifying the data structure itself.<code>container[index]</code> is syntactic sugar for <code>container.index(index)</code>.  # ExamplesThe following example implements <code>Index</code> on a <code>Stack</code> type. This <code>Stack</code> is implemented based on a <a href="./core-dict-Felt252Dict.html"><code>Felt252Dict</code></a>, where dictionary accesses are modifying the dictionary itself. As such, we must implement the <code>Index</code> trait instead of the <code>IndexView</code> trait.</p>
<pre><code class="language-cairo">use core::ops::Index;

<span class="boring">[derive(Destruct, Default)]
</span>struct Stack {
    items: Felt252Dict&lt;u128&gt;,
    len: usize
}

<span class="boring">[generate_trait]
</span>impl StackImpl of StackTrait {
    fn push(ref self: Stack, item: u128) {
        self.items.insert(self.len.into(), item);
        self.len += 1;
    }
}

impl StackIndex of Index&lt;Stack, usize&gt; {
     type Target = u128;

     fn index(ref self: Stack, index: usize) -&gt; Self::Target {
         if index &gt;= self.len {
             panic!("Index out of bounds");
         }
         self.items.get(index.into())
     }
 }

let mut stack: Stack = Default::default();
stack.push(1);
assert!(stack[0] == 1);
</code></pre>
<p>Fully qualified path: <code>core::ops::index::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-90"><a class="header" href="#trait-functions-90">Trait functions</a></h2>
<h3 id="index-5"><a class="header" href="#index-5">index</a></h3>
<p>Performs the indexing (<code>container[index]</code>) operation.  # PanicsMay panic if the index is out of bounds.</p>
<p>Fully qualified path: <code>core::ops::index::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-10"><a class="header" href="#trait-types-10">Trait types</a></h2>
<h3 id="target-5"><a class="header" href="#target-5">Target</a></h3>
<p>The returned type after indexing.</p>
<p>Fully qualified path: <code>core::ops::index::Index::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview-1"><a class="header" href="#indexview-1">IndexView</a></h1>
<p>A trait for indexing operations (<code>container[index]</code>) where the input type is not modified.<code>container[index]</code> is syntactic sugar for <code>container.index(index)</code>.  # ExamplesThe following example implements <code>IndexView</code> on a <code>NucleotideCount</code> container, which can be indexed without modifying the input, enabling individual counts to be retrieved with index syntax.</p>
<pre><code class="language-cairo">use core::ops::IndexView;

<span class="boring">[derive(Copy, Drop)]
</span>enum Nucleotide {
     A,
     C,
     G,
     T,
 }

<span class="boring">[derive(Copy, Drop)]
</span>struct NucleotideCount {
     a: usize,
     c: usize,
     g: usize,
     t: usize,
 }

impl NucleotideIndex of IndexView&lt;NucleotideCount, Nucleotide&gt; {
     type Target = usize;

     fn index(self: @NucleotideCount, index: Nucleotide) -&gt; Self::Target {
         match index {
             Nucleotide::A =&gt; *self.a,
             Nucleotide::C =&gt; *self.c,
             Nucleotide::G =&gt; *self.g,
             Nucleotide::T =&gt; *self.t,
         }
     }
 }

let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};
assert!(nucleotide_count[Nucleotide::A] == 14);
assert!(nucleotide_count[Nucleotide::C] == 9);
assert!(nucleotide_count[Nucleotide::G] == 10);
assert!(nucleotide_count[Nucleotide::T] == 12);
</code></pre>
<p>Fully qualified path: <code>core::ops::index::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-91"><a class="header" href="#trait-functions-91">Trait functions</a></h2>
<h3 id="index-6"><a class="header" href="#index-6">index</a></h3>
<p>Performs the indexing (<code>container[index]</code>) operation.  # PanicsMay panic if the index is out of bounds.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-11"><a class="header" href="#trait-types-11">Trait types</a></h2>
<h3 id="target-6"><a class="header" href="#target-6">Target</a></h3>
<p>The returned type after indexing.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangeinclusivetrait"><a class="header" href="#rangeinclusivetrait">RangeInclusiveTrait</a></h1>
<p>Fully qualified path: <code>core::ops::range::RangeInclusiveTrait</code></p>
<pre><code class="language-rust">pub trait RangeInclusiveTrait&lt;T, +Destruct&lt;T&gt;, +PartialOrd&lt;@T&gt;&gt;</code></pre>
<h2 id="trait-functions-92"><a class="header" href="#trait-functions-92">Trait functions</a></h2>
<h3 id="contains"><a class="header" href="#contains">contains</a></h3>
<p>Returns <code>true</code> if <code>item</code> is contained in the range.  # Examples</p>
<pre><code class="language-cairo">assert!(!(3..=5).contains(@2));
assert!( (3..=5).contains(@3));
assert!( (3..=5).contains(@4));
assert!( (3..=5).contains(@5));
assert!(!(3..=5).contains(@6));

assert!( (3..=3).contains(@3));
assert!(!(3..=2).contains(@3));
</code></pre>
<p>Fully qualified path: <code>core::ops::range::RangeInclusiveTrait::contains</code></p>
<pre><code class="language-rust">fn contains(self: @RangeInclusive&lt;T&gt;, item: @T) -&gt; bool</code></pre>
<h3 id="is_empty-2"><a class="header" href="#is_empty-2">is_empty</a></h3>
<p>Returns <code>true</code> if the range contains no items.  # Examples</p>
<pre><code class="language-cairo">assert!(!(3_u8..=5_u8).is_empty());
assert!(!(3_u8..=3_u8).is_empty());
assert!( (3_u8..=2_u8).is_empty());
</code></pre>
<p>Fully qualified path: <code>core::ops::range::RangeInclusiveTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: @RangeInclusive&lt;T&gt;) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangetrait"><a class="header" href="#rangetrait">RangeTrait</a></h1>
<p>Fully qualified path: <code>core::ops::range::RangeTrait</code></p>
<pre><code class="language-rust">pub trait RangeTrait&lt;T, +Destruct&lt;T&gt;, +PartialOrd&lt;@T&gt;&gt;</code></pre>
<h2 id="trait-functions-93"><a class="header" href="#trait-functions-93">Trait functions</a></h2>
<h3 id="contains-1"><a class="header" href="#contains-1">contains</a></h3>
<p>Returns <code>true</code> if <code>item</code> is contained in the range.  # Examples</p>
<pre><code class="language-cairo">assert!(!(3..5).contains(@2));
assert!( (3..5).contains(@3));
assert!( (3..5).contains(@4));
assert!(!(3..5).contains(@5));

assert!(!(3..3).contains(@3));
assert!(!(3..2).contains(@3));
</code></pre>
<p>Fully qualified path: <code>core::ops::range::RangeTrait::contains</code></p>
<pre><code class="language-rust">fn contains(self: @Range&lt;T&gt;, item: @T) -&gt; bool</code></pre>
<h3 id="is_empty-3"><a class="header" href="#is_empty-3">is_empty</a></h3>
<p>Returns <code>true</code> if the range contains no items.  # Examples</p>
<pre><code class="language-cairo">assert!(!(3_u8..5_u8).is_empty());
assert!( (3_u8..3_u8).is_empty());
assert!( (3_u8..2_u8).is_empty());
</code></pre>
<p>Fully qualified path: <code>core::ops::range::RangeTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: @Range&lt;T&gt;) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview-2"><a class="header" href="#indexview-2">IndexView</a></h1>
<p>A trait for indexing operations (<code>container[index]</code>) where the input type is not modified.<code>container[index]</code> is syntactic sugar for <code>container.index(index)</code>.  # ExamplesThe following example implements <code>IndexView</code> on a <code>NucleotideCount</code> container, which can be indexed without modifying the input, enabling individual counts to be retrieved with index syntax.</p>
<pre><code class="language-cairo">use core::ops::IndexView;

<span class="boring">[derive(Copy, Drop)]
</span>enum Nucleotide {
     A,
     C,
     G,
     T,
 }

<span class="boring">[derive(Copy, Drop)]
</span>struct NucleotideCount {
     a: usize,
     c: usize,
     g: usize,
     t: usize,
 }

impl NucleotideIndex of IndexView&lt;NucleotideCount, Nucleotide&gt; {
     type Target = usize;

     fn index(self: @NucleotideCount, index: Nucleotide) -&gt; Self::Target {
         match index {
             Nucleotide::A =&gt; *self.a,
             Nucleotide::C =&gt; *self.c,
             Nucleotide::G =&gt; *self.g,
             Nucleotide::T =&gt; *self.t,
         }
     }
 }

let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};
assert!(nucleotide_count[Nucleotide::A] == 14);
assert!(nucleotide_count[Nucleotide::C] == 9);
assert!(nucleotide_count[Nucleotide::G] == 10);
assert!(nucleotide_count[Nucleotide::T] == 12);
</code></pre>
<p>Fully qualified path: <code>core::ops::index::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-94"><a class="header" href="#trait-functions-94">Trait functions</a></h2>
<h3 id="index-7"><a class="header" href="#index-7">index</a></h3>
<p>Performs the indexing (<code>container[index]</code>) operation.  # PanicsMay panic if the index is out of bounds.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-12"><a class="header" href="#trait-types-12">Trait types</a></h2>
<h3 id="target-7"><a class="header" href="#target-7">Target</a></h3>
<p>The returned type after indexing.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-8"><a class="header" href="#index-8">Index</a></h1>
<p>A trait for indexing operations (<code>container[index]</code>) where the input type is mutated.This trait should be implemented when you want to implement indexing operations on a type that's mutated by a read access. This is useful for any type depending on a <a href="./core-dict-Felt252Dict.html"><code>Felt252Dict</code></a>, where dictionary accesses are modifying the data structure itself.<code>container[index]</code> is syntactic sugar for <code>container.index(index)</code>.  # ExamplesThe following example implements <code>Index</code> on a <code>Stack</code> type. This <code>Stack</code> is implemented based on a <a href="./core-dict-Felt252Dict.html"><code>Felt252Dict</code></a>, where dictionary accesses are modifying the dictionary itself. As such, we must implement the <code>Index</code> trait instead of the <code>IndexView</code> trait.</p>
<pre><code class="language-cairo">use core::ops::Index;

<span class="boring">[derive(Destruct, Default)]
</span>struct Stack {
    items: Felt252Dict&lt;u128&gt;,
    len: usize
}

<span class="boring">[generate_trait]
</span>impl StackImpl of StackTrait {
    fn push(ref self: Stack, item: u128) {
        self.items.insert(self.len.into(), item);
        self.len += 1;
    }
}

impl StackIndex of Index&lt;Stack, usize&gt; {
     type Target = u128;

     fn index(ref self: Stack, index: usize) -&gt; Self::Target {
         if index &gt;= self.len {
             panic!("Index out of bounds");
         }
         self.items.get(index.into())
     }
 }

let mut stack: Stack = Default::default();
stack.push(1);
assert!(stack[0] == 1);
</code></pre>
<p>Fully qualified path: <code>core::ops::index::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-95"><a class="header" href="#trait-functions-95">Trait functions</a></h2>
<h3 id="index-9"><a class="header" href="#index-9">index</a></h3>
<p>Performs the indexing (<code>container[index]</code>) operation.  # PanicsMay panic if the index is out of bounds.</p>
<p>Fully qualified path: <code>core::ops::index::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-13"><a class="header" href="#trait-types-13">Trait types</a></h2>
<h3 id="target-8"><a class="header" href="#target-8">Target</a></h3>
<p>The returned type after indexing.</p>
<p>Fully qualified path: <code>core::ops::index::Index::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstatetrait"><a class="header" href="#hashstatetrait">HashStateTrait</a></h1>
<p>A trait for hash state accumulators.Provides methods to update a hash state with new values and finalize it into a hash result.</p>
<p>Fully qualified path: <code>core::hash::HashStateTrait</code></p>
<pre><code class="language-rust">pub trait HashStateTrait&lt;S&gt;</code></pre>
<h2 id="trait-functions-96"><a class="header" href="#trait-functions-96">Trait functions</a></h2>
<h3 id="update"><a class="header" href="#update">update</a></h3>
<p>Updates the current hash state <code>self</code> with the given <code>felt252</code> value and returns a new hash state.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::hash::HashStateTrait;

let mut state = PedersenTrait::new(0);
state = state.update(1);
</code></pre>
<p>Fully qualified path: <code>core::hash::HashStateTrait::update</code></p>
<pre><code class="language-rust">fn update(self: S, value: felt252) -&gt; S</code></pre>
<h3 id="finalize-2"><a class="header" href="#finalize-2">finalize</a></h3>
<p>Takes the current state <code>self</code> and returns the hash result.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::hash::HashStateTrait;

let mut state = PedersenTrait::new(0);
let hash = state.finalize();
</code></pre>
<p>Fully qualified path: <code>core::hash::HashStateTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: S) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-1"><a class="header" href="#hash-1">Hash</a></h1>
<p>A trait for values that can be hashed.This trait should be implemented for any type that can be included in a hash calculation. The most common way to implement this trait is by using <code>#[derive(Hash)]</code>.</p>
<p>Fully qualified path: <code>core::hash::Hash</code></p>
<pre><code class="language-rust">pub trait Hash&lt;T, S, +HashStateTrait&lt;S&gt;&gt;</code></pre>
<h2 id="trait-functions-97"><a class="header" href="#trait-functions-97">Trait functions</a></h2>
<h3 id="update_state"><a class="header" href="#update_state">update_state</a></h3>
<p>Updates the hash state with the given value and returns a new hash state.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::hash::Hash;

let mut state = PedersenTrait::new(0);
let new_state = Hash::update_state(state, 1);
</code></pre>
<p>Fully qualified path: <code>core::hash::Hash::update_state</code></p>
<pre><code class="language-rust">fn update_state(state: S, value: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacyhash"><a class="header" href="#legacyhash">LegacyHash</a></h1>
<p>A trait for hashing values using a <code>felt252</code> as hash state, used for backwards compatibility. NOTE: Implement <code>Hash</code> instead of this trait if possible.</p>
<p>Fully qualified path: <code>core::hash::LegacyHash</code></p>
<pre><code class="language-rust">pub trait LegacyHash&lt;T&gt;</code></pre>
<h2 id="trait-functions-98"><a class="header" href="#trait-functions-98">Trait functions</a></h2>
<h3 id="hash-2"><a class="header" href="#hash-2">hash</a></h3>
<p>Takes a <code>felt252</code> state and a value of type <code>T</code> and returns the hash result.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::hash::LegacyHash;

let hash = LegacyHash::hash(0, 1);
</code></pre>
<p>Fully qualified path: <code>core::hash::LegacyHash::hash</code></p>
<pre><code class="language-rust">fn hash(state: felt252, value: T) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstateextrait"><a class="header" href="#hashstateextrait">HashStateExTrait</a></h1>
<p>Extension trait for hash state accumulators.This trait adds the <code>update_with</code> method to hash states, allowing you to directly hash values of any type T that implements <code>Hash</code>, rather than having to manually convert values to felt252 first. This provides a more ergonomic API when working with complex types.</p>
<p>Fully qualified path: <code>core::hash::HashStateExTrait</code></p>
<pre><code class="language-rust">pub trait HashStateExTrait&lt;S, T&gt;</code></pre>
<h2 id="trait-functions-99"><a class="header" href="#trait-functions-99">Trait functions</a></h2>
<h3 id="update_with"><a class="header" href="#update_with">update_with</a></h3>
<p>Updates the hash state with the given value and returns the updated state.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;
use core::hash::HashStateExTrait;

<span class="boring">[derive(Copy, Drop, Hash)]
</span>struct Point { x: u32, y: u32 }

let point = Point { x: 1, y: 2 };
let hash = PedersenTrait::new(0)
    .update_with(point)
    .update_with(42)
    .finalize();
</code></pre>
<p>Fully qualified path: <code>core::hash::HashStateExTrait::update_with</code></p>
<pre><code class="language-rust">fn update_with(self: S, value: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersentrait"><a class="header" href="#pedersentrait">PedersenTrait</a></h1>
<p>Fully qualified path: <code>core::pedersen::PedersenTrait</code></p>
<pre><code class="language-rust">pub trait PedersenTrait</code></pre>
<h2 id="trait-functions-100"><a class="header" href="#trait-functions-100">Trait functions</a></h2>
<h3 id="new-4"><a class="header" href="#new-4">new</a></h3>
<p>Creates a new Pedersen hash state with the given base value.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
assert!(state.state == 0);
</code></pre>
<p>Fully qualified path: <code>core::pedersen::PedersenTrait::new</code></p>
<pre><code class="language-rust">fn new(base: felt252) -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde-1"><a class="header" href="#serde-1">Serde</a></h1>
<p>A trait that allows for serializing and deserializing values of any type.The <code>Serde&lt;T&gt;</code> trait defines two core operations: - <code>serialize</code>: Converts a value into a sequence of <code>felt252</code>s - <code>deserialize</code>: Reconstructs a value from a sequence of <code>felt252</code>s  # Examples  ## Simple Types (u8, u16, u32, u64, u128)Simple types are serialized into a single <code>felt252</code>:</p>
<pre><code class="language-cairo">let value: u8 = 42;
let mut output: Array&lt;felt252&gt; = array![];
value.serialize(ref output);
assert!(output == array![42]); // Single value
</code></pre>
<h2 id="compound-types-u256compound-types-may-be-serialized-into-multiple-felt252-values"><a class="header" href="#compound-types-u256compound-types-may-be-serialized-into-multiple-felt252-values">Compound Types (u256)Compound types may be serialized into multiple <code>felt252</code> values:</a></h2>
<pre><code class="language-cairo">let value: u256 = u256 { low: 1, high: 2 };
let mut output: Array&lt;felt252&gt; = array![];
value.serialize(ref output);
assert!(output == array![1, 2]); // Two `felt252`s: low and high
</code></pre>
<h1 id="implementing-serde---using-the-derive-macroin-most-cases-you-can-use-the-deriveserde-attribute-to-automatically-generate-the-implementation-for-your-type"><a class="header" href="#implementing-serde---using-the-derive-macroin-most-cases-you-can-use-the-deriveserde-attribute-to-automatically-generate-the-implementation-for-your-type">Implementing <code>Serde</code>  ## Using the <code>Derive</code> MacroIn most cases, you can use the <code>#[derive(Serde)]</code> attribute to automatically generate the implementation for your type:</a></h1>
<pre><code class="language-cairo"><span class="boring">[derive(Serde)]
</span>struct Point {
    x: u32,
    y: u32
}
</code></pre>
<h2 id="manual-implementationshould-you-need-to-customize-the-serialization-behavior-for-a-type-in-a-way-that-derive-does-not-support-you-can-implement-the-serde-yourself"><a class="header" href="#manual-implementationshould-you-need-to-customize-the-serialization-behavior-for-a-type-in-a-way-that-derive-does-not-support-you-can-implement-the-serde-yourself">Manual ImplementationShould you need to customize the serialization behavior for a type in a way that derive does not support, you can implement the <code>Serde</code> yourself:</a></h2>
<pre><code class="language-cairo">impl PointSerde of Serde&lt;Point&gt; {
    fn serialize(self: @Point, ref output: Array&lt;felt252&gt;) {
        output.append((*self.x).into());
        output.append((*self.y).into());
    }

    fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;Point&gt; {
        let x = (*serialized.pop_front()?).try_into()?;
        let y = (*serialized.pop_front()?).try_into()?;

        Some(Point { x, y })
    }
}
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde</code></p>
<pre><code class="language-rust">pub trait Serde&lt;T&gt;</code></pre>
<h2 id="trait-functions-101"><a class="header" href="#trait-functions-101">Trait functions</a></h2>
<h3 id="serialize"><a class="header" href="#serialize">serialize</a></h3>
<p>Serializes a value into a sequence of <code>felt252</code>s.  # Examples</p>
<pre><code class="language-cairo">let value: u256 = 1;
let mut serialized: Array&lt;felt252&gt; = array![];
value.serialize(ref serialized);
assert!(serialized == array![1, 0]); // `serialized` contains the [low, high] parts of the
`u256` value ```
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde::serialize</code></p>
<pre><code class="language-rust">fn serialize(self: @T, ref output: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize"><a class="header" href="#deserialize">deserialize</a></h3>
<p>Deserializes a value from a sequence of <code>felt252</code>s. If the value cannot be deserialized, returns <code>None</code>.  # Examples</p>
<pre><code class="language-cairo">let mut serialized: Span&lt;felt252&gt; = array![1, 0].span();
let value: u256 = Serde::deserialize(ref serialized).unwrap();
assert!(value == 1);
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidontrait"><a class="header" href="#poseidontrait">PoseidonTrait</a></h1>
<p>Fully qualified path: <code>core::poseidon::PoseidonTrait</code></p>
<pre><code class="language-rust">pub trait PoseidonTrait</code></pre>
<h2 id="trait-functions-102"><a class="header" href="#trait-functions-102">Trait functions</a></h2>
<h3 id="new-5"><a class="header" href="#new-5">new</a></h3>
<p>Creates an initial state with all fields set to 0.  # Examples</p>
<pre><code class="language-cairo">use core::poseidon::PoseidonTrait;

let mut state = PoseidonTrait::new();
</code></pre>
<p>Fully qualified path: <code>core::poseidon::PoseidonTrait::new</code></p>
<pre><code class="language-rust">fn new() -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<p>A trait for standard formatting, using the empty format ("{}").  # Examples</p>
<pre><code class="language-cairo">let word: ByteArray = "123";
println!("{}", word);
</code></pre>
<p>Fully qualified path: <code>core::fmt::Display</code></p>
<pre><code class="language-rust">pub trait Display&lt;T&gt;</code></pre>
<h2 id="trait-functions-103"><a class="header" href="#trait-functions-103">Trait functions</a></h2>
<h3 id="fmt-1"><a class="header" href="#fmt-1">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::Display::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-1"><a class="header" href="#debug-1">Debug</a></h1>
<p>A trait for debug formatting, using the empty format ("{:?}").  # Examples</p>
<pre><code class="language-cairo">let word: ByteArray = "123";
println!("{:?}", word);
</code></pre>
<p>Fully qualified path: <code>core::fmt::Debug</code></p>
<pre><code class="language-rust">pub trait Debug&lt;T&gt;</code></pre>
<h2 id="trait-functions-104"><a class="header" href="#trait-functions-104">Trait functions</a></h2>
<h3 id="fmt-2"><a class="header" href="#fmt-2">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::Debug::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lowerhex"><a class="header" href="#lowerhex">LowerHex</a></h1>
<p>A trait for hex formatting in lower case, using the empty format ("{:x}").</p>
<p>Fully qualified path: <code>core::fmt::LowerHex</code></p>
<pre><code class="language-rust">pub trait LowerHex&lt;T&gt;</code></pre>
<h2 id="trait-functions-105"><a class="header" href="#trait-functions-105">Trait functions</a></h2>
<h3 id="fmt-3"><a class="header" href="#fmt-3">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::LowerHex::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscallresulttrait"><a class="header" href="#syscallresulttrait">SyscallResultTrait</a></h1>
<p>Trait for handling syscall results.</p>
<p>Fully qualified path: <code>core::starknet::SyscallResultTrait</code></p>
<pre><code class="language-rust">pub trait SyscallResultTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-106"><a class="header" href="#trait-functions-106">Trait functions</a></h2>
<h3 id="unwrap_syscall"><a class="header" href="#unwrap_syscall">unwrap_syscall</a></h3>
<p>Unwraps a syscall result, yielding the content of an <code>Ok</code>.  # PanicsPanics with the syscall error message if the value is an <code>Err</code>.  # Examples</p>
<pre><code class="language-cairo">let result = starknet::syscalls::get_execution_info_v2_syscall();
let info = result.unwrap_syscall();
</code></pre>
<p>Fully qualified path: <code>core::starknet::SyscallResultTrait::unwrap_syscall</code></p>
<pre><code class="language-rust">fn unwrap_syscall(self: SyscallResult&lt;T&gt;) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store"><a class="header" href="#store">Store</a></h1>
<p>Trait for types that can be stored in Starknet contract storage.The <code>Store</code> trait enables types to be stored in and retrieved from Starknet's contract storage. Cairo implements <code>Store</code> for most primitive types. However, collection types (arrays, dicts, etc.) do not implement <code>Store</code> directly. Instead, use specialized storage types, such as <a href="%60Vec%60"><code>Vec</code></a> or <a href="%60Map%60"><code>Map</code></a>.<a href="%60Map%60"><code>Map</code></a>: starknet::storage::Map <a href="%60Vec%60"><code>Vec</code></a>: starknet::storage::Vec  # DerivationTo make a type storable in contract storage, simply derive the <code>Store</code> trait:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, starknet::Store)]
</span>struct Sizes {
    tiny: u8,    // 8 bits
    small: u32,  // 32 bits
    medium: u64, // 64 bits
}
</code></pre>
<p>This allows the <code>Size</code> struct to be stored in a contract's storage.There's no real reason to implement this trait yourself, as it can be trivially derived. For efficiency purposes, consider manually implementing <a href="./core-starknet-storage_access-StorePacking.html"><code>StorePacking</code></a> to optimize storage usage.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store</code></p>
<pre><code class="language-rust">pub trait Store&lt;T&gt;</code></pre>
<h2 id="trait-functions-107"><a class="header" href="#trait-functions-107">Trait functions</a></h2>
<h3 id="read"><a class="header" href="#read">read</a></h3>
<p>Reads a value from storage at the given domain and base address.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address to read from</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read</code></p>
<pre><code class="language-rust">fn read(address_domain: u32, base: StorageBaseAddress) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write"><a class="header" href="#write">write</a></h3>
<p>Writes a value to storage at the given domain and base address.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address to write to * <code>value</code> - The value to store</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write</code></p>
<pre><code class="language-rust">fn write(address_domain: u32, base: StorageBaseAddress, value: T) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="read_at_offset"><a class="header" href="#read_at_offset">read_at_offset</a></h3>
<p>Reads a value from storage at a base address plus an offset.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address * <code>offset</code> - The offset from the base address where the value should be read</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read_at_offset</code></p>
<pre><code class="language-rust">fn read_at_offset(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write_at_offset"><a class="header" href="#write_at_offset">write_at_offset</a></h3>
<p>Writes a value to storage at a base address plus an offset.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address * <code>offset</code> - The offset from the base address where the value should be written * <code>value</code> - The value to store</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write_at_offset</code></p>
<pre><code class="language-rust">fn write_at_offset(
    address_domain: u32, base: StorageBaseAddress, offset: u8, value: T,
) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="size"><a class="header" href="#size">size</a></h3>
<p>Returns the size in storage for this type.This is bounded to 255, as the offset is a u8. As such, a single type can only take up to 255 slots in storage.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::size</code></p>
<pre><code class="language-rust">fn size() -&gt; u8</code></pre>
<h3 id="scrub"><a class="header" href="#scrub">scrub</a></h3>
<p>Clears the storage area by writing zeroes to it.  # Arguments<code>address_domain</code> - The storage domain * <code>base</code> - The base storage address to start clearing * <code>offset</code> - The offset from the base address where clearing should startThe operation writes zeroes to storage starting from the specified base address and offset, and continues for the size of the type as determined by the <code>size()</code> function.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::scrub</code></p>
<pre><code class="language-rust">fn scrub(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;()&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-1"><a class="header" href="#event-1">Event</a></h1>
<p>A trait for handling serialization and deserialization of events.Events in Starknet are stored in transaction receipts as a combination of keys and data fields. This trait provides the methods needed to serialize event data into these fields and deserialize them back into their original form.This trait can easily be derived using the <code>#[derive(starknet::Event)]</code> attribute. Fields can be marked as keys using the <code>#[key]</code> attribute to serialize them as event keys.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, starknet::Event)]
</span>pub struct Transfer {
<span class="boring">    [key]
</span>    pub from: ContractAddress,
<span class="boring">    [key]
</span>    pub to: ContractAddress,
    pub amount: u256,
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::event::Event</code></p>
<pre><code class="language-rust">pub trait Event&lt;T&gt;</code></pre>
<h2 id="trait-functions-108"><a class="header" href="#trait-functions-108">Trait functions</a></h2>
<h3 id="append_keys_and_data"><a class="header" href="#append_keys_and_data">append_keys_and_data</a></h3>
<p>Serializes the keys and data for event emission.The keys array will contain: - The event name selector as the first key - Any fields marked with #<a href="key">key</a> as subsequent keysThe data array will contain all non-key fields.</p>
<p>Fully qualified path: <code>core::starknet::event::Event::append_keys_and_data</code></p>
<pre><code class="language-rust">fn append_keys_and_data(self: @T, ref keys: Array&lt;felt252&gt;, ref data: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-1"><a class="header" href="#deserialize-1">deserialize</a></h3>
<p>Deserializes events keys and data back into the original event structure.Returns <code>None</code> if deserialization fails.</p>
<p>Fully qualified path: <code>core::starknet::event::Event::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref keys: Span&lt;felt252&gt;, ref data: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontract"><a class="header" href="#accountcontract">AccountContract</a></h1>
<p>A trait for account contracts that support class declarations (only <code>__validate__</code> and <code>__execute__</code> are mandatory for an account).This trait assumes that the calldata for invoke transactions is <code>Array&lt;Call&gt;</code>. This is the network standard following SNIP6. It is not enforced by Starknet, but deviating from the standard interface may lead to incompatibility with standard tooling.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract</code></p>
<pre><code class="language-rust">pub trait AccountContract&lt;TContractState&gt;</code></pre>
<h2 id="trait-functions-109"><a class="header" href="#trait-functions-109">Trait functions</a></h2>
<h3 id="validate_declare"><a class="header" href="#validate_declare"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: @TContractState, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate"><a class="header" href="#validate"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute"><a class="header" href="#execute"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-1"><a class="header" href="#store-1">Store</a></h1>
<p>Trait for types that can be stored in Starknet contract storage.The <code>Store</code> trait enables types to be stored in and retrieved from Starknet's contract storage. Cairo implements <code>Store</code> for most primitive types. However, collection types (arrays, dicts, etc.) do not implement <code>Store</code> directly. Instead, use specialized storage types, such as <a href="%60Vec%60"><code>Vec</code></a> or <a href="%60Map%60"><code>Map</code></a>.<a href="%60Map%60"><code>Map</code></a>: starknet::storage::Map <a href="%60Vec%60"><code>Vec</code></a>: starknet::storage::Vec  # DerivationTo make a type storable in contract storage, simply derive the <code>Store</code> trait:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, starknet::Store)]
</span>struct Sizes {
    tiny: u8,    // 8 bits
    small: u32,  // 32 bits
    medium: u64, // 64 bits
}
</code></pre>
<p>This allows the <code>Size</code> struct to be stored in a contract's storage.There's no real reason to implement this trait yourself, as it can be trivially derived. For efficiency purposes, consider manually implementing <a href="./core-starknet-storage_access-StorePacking.html"><code>StorePacking</code></a> to optimize storage usage.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store</code></p>
<pre><code class="language-rust">pub trait Store&lt;T&gt;</code></pre>
<h2 id="trait-functions-110"><a class="header" href="#trait-functions-110">Trait functions</a></h2>
<h3 id="read-1"><a class="header" href="#read-1">read</a></h3>
<p>Reads a value from storage at the given domain and base address.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address to read from</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read</code></p>
<pre><code class="language-rust">fn read(address_domain: u32, base: StorageBaseAddress) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write-1"><a class="header" href="#write-1">write</a></h3>
<p>Writes a value to storage at the given domain and base address.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address to write to * <code>value</code> - The value to store</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write</code></p>
<pre><code class="language-rust">fn write(address_domain: u32, base: StorageBaseAddress, value: T) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="read_at_offset-1"><a class="header" href="#read_at_offset-1">read_at_offset</a></h3>
<p>Reads a value from storage at a base address plus an offset.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address * <code>offset</code> - The offset from the base address where the value should be read</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read_at_offset</code></p>
<pre><code class="language-rust">fn read_at_offset(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write_at_offset-1"><a class="header" href="#write_at_offset-1">write_at_offset</a></h3>
<p>Writes a value to storage at a base address plus an offset.  # Arguments<code>address_domain</code> - The storage domain (currently only 0 is supported) * <code>base</code> - The base storage address * <code>offset</code> - The offset from the base address where the value should be written * <code>value</code> - The value to store</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write_at_offset</code></p>
<pre><code class="language-rust">fn write_at_offset(
    address_domain: u32, base: StorageBaseAddress, offset: u8, value: T,
) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="size-1"><a class="header" href="#size-1">size</a></h3>
<p>Returns the size in storage for this type.This is bounded to 255, as the offset is a u8. As such, a single type can only take up to 255 slots in storage.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::size</code></p>
<pre><code class="language-rust">fn size() -&gt; u8</code></pre>
<h3 id="scrub-1"><a class="header" href="#scrub-1">scrub</a></h3>
<p>Clears the storage area by writing zeroes to it.  # Arguments<code>address_domain</code> - The storage domain * <code>base</code> - The base storage address to start clearing * <code>offset</code> - The offset from the base address where clearing should startThe operation writes zeroes to storage starting from the specified base address and offset, and continues for the size of the type as determined by the <code>size()</code> function.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::scrub</code></p>
<pre><code class="language-rust">fn scrub(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;()&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storepacking"><a class="header" href="#storepacking">StorePacking</a></h1>
<p>Trait for efficient packing of values into optimized storage representations.This trait enables bit-packing of complex types into simpler storage types to reduce gas costs by minimizing the number of storage slots used. When a type implements <code>StorePacking</code>, the compiler automatically uses <a href="%60StoreUsingPacking%60"><code>StoreUsingPacking</code></a> to handle storage operations. As such, a type cannot implement both <code>Store</code> and <code>StorePacking</code>.  # Storage OptimizationEach storage slot in Starknet is a <code>felt252</code>, and storage operations are expensive. By packing multiple values into fewer slots, you can significantly reduce gas costs. For example: - Multiple small integers can be packed into a single <code>felt252</code> - Structs with several fields can be compressed into a single storage slot  # Implementation RequirementsTo implement <code>StorePacking</code>, ensure that the <code>PackedT</code> type implements <a href="./core-starknet-storage_access-Store.html"><code>Store</code></a>. The packed representation must preserve all necessary information to allow unpacking back to the original type. Additionally, the <code>pack</code> and <code>unpack</code> operations must be reversible, meaning that packing followed by unpacking should return the original value.  # ExamplePacking multiple integer fields into a single storage slot:</p>
<pre><code class="language-cairo">use starknet::storage_access::StorePacking;

<span class="boring">[derive(Drop)]
</span>struct Sizes {
    tiny: u8,    // 8 bits
    small: u32,  // 32 bits
    medium: u64, // 64 bits
}

const TWO_POW_8: u128 = 0x100;
const TWO_POW_40: u128 = 0x10000000000;

impl SizesStorePacking of StorePacking&lt;Sizes, u128&gt; {
    fn pack(value: Sizes) -&gt; u128 {
        value.tiny.into() +
        (value.small.into() * TWO_POW_8) +
        (value.medium.into() * TWO_POW_40)
    }

    fn unpack(value: u128) -&gt; Sizes {
        let tiny = value &amp; 0xff;
        let small = (value / TWO_POW_8) &amp; 0xffffffff;
        let medium = (value / TWO_POW_40);

        Sizes {
            tiny: tiny.try_into().unwrap(),
            small: small.try_into().unwrap(),
            medium: medium.try_into().unwrap(),
        }
    }
}
</code></pre>
<p>By implementing <code>StorePacking</code> for <code>Sizes</code>, the <code>Sizes</code> will be stored in it's packed form, using a single storage slot instead of 3. When retrieved, it will automatically be unpacked back into the original type.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking</code></p>
<pre><code class="language-rust">pub trait StorePacking&lt;T, PackedT&gt;</code></pre>
<h2 id="trait-functions-111"><a class="header" href="#trait-functions-111">Trait functions</a></h2>
<h3 id="pack"><a class="header" href="#pack">pack</a></h3>
<p>Packs a value into its optimized storage representation.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking::pack</code></p>
<pre><code class="language-rust">fn pack(value: T) -&gt; PackedT</code></pre>
<h3 id="unpack"><a class="header" href="#unpack">unpack</a></h3>
<p>Unpacks a storage representation back into the original type.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking::unpack</code></p>
<pre><code class="language-rust">fn unpack(value: PackedT) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256trait"><a class="header" href="#secp256trait">Secp256Trait</a></h1>
<p>A trait for interacting with Secp256{k/r}1 curves.Provides operations needed to work with Secp256k1 and Secp256r1 elliptic curves. It includes methods for accessing curve parameters and creating curve points.  # Examples</p>
<pre><code class="language-cairo">use starknet::secp256k1::Secp256k1Point;
use starknet::secp256_trait::Secp256Trait;
use starknet::SyscallResultTrait;

assert!(
    Secp256Trait::&lt;
        Secp256k1Point,
    &gt;::get_curve_size() == 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141,
);

let generator = Secp256Trait::&lt;Secp256k1Point&gt;::get_generator_point();

let generator = Secp256Trait::&lt;
Secp256k1Point,
&gt;::secp256_ec_new_syscall(
0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
)
.unwrap_syscall();

let random_point = Secp256Trait::&lt;
Secp256k1Point,
&gt;::secp256_ec_get_point_from_x_syscall(
0x4aebd3099c618202fcfe16ae7770b0c49ab5eadf74b754204a3bb6060e44eff3, true,
);
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait</code></p>
<pre><code class="language-rust">pub trait Secp256Trait&lt;Secp256Point&gt;</code></pre>
<h2 id="trait-functions-112"><a class="header" href="#trait-functions-112">Trait functions</a></h2>
<h3 id="get_curve_size"><a class="header" href="#get_curve_size">get_curve_size</a></h3>
<p>Returns the order (size) of the curve's underlying field.This is the number of points on the curve, also known as the curve order.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::get_curve_size</code></p>
<pre><code class="language-rust">fn get_curve_size() -&gt; u256</code></pre>
<h3 id="get_generator_point"><a class="header" href="#get_generator_point">get_generator_point</a></h3>
<p>Returns the generator point (G) for the curve.The generator point is a standard base point on the curve from which other points can be generated through scalar multiplication.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::get_generator_point</code></p>
<pre><code class="language-rust">fn get_generator_point() -&gt; Secp256Point</code></pre>
<h3 id="secp256_ec_new_syscall"><a class="header" href="#secp256_ec_new_syscall">secp256_ec_new_syscall</a></h3>
<p>Creates a new curve point from its x and y coordinates.Returns <code>None</code> if the provided coordinates don't represent a valid point on the curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::secp256_ec_new_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_new_syscall(x: u256, y: u256) -&gt; SyscallResult&lt;Option&lt;Secp256Point&gt;&gt;</code></pre>
<h3 id="secp256_ec_get_point_from_x_syscall"><a class="header" href="#secp256_ec_get_point_from_x_syscall">secp256_ec_get_point_from_x_syscall</a></h3>
<p>Creates a curve point on the curve given its x-coordinate and y-parity.  # Arguments<code>x</code> - The x coordinate of the point * <code>y_parity</code> - If true, choose the odd y value; if false, choose the even y value  # ReturnsReturns <code>Some(point)</code> if a point exists with the given x coordinate, <code>None</code> otherwise.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::secp256_ec_get_point_from_x_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_get_point_from_x_syscall(
    x: u256, y_parity: bool,
) -&gt; SyscallResult&lt;Option&lt;Secp256Point&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256pointtrait"><a class="header" href="#secp256pointtrait">Secp256PointTrait</a></h1>
<p>A trait for performing operations on Secp256{k/r}1 curve points.Provides operations needed for elliptic curve cryptography, including point addition and scalar multiplication.  # Examples</p>
<pre><code class="language-cairo">use starknet::SyscallResultTrait;
use starknet::secp256k1::Secp256k1Point;
use starknet::secp256_trait::Secp256PointTrait;
use starknet::secp256_trait::Secp256Trait;

let generator = Secp256Trait::&lt;Secp256k1Point&gt;::get_generator_point();

assert!(
    Secp256PointTrait::get_coordinates(generator)
        .unwrap_syscall() == (
            0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
            0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
        ),
);

let point = Secp256PointTrait::add(generator, generator);
let other_point = Secp256PointTrait::mul(generator, 2);
</code></pre>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait</code></p>
<pre><code class="language-rust">pub trait Secp256PointTrait&lt;Secp256Point&gt;</code></pre>
<h2 id="trait-functions-113"><a class="header" href="#trait-functions-113">Trait functions</a></h2>
<h3 id="get_coordinates"><a class="header" href="#get_coordinates">get_coordinates</a></h3>
<p>Returns the x and y coordinates of the curve point.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::get_coordinates</code></p>
<pre><code class="language-rust">fn get_coordinates(self: Secp256Point) -&gt; SyscallResult&lt;(u256, u256)&gt;</code></pre>
<h3 id="add-3"><a class="header" href="#add-3">add</a></h3>
<p>Performs elliptic curve point addition.Adds <code>self</code> and <code>other</code> following the curve's addition law and returns the resulting point.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::add</code></p>
<pre><code class="language-rust">fn add(self: Secp256Point, other: Secp256Point) -&gt; SyscallResult&lt;Secp256Point&gt;</code></pre>
<h3 id="mul-3"><a class="header" href="#mul-3">mul</a></h3>
<p>Performs scalar multiplication of a curve point.Multiplies <code>self</code> by the given scalar value.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::mul</code></p>
<pre><code class="language-rust">fn mul(self: Secp256Point, scalar: u256) -&gt; SyscallResult&lt;Secp256Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-2"><a class="header" href="#event-2">Event</a></h1>
<p>A trait for handling serialization and deserialization of events.Events in Starknet are stored in transaction receipts as a combination of keys and data fields. This trait provides the methods needed to serialize event data into these fields and deserialize them back into their original form.This trait can easily be derived using the <code>#[derive(starknet::Event)]</code> attribute. Fields can be marked as keys using the <code>#[key]</code> attribute to serialize them as event keys.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, starknet::Event)]
</span>pub struct Transfer {
<span class="boring">    [key]
</span>    pub from: ContractAddress,
<span class="boring">    [key]
</span>    pub to: ContractAddress,
    pub amount: u256,
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::event::Event</code></p>
<pre><code class="language-rust">pub trait Event&lt;T&gt;</code></pre>
<h2 id="trait-functions-114"><a class="header" href="#trait-functions-114">Trait functions</a></h2>
<h3 id="append_keys_and_data-1"><a class="header" href="#append_keys_and_data-1">append_keys_and_data</a></h3>
<p>Serializes the keys and data for event emission.The keys array will contain: - The event name selector as the first key - Any fields marked with #<a href="key">key</a> as subsequent keysThe data array will contain all non-key fields.</p>
<p>Fully qualified path: <code>core::starknet::event::Event::append_keys_and_data</code></p>
<pre><code class="language-rust">fn append_keys_and_data(self: @T, ref keys: Array&lt;felt252&gt;, ref data: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-2"><a class="header" href="#deserialize-2">deserialize</a></h3>
<p>Deserializes events keys and data back into the original event structure.Returns <code>None</code> if deserialization fails.</p>
<p>Fully qualified path: <code>core::starknet::event::Event::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref keys: Span&lt;felt252&gt;, ref data: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventemitter"><a class="header" href="#eventemitter">EventEmitter</a></h1>
<p>A trait for emitting Starknet events.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[derive(Drop, starknet::Event)]
</span>pub struct NewOwner {
    pub new_owner: ContractAddress,
}

fn emit_event(ref self: ContractState, new_owner: ContractAddress) {
    self.emit(NewOwner { new_owner });
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::event::EventEmitter</code></p>
<pre><code class="language-rust">pub trait EventEmitter&lt;T, TEvent&gt;</code></pre>
<h2 id="trait-functions-115"><a class="header" href="#trait-functions-115">Trait functions</a></h2>
<h3 id="emit"><a class="header" href="#emit">emit</a></h3>
<p>Emits an event.</p>
<p>Fully qualified path: <code>core::starknet::event::EventEmitter::emit</code></p>
<pre><code class="language-rust">fn emit&lt;S, +Into&lt;S, TEvent&gt;&gt;(ref self: T, event: S)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontract-1"><a class="header" href="#accountcontract-1">AccountContract</a></h1>
<p>A trait for account contracts that support class declarations (only <code>__validate__</code> and <code>__execute__</code> are mandatory for an account).This trait assumes that the calldata for invoke transactions is <code>Array&lt;Call&gt;</code>. This is the network standard following SNIP6. It is not enforced by Starknet, but deviating from the standard interface may lead to incompatibility with standard tooling.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract</code></p>
<pre><code class="language-rust">pub trait AccountContract&lt;TContractState&gt;</code></pre>
<h2 id="trait-functions-116"><a class="header" href="#trait-functions-116">Trait functions</a></h2>
<h3 id="validate_declare-1"><a class="header" href="#validate_declare-1"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: @TContractState, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate-1"><a class="header" href="#validate-1"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute-1"><a class="header" href="#execute-1"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractdispatchertrait"><a class="header" href="#accountcontractdispatchertrait">AccountContractDispatcherTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait</code></p>
<pre><code class="language-rust">pub trait AccountContractDispatcherTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-117"><a class="header" href="#trait-functions-117">Trait functions</a></h2>
<h3 id="validate_declare-2"><a class="header" href="#validate_declare-2"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: T, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate-2"><a class="header" href="#validate-2"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(self: T, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute-2"><a class="header" href="#execute-2"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(self: T, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafedispatchertrait"><a class="header" href="#accountcontractsafedispatchertrait">AccountContractSafeDispatcherTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait</code></p>
<pre><code class="language-rust">pub trait AccountContractSafeDispatcherTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-118"><a class="header" href="#trait-functions-118">Trait functions</a></h2>
<h3 id="validate_declare-3"><a class="header" href="#validate_declare-3"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: T, class_hash: felt252) -&gt; starknet::SyscallResult&lt;felt252&gt;</code></pre>
<h3 id="validate-3"><a class="header" href="#validate-3"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(self: T, calls: Array&lt;Call&gt;) -&gt; starknet::SyscallResult&lt;felt252&gt;</code></pre>
<h3 id="execute-3"><a class="header" href="#execute-3"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(self: T, calls: Array&lt;Call&gt;) -&gt; starknet::SyscallResult&lt;Array&lt;Span&lt;felt252&gt;&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaspointer"><a class="header" href="#storageaspointer">StorageAsPointer</a></h1>
<p>Trait for converting a storage member to a <code>StoragePointer0Offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer</code></p>
<pre><code class="language-rust">pub trait StorageAsPointer&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-119"><a class="header" href="#trait-functions-119">Trait functions</a></h2>
<h3 id="as_ptr"><a class="header" href="#as_ptr">as_ptr</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer::as_ptr</code></p>
<pre><code class="language-rust">fn as_ptr(self: @TMemberState) -&gt; StoragePointer0Offset&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-14"><a class="header" href="#trait-types-14">Trait types</a></h2>
<h3 id="value-4"><a class="header" href="#value-4">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointerreadaccess"><a class="header" href="#storagepointerreadaccess">StoragePointerReadAccess</a></h1>
<p>Trait for accessing the values in storage using a <code>StoragePointer</code>.  # Examples</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess</code></p>
<pre><code class="language-rust">pub trait StoragePointerReadAccess&lt;T&gt;</code></pre>
<h2 id="trait-functions-120"><a class="header" href="#trait-functions-120">Trait functions</a></h2>
<h3 id="read-2"><a class="header" href="#read-2">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: @T) -&gt; Self::Value</code></pre>
<h2 id="trait-types-15"><a class="header" href="#trait-types-15">Trait types</a></h2>
<h3 id="value-5"><a class="header" href="#value-5">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointerwriteaccess"><a class="header" href="#storagepointerwriteaccess">StoragePointerWriteAccess</a></h1>
<p>Trait for writing values to storage using a <code>StoragePointer</code>.  # Examples</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess</code></p>
<pre><code class="language-rust">pub trait StoragePointerWriteAccess&lt;T&gt;</code></pre>
<h2 id="trait-functions-121"><a class="header" href="#trait-functions-121">Trait functions</a></h2>
<h3 id="write-2"><a class="header" href="#write-2">write</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess::write</code></p>
<pre><code class="language-rust">fn write(self: T, value: Self::Value)</code></pre>
<h2 id="trait-types-16"><a class="header" href="#trait-types-16">Trait types</a></h2>
<h3 id="value-6"><a class="header" href="#value-6">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaspath"><a class="header" href="#storageaspath">StorageAsPath</a></h1>
<p>Trait for creating a new <code>StoragePath</code> from a storage member.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath</code></p>
<pre><code class="language-rust">pub trait StorageAsPath&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-122"><a class="header" href="#trait-functions-122">Trait functions</a></h2>
<h3 id="as_path"><a class="header" href="#as_path">as_path</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath::as_path</code></p>
<pre><code class="language-rust">fn as_path(self: @TMemberState) -&gt; StoragePath&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-17"><a class="header" href="#trait-types-17">Trait types</a></h2>
<h3 id="value-7"><a class="header" href="#value-7">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pendingstoragepathtrait"><a class="header" href="#pendingstoragepathtrait">PendingStoragePathTrait</a></h1>
<p>A trait for creating a <code>PendingStoragePath</code> from a <code>StoragePath</code> hash state and a key.</p>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePathTrait</code></p>
<pre><code class="language-rust">pub trait PendingStoragePathTrait&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-123"><a class="header" href="#trait-functions-123">Trait functions</a></h2>
<h3 id="new-6"><a class="header" href="#new-6">new</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePathTrait::new</code></p>
<pre><code class="language-rust">fn new(storage_path: @StoragePath&lt;S&gt;, pending_key: felt252) -&gt; PendingStoragePath&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiterrange"><a class="header" href="#intoiterrange">IntoIterRange</a></h1>
<p>Trait for turning collection of values into an iterator over a specific range.</p>
<p>Fully qualified path: <code>core::starknet::storage::IntoIterRange</code></p>
<pre><code class="language-rust">pub trait IntoIterRange&lt;T&gt;</code></pre>
<h2 id="trait-functions-124"><a class="header" href="#trait-functions-124">Trait functions</a></h2>
<h3 id="into_iter_range"><a class="header" href="#into_iter_range">into_iter_range</a></h3>
<p>Creates an iterator over a range from a collection.</p>
<p>Fully qualified path: <code>core::starknet::storage::IntoIterRange::into_iter_range</code></p>
<pre><code class="language-rust">fn into_iter_range(self: T, range: core::ops::Range&lt;u64&gt;) -&gt; Self::IntoIter</code></pre>
<h3 id="into_iter_full_range"><a class="header" href="#into_iter_full_range">into_iter_full_range</a></h3>
<p>Creates an iterator over the full range of a collection.</p>
<p>Fully qualified path: <code>core::starknet::storage::IntoIterRange::into_iter_full_range</code></p>
<pre><code class="language-rust">fn into_iter_full_range(self: T) -&gt; Self::IntoIter</code></pre>
<h2 id="trait-types-18"><a class="header" href="#trait-types-18">Trait types</a></h2>
<h3 id="intoiter"><a class="header" href="#intoiter">IntoIter</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::IntoIterRange::IntoIter</code></p>
<pre><code class="language-rust">type IntoIter;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validstoragetypetrait"><a class="header" href="#validstoragetypetrait">ValidStorageTypeTrait</a></h1>
<p>Trait that ensures a type is valid for storage in Starknet contracts. This trait is used to enforce that only specific types, such as those implementing <code>Store</code> or acting as a <code>StorageNode</code>, can be a part of a storage hierarchy. Any type that does not implement this trait cannot be used in a storage struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::ValidStorageTypeTrait</code></p>
<pre><code class="language-rust">pub trait ValidStorageTypeTrait&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagemapreadaccess"><a class="header" href="#storagemapreadaccess">StorageMapReadAccess</a></h1>
<p>Provides direct read access to values in a storage <a href="./core-starknet-storage-map-Map.html"><code>Map</code></a>.  # Examples</p>
<pre><code class="language-cairo">use starknet::ContractAddress;
use starknet::storage::{Map, StorageMapReadAccess, StoragePathEntry};

<span class="boring">[storage]
</span>struct Storage {
    balances: Map&lt;ContractAddress, u256&gt;,
    allowances: Map&lt;ContractAddress, Map&lt;ContractAddress, u256&gt;&gt;,
}

fn read_storage(self: @ContractState, address: ContractAddress) {
    // Read from single mapping
    let balance = self.balances.read(address);
    // Read from nested mapping
    let allowance = self.allowances.entry(owner).read(spender);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess</code></p>
<pre><code class="language-rust">pub trait StorageMapReadAccess&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-125"><a class="header" href="#trait-functions-125">Trait functions</a></h2>
<h3 id="read-3"><a class="header" href="#read-3">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: TMemberState, key: Self::Key) -&gt; Self::Value</code></pre>
<h2 id="trait-types-19"><a class="header" href="#trait-types-19">Trait types</a></h2>
<h3 id="key"><a class="header" href="#key">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-8"><a class="header" href="#value-8">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagemapwriteaccess"><a class="header" href="#storagemapwriteaccess">StorageMapWriteAccess</a></h1>
<p>Provides direct write access to values in a storage <a href="./core-starknet-storage-map-Map.html"><code>Map</code></a>.Enables directly storing values in the contract's storage at the address of the given key.  # Examples</p>
<pre><code class="language-cairo">use starknet::ContractAddress;
use starknet::storage::{Map, StorageMapWriteAccess, StoragePathEntry};

<span class="boring">[storage]
</span>struct Storage {
    balances: Map&lt;ContractAddress, u256&gt;,
    allowances: Map&lt;ContractAddress, Map&lt;ContractAddress, u256&gt;&gt;,
}

fn write_storage(ref self: ContractState, address: ContractAddress) {
    // Write to single mapping
    self.balances.write(address, 100);
    // Write to nested mapping
    self.allowances.entry(owner).write(spender, 50);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess</code></p>
<pre><code class="language-rust">pub trait StorageMapWriteAccess&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-126"><a class="header" href="#trait-functions-126">Trait functions</a></h2>
<h3 id="write-3"><a class="header" href="#write-3">write</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::write</code></p>
<pre><code class="language-rust">fn write(self: TMemberState, key: Self::Key, value: Self::Value)</code></pre>
<h2 id="trait-types-20"><a class="header" href="#trait-types-20">Trait types</a></h2>
<h3 id="key-1"><a class="header" href="#key-1">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-9"><a class="header" href="#value-9">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepathentry"><a class="header" href="#storagepathentry">StoragePathEntry</a></h1>
<p>Computes storage paths for accessing <a href="./core-starknet-storage-map-Map.html"><code>Map</code></a> entries.The storage path combines the variable's base path with the key's hash to create a unique identifier for the storage slot. This path can then be used for subsequent read or write operations, or advanced further by chaining the <code>entry</code> method.  # Examples</p>
<pre><code class="language-cairo">use starknet::ContractAddress;
use starknet::storage::{Map, StoragePathEntry};

<span class="boring">[storage]
</span>struct Storage {
    balances: Map&lt;ContractAddress, u256&gt;,
}

// Get the storage path for the balance of a specific address
let balance_path = self.balances.entry(address);
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry</code></p>
<pre><code class="language-rust">pub trait StoragePathEntry&lt;C&gt;</code></pre>
<h2 id="trait-functions-127"><a class="header" href="#trait-functions-127">Trait functions</a></h2>
<h3 id="entry-1"><a class="header" href="#entry-1">entry</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::entry</code></p>
<pre><code class="language-rust">fn entry(self: C, key: Self::Key) -&gt; StoragePath&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-21"><a class="header" href="#trait-types-21">Trait types</a></h2>
<h3 id="key-2"><a class="header" href="#key-2">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-10"><a class="header" href="#value-10">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagetrait"><a class="header" href="#storagetrait">StorageTrait</a></h1>
<p>A trait for creating the struct containing the <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of a contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait</code></p>
<pre><code class="language-rust">pub trait StorageTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-128"><a class="header" href="#trait-functions-128">Trait functions</a></h2>
<h3 id="storage-1"><a class="header" href="#storage-1">storage</a></h3>
<p>Creates a struct containing the <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of a contract state. Should be called from the <code>deref</code> method of the contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait::storage</code></p>
<pre><code class="language-rust">fn storage(self: FlattenedStorage&lt;T&gt;) -&gt; Self::BaseType</code></pre>
<h2 id="trait-types-22"><a class="header" href="#trait-types-22">Trait types</a></h2>
<h3 id="basetype"><a class="header" href="#basetype">BaseType</a></h3>
<p>The type of the struct containing the <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of the type <code>T</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait::BaseType</code></p>
<pre><code class="language-rust">type BaseType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagetraitmut"><a class="header" href="#storagetraitmut">StorageTraitMut</a></h1>
<p>A trait for creating the struct containing the mutable <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of a contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut</code></p>
<pre><code class="language-rust">pub trait StorageTraitMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-129"><a class="header" href="#trait-functions-129">Trait functions</a></h2>
<h3 id="storage_mut"><a class="header" href="#storage_mut">storage_mut</a></h3>
<p>Creates a struct containing a mutable version of the <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of a contract state. Should be called from the <code>deref</code> method of the contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut::storage_mut</code></p>
<pre><code class="language-rust">fn storage_mut(self: FlattenedStorage&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::BaseType</code></pre>
<h2 id="trait-types-23"><a class="header" href="#trait-types-23">Trait types</a></h2>
<h3 id="basetype-1"><a class="header" href="#basetype-1">BaseType</a></h3>
<p>The type of the struct containing the mutable <code>StorageBase</code> or <code>FlattenedStorage</code> of all the members of the type <code>T</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut::BaseType</code></p>
<pre><code class="language-rust">type BaseType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenode"><a class="header" href="#storagenode">StorageNode</a></h1>
<p>A trait that given a storage path of a struct, generates the storage node of this struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode</code></p>
<pre><code class="language-rust">pub trait StorageNode&lt;T&gt;</code></pre>
<h2 id="trait-functions-130"><a class="header" href="#trait-functions-130">Trait functions</a></h2>
<h3 id="storage_node"><a class="header" href="#storage_node">storage_node</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode::storage_node</code></p>
<pre><code class="language-rust">fn storage_node(self: StoragePath&lt;T&gt;) -&gt; Self::NodeType</code></pre>
<h2 id="trait-types-24"><a class="header" href="#trait-types-24">Trait types</a></h2>
<h3 id="nodetype"><a class="header" href="#nodetype">NodeType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode::NodeType</code></p>
<pre><code class="language-rust">type NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenodemut"><a class="header" href="#storagenodemut">StorageNodeMut</a></h1>
<p>A mutable version of <code>StorageNode</code>, works the same way, but on <code>Mutable&lt;T&gt;</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut</code></p>
<pre><code class="language-rust">pub trait StorageNodeMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-131"><a class="header" href="#trait-functions-131">Trait functions</a></h2>
<h3 id="storage_node_mut"><a class="header" href="#storage_node_mut">storage_node_mut</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut::storage_node_mut</code></p>
<pre><code class="language-rust">fn storage_node_mut(self: StoragePath&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::NodeType</code></pre>
<h2 id="trait-types-25"><a class="header" href="#trait-types-25">Trait types</a></h2>
<h3 id="nodetype-1"><a class="header" href="#nodetype-1">NodeType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut::NodeType</code></p>
<pre><code class="language-rust">type NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointers"><a class="header" href="#subpointers">SubPointers</a></h1>
<p>Similar to storage node, but for structs which are stored sequentially in the storage. In contrast to storage node, the fields of the struct are just at an offset from the base address of the struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers</code></p>
<pre><code class="language-rust">pub trait SubPointers&lt;T&gt;</code></pre>
<h2 id="trait-functions-132"><a class="header" href="#trait-functions-132">Trait functions</a></h2>
<h3 id="sub_pointers"><a class="header" href="#sub_pointers">sub_pointers</a></h3>
<p>Creates a sub pointers struct for the given storage pointer to a struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers::sub_pointers</code></p>
<pre><code class="language-rust">fn sub_pointers(self: StoragePointer&lt;T&gt;) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-26"><a class="header" href="#trait-types-26">Trait types</a></h2>
<h3 id="subpointerstype"><a class="header" href="#subpointerstype">SubPointersType</a></h3>
<p>The type of the storage pointers, generated for the struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersforward"><a class="header" href="#subpointersforward">SubPointersForward</a></h1>
<p>A trait for implementing <code>SubPointers</code> for types which are not a <code>StoragePointer</code>, such as <code>StorageBase</code> and <code>StoragePath</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward</code></p>
<pre><code class="language-rust">pub trait SubPointersForward&lt;T&gt;</code></pre>
<h2 id="trait-functions-133"><a class="header" href="#trait-functions-133">Trait functions</a></h2>
<h3 id="sub_pointers-1"><a class="header" href="#sub_pointers-1">sub_pointers</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward::sub_pointers</code></p>
<pre><code class="language-rust">fn sub_pointers(self: T) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-27"><a class="header" href="#trait-types-27">Trait types</a></h2>
<h3 id="subpointerstype-1"><a class="header" href="#subpointerstype-1">SubPointersType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersmut"><a class="header" href="#subpointersmut">SubPointersMut</a></h1>
<p>A mutable version of <code>SubPointers</code>, works the same way, but on <code>Mutable&lt;T&gt;</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut</code></p>
<pre><code class="language-rust">pub trait SubPointersMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-134"><a class="header" href="#trait-functions-134">Trait functions</a></h2>
<h3 id="sub_pointers_mut"><a class="header" href="#sub_pointers_mut">sub_pointers_mut</a></h3>
<p>Creates a sub pointers struct for the given storage pointer to a struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut::sub_pointers_mut</code></p>
<pre><code class="language-rust">fn sub_pointers_mut(self: StoragePointer&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-28"><a class="header" href="#trait-types-28">Trait types</a></h2>
<h3 id="subpointerstype-2"><a class="header" href="#subpointerstype-2">SubPointersType</a></h3>
<p>The type of the storage pointers, generated for the struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersmutforward"><a class="header" href="#subpointersmutforward">SubPointersMutForward</a></h1>
<p>A trait for implementing <code>SubPointersMut</code> for types which are not a <code>StoragePointer</code>, such as <code>StorageBase</code> and <code>StoragePath</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward</code></p>
<pre><code class="language-rust">pub trait SubPointersMutForward&lt;T&gt;</code></pre>
<h2 id="trait-functions-135"><a class="header" href="#trait-functions-135">Trait functions</a></h2>
<h3 id="sub_pointers_mut-1"><a class="header" href="#sub_pointers_mut-1">sub_pointers_mut</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward::sub_pointers_mut</code></p>
<pre><code class="language-rust">fn sub_pointers_mut(self: T) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-29"><a class="header" href="#trait-types-29">Trait types</a></h2>
<h3 id="subpointerstype-3"><a class="header" href="#subpointerstype-3">SubPointersType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutablevectrait"><a class="header" href="#mutablevectrait">MutableVecTrait</a></h1>
<p>Provides mutable access to elements in a storage <a href="./core-starknet-storage-vec-Vec.html"><code>Vec</code></a>.This trait extends the read functionality with methods to append new elements and modify existing ones.</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait</code></p>
<pre><code class="language-rust">pub trait MutableVecTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-136"><a class="header" href="#trait-functions-136">Trait functions</a></h2>
<h3 id="get-3"><a class="header" href="#get-3">get</a></h3>
<p>Returns a mutable storage path to the element at the specified index, or <code>None</code> if out of bounds.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait, StoragePointerWriteAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn set_number(ref self: ContractState, index: u64, number: u256) -&gt; bool {
    if let Some(ptr) = self.numbers.get(index) {
        ptr.write(number);
        true
    } else {
        false
    }
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::get</code></p>
<pre><code class="language-rust">fn get(self: T, index: u64) -&gt; Option&lt;StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;&gt;</code></pre>
<h3 id="at-2"><a class="header" href="#at-2">at</a></h3>
<p>Returns a mutable storage path to the element at the specified index.  # PanicsPanics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait, StoragePointerWriteAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn set_number(ref self: ContractState, index: u64, number: u256) {
    self.numbers.at(index).write(number);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::at</code></p>
<pre><code class="language-rust">fn at(self: T, index: u64) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="len-2"><a class="header" href="#len-2">len</a></h3>
<p>Returns the number of elements in the vector.The length is stored at the vector's base storage address and is automatically updated when elements are appended.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn is_empty(self: @ContractState) -&gt; bool {
    self.numbers.len() == 0
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::len</code></p>
<pre><code class="language-rust">fn len(self: T) -&gt; u64</code></pre>
<h3 id="append-1"><a class="header" href="#append-1">append</a></h3>
<p>Returns a mutable storage path to write a new element at the end of the vector.This operation: 1. Increments the vector's length 2. Returns a storage path to write the new element  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait, StoragePointerWriteAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn push_number(ref self: ContractState, number: u256) {
    self.numbers.append().write(number);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::append</code></p>
<pre><code class="language-rust">fn append(self: T) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="allocate"><a class="header" href="#allocate">allocate</a></h3>
<p>Allocates space for a new element at the end of the vector, returning a mutable storage path to write the element.This function is a replacement for the deprecated <code>append</code> function, which allowed appending new elements to a vector. Unlike <code>append</code>, <code>allocate</code> is specifically useful when you need to prepare space for elements of unknown or dynamic size (e.g., appending another vector).  # Use Case<code>allocate</code> is essential when pushing a vector into another vector, as the size of the nested vector is unknown at compile time. It allows the caller to allocate the required space first, then write the nested vector into the allocated space using <code>.write()</code>.This is necessary because pushing directly (e.g., <code>vec.push(nested_vec)</code>) is not supported due to <code>Vec</code> being only a storage abstraction.  # Deprecation NoteThe <code>append</code> function is now deprecated. Use <code>allocate</code> to achieve the same functionality with improved clarity and flexibility.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait, StoragePointerWriteAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;Vec&lt;u256&gt;&gt;,
}

fn append_nested_vector(ref self: ContractState, elements: Array&lt;u256&gt;) {
    // Allocate space for the nested vector in the outer vector.
    let new_vec_storage_path = self.numbers.allocate();
    for element in elements {
        new_vec_storage_path.push(element)
    }
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::allocate</code></p>
<pre><code class="language-rust">fn allocate(self: T) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="push"><a class="header" href="#push">push</a></h3>
<p>Pushes a new value onto the vector.This operation: 1. Increments the vector's length. 2. Writes the provided value to the new storage location at the end of the vector.  # NoteIf you need to allocate storage without writing a value (e.g., when appending another vector), consider using <a href="%60allocate%60"><code>allocate</code></a> instead.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn push_number(ref self: ContractState, number: u256) {
    self.numbers.push(number);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::push</code></p>
<pre><code class="language-rust">fn push&lt;+Drop&lt;Self::ElementType&gt;, +starknet::Store&lt;Self::ElementType&gt;&gt;(
    self: T, value: Self::ElementType,
)</code></pre>
<h3 id="pop"><a class="header" href="#pop">pop</a></h3>
<p>Pops the last value off the vector.This operation: 1. Retrieves the value stored at the last position in the vector. 2. Decrements the vector's length. 3. Returns the retrieved value or <code>None</code> if the vector is empty.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, MutableVecTrait};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn pop_number(ref self: ContractState) -&gt; Option&lt;u256&gt; {
    self.numbers.pop()
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::pop</code></p>
<pre><code class="language-rust">fn pop&lt;+Drop&lt;Self::ElementType&gt;, +starknet::Store&lt;Self::ElementType&gt;&gt;(
    self: T,
) -&gt; Option&lt;Self::ElementType&gt;</code></pre>
<h2 id="trait-types-30"><a class="header" href="#trait-types-30">Trait types</a></h2>
<h3 id="elementtype"><a class="header" href="#elementtype">ElementType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::ElementType</code></p>
<pre><code class="language-rust">type ElementType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectrait"><a class="header" href="#vectrait">VecTrait</a></h1>
<p>Provides read-only access to elements in a storage <a href="./core-starknet-storage-vec-Vec.html"><code>Vec</code></a>.This trait enables retrieving elements and checking the vector's length without modifying the underlying storage.</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait</code></p>
<pre><code class="language-rust">pub trait VecTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-137"><a class="header" href="#trait-functions-137">Trait functions</a></h2>
<h3 id="get-4"><a class="header" href="#get-4">get</a></h3>
<p>Returns a storage path to the element at the specified index, or <code>None</code> if out of bounds.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, VecTrait, StoragePointerReadAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn maybe_number(self: @ContractState, index: u64) -&gt; Option&lt;u256&gt; {
    self.numbers.get(index).map(|ptr| ptr.read())
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::get</code></p>
<pre><code class="language-rust">fn get(self: T, index: u64) -&gt; Option&lt;StoragePath&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="at-3"><a class="header" href="#at-3">at</a></h3>
<p>Returns a storage path to access the element at the specified index.  # PanicsPanics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, VecTrait, StoragePointerReadAccess};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn get_number(self: @ContractState, index: u64) -&gt; u256 {
    self.numbers.at(index).read()
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::at</code></p>
<pre><code class="language-rust">fn at(self: T, index: u64) -&gt; StoragePath&lt;Self::ElementType&gt;</code></pre>
<h3 id="len-3"><a class="header" href="#len-3">len</a></h3>
<p>Returns the number of elements in the vector.The length is stored at the vector's base storage address and is automatically updated when elements are appended.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage::{Vec, VecTrait};

<span class="boring">[storage]
</span>struct Storage {
    numbers: Vec&lt;u256&gt;,
}

fn is_empty(self: @ContractState) -&gt; bool {
    self.numbers.len() == 0
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::len</code></p>
<pre><code class="language-rust">fn len(self: T) -&gt; u64</code></pre>
<h2 id="trait-types-31"><a class="header" href="#trait-types-31">Trait types</a></h2>
<h3 id="elementtype-1"><a class="header" href="#elementtype-1">ElementType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::ElementType</code></p>
<pre><code class="language-rust">type ElementType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31trait"><a class="header" href="#bytes31trait">Bytes31Trait</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Trait</code></p>
<pre><code class="language-rust">pub trait Bytes31Trait</code></pre>
<h2 id="trait-functions-138"><a class="header" href="#trait-functions-138">Trait functions</a></h2>
<h3 id="at-4"><a class="header" href="#at-4">at</a></h3>
<p>Returns the byte at the given index (LSB's index is 0).Assumes that <code>index &lt; BYTES_IN_BYTES31</code>. If the assumption is not met, the behavior is undefined.  # Examples</p>
<pre><code class="language-cairo">let bytes: bytes31 = 1_u8.into();
assert!(bytes.at(0) == 1);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Trait::at</code></p>
<pre><code class="language-rust">fn at(self: @bytes31, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearraytrait"><a class="header" href="#bytearraytrait">ByteArrayTrait</a></h1>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait</code></p>
<pre><code class="language-rust">pub trait ByteArrayTrait</code></pre>
<h2 id="trait-functions-139"><a class="header" href="#trait-functions-139">Trait functions</a></h2>
<h3 id="append_word"><a class="header" href="#append_word">append_word</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>.This function assumes that: 1. <code>word</code> could be validly converted to a <code>bytes31</code> which has no more than <code>len</code> bytes of data. 2. len &lt;= BYTES_IN_BYTES31.If these assumptions are not met, it can corrupt the <code>ByteArray</code>. Thus, this should be a private function. We could add masking/assertions but it would be more expensive.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_word('word', 4);
assert!(ba == "word");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word</code></p>
<pre><code class="language-rust">fn append_word(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append-2"><a class="header" href="#append-2">append</a></h3>
<p>Appends a <code>ByteArray</code> to the end of another <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "1";
ba.append(@"2");
assert!(ba == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append</code></p>
<pre><code class="language-rust">fn append(ref self: ByteArray, other: @ByteArray)</code></pre>
<h3 id="concat"><a class="header" href="#concat">concat</a></h3>
<p>Concatenates two <code>ByteArray</code> and returns the result.The content of <code>left</code> is cloned in a new memory segment. # Examples</p>
<pre><code class="language-cairo">let ba = "1";
let other_ba = "2";
let result = ByteArrayTrait::concat(@ba, @other_ba);
assert!(result == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::concat</code></p>
<pre><code class="language-rust">fn concat(left: @ByteArray, right: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_byte"><a class="header" href="#append_byte">append_byte</a></h3>
<p>Appends a single byte to the end of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_byte(0);
assert!(ba == "0");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_byte</code></p>
<pre><code class="language-rust">fn append_byte(ref self: ByteArray, byte: u8)</code></pre>
<h3 id="len-4"><a class="header" href="#len-4">len</a></h3>
<p>Returns the length of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let len = ba.len();
assert!(len == 10);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::len</code></p>
<pre><code class="language-rust">fn len(self: @ByteArray) -&gt; usize</code></pre>
<h3 id="at-5"><a class="header" href="#at-5">at</a></h3>
<p>Returns an option of the byte at the given index of <code>self</code> or <code>None</code> if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let byte = ba.at(0).unwrap();
assert!(byte == 98);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::at</code></p>
<pre><code class="language-rust">fn at(self: @ByteArray, index: usize) -&gt; Option&lt;u8&gt;</code></pre>
<h3 id="rev"><a class="header" href="#rev">rev</a></h3>
<p>Returns a <code>ByteArray</code> with the reverse order of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
let rev_ba = ba.rev();
assert!(rev_ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::rev</code></p>
<pre><code class="language-rust">fn rev(self: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_word_rev"><a class="header" href="#append_word_rev">append_word_rev</a></h3>
<p>Appends the reverse of the given word to the end of <code>self</code>.This function assumes that: 1. len &lt; 31 2. word is validly convertible to bytes31 of length <code>len</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_word_rev('123', 3);
assert!(ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word_rev</code></p>
<pre><code class="language-rust">fn append_word_rev(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_word_fits_into_pending"><a class="header" href="#append_word_fits_into_pending">append_word_fits_into_pending</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>, assuming there is enough space in the pending word (<code>self.pending_word_len + len &lt; BYTES_IN_BYTES31</code>).<code>word</code> is of type <code>felt252</code> but actually represents a <code>bytes31</code>. It is represented as a <code>felt252</code> to improve performance of building the <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word_fits_into_pending</code></p>
<pre><code class="language-rust">fn append_word_fits_into_pending(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_split_index_lt_16"><a class="header" href="#append_split_index_lt_16">append_split_index_lt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that <code>0 &lt; split_index &lt; 16</code>.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_lt_16</code></p>
<pre><code class="language-rust">fn append_split_index_lt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split_index_16"><a class="header" href="#append_split_index_16">append_split_index_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is exactly 16.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_16</code></p>
<pre><code class="language-rust">fn append_split_index_16(ref self: ByteArray, word: felt252)</code></pre>
<h3 id="append_split_index_gt_16"><a class="header" href="#append_split_index_gt_16">append_split_index_gt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is &gt; 16.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_gt_16</code></p>
<pre><code class="language-rust">fn append_split_index_gt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split"><a class="header" href="#append_split">append_split</a></h3>
<p>A helper function to append a remainder to <code>self</code>, by: 1. completing <code>self.pending_word</code> to a full word using <code>complete_full_word</code>, assuming it's validly convertible to a <code>bytes31</code> of length exactly <code>BYTES_IN_BYTES31 - self.pending_word_len</code>. 2. Setting <code>self.pending_word</code> to <code>new_pending</code>.Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split</code></p>
<pre><code class="language-rust">fn append_split(ref self: ByteArray, complete_full_word: felt252, new_pending: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stringliteral"><a class="header" href="#stringliteral">StringLiteral</a></h1>
<p>Fully qualified path: <code>core::string::StringLiteral</code></p>
<pre><code class="language-rust">pub trait StringLiteral&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peekabletrait"><a class="header" href="#peekabletrait">PeekableTrait</a></h1>
<p>Fully qualified path: <code>core::iter::adapters::peekable::PeekableTrait</code></p>
<pre><code class="language-rust">pub trait PeekableTrait&lt;I, impl IterI: Iterator&lt;I&gt;, +Copy&lt;IterI::Item&gt;, +Drop&lt;IterI::Item&gt;&gt;</code></pre>
<h2 id="trait-functions-140"><a class="header" href="#trait-functions-140">Trait functions</a></h2>
<h3 id="peek"><a class="header" href="#peek">peek</a></h3>
<p>Returns a copy to the next() value without advancing the iterator.Like <a href="%60next%60"><code>next</code></a>, if there is a value, it is wrapped in a <code>Some(T)</code>. But if the iteration is over, <code>None</code> is returned.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = (1..4_u8).into_iter().peekable();

// peek() lets us see one step into the future
assert_eq!(iter.peek(), Some(1));
assert_eq!(iter.next(), Some(1));

assert_eq!(iter.next(), Some(2));

// The iterator does not advance even if we `peek` multiple times
assert_eq!(iter.peek(), Some(3));
assert_eq!(iter.peek(), Some(3));

assert_eq!(iter.next(), Some(3));

// After the iterator is finished, so is `peek()`
assert_eq!(iter.peek(), None);
assert_eq!(iter.next(), None);
</code></pre>
<p>Fully qualified path: <code>core::iter::adapters::peekable::PeekableTrait::peek</code></p>
<pre><code class="language-rust">fn peek(ref self: Peekable&lt;I, IterI::Item&gt;) -&gt; Option&lt;IterI::Item&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extend"><a class="header" href="#extend">Extend</a></h1>
<p>Extend a collection with the contents of an iterator.Iterators produce a series of values, and collections can also be thought of as a series of values. The <code>Extend</code> trait bridges this gap, allowing you to extend a collection by including the contents of that iterator. When extending a collection with an already existing key, that entry is updated or, in the case of collections that permit multiple entries with equal keys, that entry is inserted.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2];

arr.extend(array![3, 4, 5]);

assert_eq!(arr, array![1, 2, 3, 4, 5]);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::collect::Extend</code></p>
<pre><code class="language-rust">pub trait Extend&lt;T, A&gt;</code></pre>
<h2 id="trait-functions-141"><a class="header" href="#trait-functions-141">Trait functions</a></h2>
<h3 id="extend-1"><a class="header" href="#extend-1">extend</a></h3>
<p>Extends a collection with the contents of an iterator.</p>
<p>Fully qualified path: <code>core::iter::traits::collect::Extend::extend</code></p>
<pre><code class="language-rust">fn extend&lt;
    I,
    impl IntoIter: IntoIterator&lt;I&gt;,
    +TypeEqual&lt;IntoIter::Iterator::Item, A&gt;,
    +Destruct&lt;IntoIter::IntoIter&gt;,
    +Destruct&lt;I&gt;,
&gt;(
    ref self: T, iter: I,
)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromiterator"><a class="header" href="#fromiterator">FromIterator</a></h1>
<p>Conversion from an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>.By implementing <code>FromIterator</code> for a type, you define how it will be created from an iterator. This is common for types which describe a collection of some kind.If you want to create a collection from the contents of an iterator, the <a href="%60Iterator::collect()%60"><code>Iterator::collect()</code></a> method is preferred. However, when you need to specify the container type, <a href="%60FromIterator::from_iter()%60"><code>FromIterator::from_iter()</code></a> can be more readable than using a turbofish (e.g. <code>::&lt;Array&lt;_&gt;&gt;()</code>). See the <a href="%60Iterator::collect()%60"><code>Iterator::collect()</code></a> documentation for more examples of its use.See also: <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let v = FromIterator::from_iter(0..5_u32);

assert_eq!(v, array![0, 1, 2, 3, 4]);
</code></pre>
<p>Implementing <code>FromIterator</code> for your type:</p>
<pre><code class="language-cairo">use core::metaprogramming::TypeEqual;

// A sample collection, that's just a wrapper over Array&lt;T&gt;
<span class="boring">[derive(Drop, Debug)]
</span>struct MyCollection {
    arr: Array&lt;u32&gt;,
}

// Let's give it some methods so we can create one and add things
// to it.
<span class="boring">[generate_trait]
</span>impl MyCollectionImpl of MyCollectionTrait {
    fn new() -&gt; MyCollection {
        MyCollection { arr: ArrayTrait::new() }
    }

    fn add(ref self: MyCollection, elem: u32) {
        self.arr.append(elem);
    }
}

// and we'll implement FromIterator
impl MyCollectionFromIterator of FromIterator&lt;MyCollection, u32&gt; {
    fn from_iter&lt;
            I,
            impl IntoIter: IntoIterator&lt;I&gt;,
            +TypeEqual&lt;IntoIter::Iterator::Item, u32&gt;,
            +Destruct&lt;IntoIter::IntoIter&gt;,
            +Destruct&lt;I&gt;,
        &gt;(
            iter: I
        ) -&gt; MyCollection {
        let mut c = MyCollectionTrait::new();
        for i in iter {
            c.add(i);
        };
        c
    }
}

// Now we can make a new iterator...
let iter = (0..5_u32).into_iter();

// ... and make a MyCollection out of it
let c = FromIterator::&lt;MyCollection&gt;::from_iter(iter);

assert_eq!(c.arr, array![0, 1, 2, 3, 4]);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::collect::FromIterator</code></p>
<pre><code class="language-rust">pub trait FromIterator&lt;T, A&gt;</code></pre>
<h2 id="trait-functions-142"><a class="header" href="#trait-functions-142">Trait functions</a></h2>
<h3 id="from_iter"><a class="header" href="#from_iter">from_iter</a></h3>
<p>Creates a value from an iterator.See the <a href="./core-iter.html">module-level documentation</a> for more.  # Examples</p>
<pre><code class="language-cairo">let iter = (0..5_u32).into_iter();

let v = FromIterator::from_iter(iter);

assert_eq!(v, array![0, 1, 2, 3, 4]);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::collect::FromIterator::from_iter</code></p>
<pre><code class="language-rust">fn from_iter&lt;
    I,
    impl IntoIter: IntoIterator&lt;I&gt;,
    +TypeEqual&lt;IntoIter::Iterator::Item, A&gt;,
    +Destruct&lt;IntoIter::IntoIter&gt;,
    +Destruct&lt;I&gt;,
&gt;(
    iter: I,
) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiterator"><a class="header" href="#intoiterator">IntoIterator</a></h1>
<p>Conversion into an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>.By implementing <code>IntoIterator</code> for a type, you define how it will be converted to an iterator. This is common for types which describe a collection of some kind.One benefit of implementing <code>IntoIterator</code> is that your type will work with Cairo's <code>for</code> loop syntax.See also: <a href="./core-iter-traits-collect-FromIterator.html"><code>FromIterator</code></a>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

assert!(Some(1) == iter.next());
assert!(Some(2) == iter.next());
assert!(Some(3) == iter.next());
assert!(None == iter.next());
</code></pre>
<p>Implementing <code>IntoIterator</code> for your type:</p>
<pre><code class="language-cairo">// A sample collection, that's just a wrapper over `Array&lt;u32&gt;`
<span class="boring">[derive(Drop, Debug)]
</span>struct MyCollection {
    arr: Array&lt;u32&gt;
}

// Let's give it some methods so we can create one and add things
// to it.
<span class="boring">[generate_trait]
</span>impl MyCollectionImpl of MyCollectionTrait {
    fn new() -&gt; MyCollection {
        MyCollection {
            arr: ArrayTrait::new()
        }
    }

    fn add(ref self: MyCollection, elem: u32) {
        self.arr.append(elem);
    }
}

// and we'll implement `IntoIterator`
impl MyCollectionIntoIterator of IntoIterator&lt;MyCollection&gt; {
    type IntoIter = core::array::ArrayIter&lt;u32&gt;;
    fn into_iter(self: MyCollection) -&gt; Self::IntoIter {
        self.arr.into_iter()
    }
}

// Now we can make a new collection...
let mut c = MyCollectionTrait::new();

// ... add some stuff to it ...
c.add(0);
c.add(1);
c.add(2);

// ... and then turn it into an `Iterator`:
let mut n = 0;
for i in c {
    assert!(i == n);
    n += 1;
};
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::collect::IntoIterator</code></p>
<pre><code class="language-rust">pub trait IntoIterator&lt;T&gt;</code></pre>
<h2 id="trait-functions-143"><a class="header" href="#trait-functions-143">Trait functions</a></h2>
<h3 id="into_iter"><a class="header" href="#into_iter">into_iter</a></h3>
<p>Creates an iterator from a value.See the <a href="./core-iter.html">module-level documentation</a> for more.  # Examples</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

assert_eq!(Some(1), iter.next());
assert_eq!(Some(2), iter.next());
assert_eq!(Some(3), iter.next());
assert_eq!(None, iter.next());
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::collect::IntoIterator::into_iter</code></p>
<pre><code class="language-rust">fn into_iter(self: T) -&gt; Self::IntoIter</code></pre>
<h2 id="trait-types-32"><a class="header" href="#trait-types-32">Trait types</a></h2>
<h3 id="intoiter-1"><a class="header" href="#intoiter-1">IntoIter</a></h3>
<p>The iterator type that will be created.</p>
<p>Fully qualified path: <code>core::iter::traits::collect::IntoIterator::IntoIter</code></p>
<pre><code class="language-rust">type IntoIter;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>A trait for dealing with iterators.This is the main iterator trait. For more about the concept of iterators generally, please see the [module-level documentation](module-level documentation). In particular, you may want to know how to [implement <code>Iterator</code>][impl].[module-level documentation](module-level documentation): crate::iter <a href="impl">impl</a>: crate::iter#implementing-iterator</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator</code></p>
<pre><code class="language-rust">pub trait Iterator&lt;T&gt;</code></pre>
<h2 id="trait-functions-144"><a class="header" href="#trait-functions-144">Trait functions</a></h2>
<h3 id="next-1"><a class="header" href="#next-1">next</a></h3>
<p>Advances the iterator and returns the next value.Returns <a href="./core-option.html#none"><code>None</code></a> when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling <code>next()</code> again may or may not eventually start returning <a href="%60Some(Item)%60"><code>Some(Item)</code></a> again at some point.<a href="%60Some(Item)%60"><code>Some(Item)</code></a>: Some <a href="./core-option.html#none"><code>None</code></a>: None  # Examples</p>
<pre><code class="language-cairo">let mut iter = [1, 2, 3].span().into_iter();

// A call to next() returns the next value...
assert_eq!(Some(@1), iter.next());
assert_eq!(Some(@2), iter.next());
assert_eq!(Some(@3), iter.next());

// ... and then None once it's over.
assert_eq!(None, iter.next());

// More calls may or may not return `None`. Here, they always will.
assert_eq!(None, iter.next());
assert_eq!(None, iter.next());
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::next</code></p>
<pre><code class="language-rust">fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;</code></pre>
<h3 id="count"><a class="header" href="#count">count</a></h3>
<p>Consumes the iterator, counting the number of iterations and returning it.This method will call <a href="%60next%60"><code>next</code></a> repeatedly until <a href="./core-option.html#none"><code>None</code></a> is encountered, returning the number of times it saw <a href="./core-option.html#some"><code>Some</code></a>. Note that <a href="%60next%60"><code>next</code></a> has to be called at least once even if the iterator does not have any elements.  # Overflow BehaviorThe method does no guarding against overflows, so counting elements of an iterator with more than <a href="./core-num-traits-bounded-Bounded.html"><code>Bounded::&lt;usize&gt;::MAX</code></a> elements either produces the wrong result or panics.  # PanicsThis function might panic if the iterator has more than <a href="./core-num-traits-bounded-Bounded.html"><code>Bounded::&lt;usize&gt;::MAX</code></a> elements.  # Examples</p>
<pre><code class="language-cairo">let mut a = array![1, 2, 3].into_iter();
assert_eq!(a.count(), 3);

let mut a = array![1, 2, 3, 4, 5].into_iter();
assert_eq!(a.count(), 5);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::count</code></p>
<pre><code class="language-rust">fn count&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;&gt;(self: T) -&gt; usize</code></pre>
<h3 id="last"><a class="header" href="#last">last</a></h3>
<p>Consumes the iterator, returning the last element.This method will evaluate the iterator until it returns <a href="./core-option.html#none"><code>None</code></a>. While doing so, it keeps track of the current element. After <a href="./core-option.html#none"><code>None</code></a> is returned, <code>last()</code> will then return the last element it saw.  # Examples</p>
<pre><code class="language-cairo">let mut a = array![1, 2, 3].into_iter();
assert_eq!(a.last(), Option::Some(3));

let mut a = array![].into_iter();
assert_eq!(a.last(), Option::None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::last</code></p>
<pre><code class="language-rust">fn last&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;&gt;(self: T) -&gt; Option&lt;Self::Item&gt;</code></pre>
<h3 id="advance_by"><a class="header" href="#advance_by">advance_by</a></h3>
<p>Advances the iterator by <code>n</code> elements.This method will eagerly skip <code>n</code> elements by calling <a href="%60next%60"><code>next</code></a> up to <code>n</code> times until <a href="./core-option.html#none"><code>None</code></a> is encountered.<code>advance_by(n)</code> will return <code>Ok(())</code> if the iterator successfully advances by <code>n</code> elements, or a <code>Err(NonZero&lt;usize&gt;)</code> with value <code>k</code> if <a href="./core-option.html#none"><code>None</code></a> is encountered, where <code>k</code> is remaining number of steps that could not be advanced because the iterator ran out. If <code>self</code> is empty and <code>n</code> is non-zero, then this returns <code>Err(n)</code>. Otherwise, <code>k</code> is always less than <code>n</code>.<a href="./core-option.html#none"><code>None</code></a>: None <a href="%60next%60"><code>next</code></a>: Iterator::next  # Examples</p>
<pre><code class="language-cairo">let mut iter = array![1_u8, 2, 3, 4].into_iter();

assert_eq!(iter.advance_by(2), Ok(()));
assert_eq!(iter.next(), Some(3));
assert_eq!(iter.advance_by(0), Ok(()));
assert_eq!(iter.advance_by(100), Err(99));
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::advance_by</code></p>
<pre><code class="language-rust">fn advance_by&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;&gt;(
    ref self: T, n: usize,
) -&gt; Result&lt;(), NonZero&lt;usize&gt;&gt;</code></pre>
<h3 id="nth"><a class="header" href="#nth">nth</a></h3>
<p>Returns the <code>n</code>th element of the iterator.Like most indexing operations, the count starts from zero, so <code>nth(0)</code> returns the first value, <code>nth(1)</code> the second, and so on.Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling <code>nth(0)</code> multiple times on the same iterator will return different elements.<code>nth()</code> will return <a href="./core-option.html#none"><code>None</code></a> if <code>n</code> is greater than or equal to the length of the iterator.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();
assert_eq!(iter.nth(1), Some(2));
</code></pre>
<p>Calling <code>nth()</code> multiple times doesn't rewind the iterator:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

assert_eq!(iter.nth(1), Some(2));
assert_eq!(iter.nth(1), None);
</code></pre>
<p>Returning <code>None</code> if there are less than <code>n + 1</code> elements:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();
assert_eq!(iter.nth(10), None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::nth</code></p>
<pre><code class="language-rust">fn nth&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;&gt;(ref self: T, n: usize) -&gt; Option&lt;Self::Item&gt;</code></pre>
<h3 id="map-3"><a class="header" href="#map-3">map</a></h3>
<p>Takes a closure and creates an iterator which calls that closure on each element.<code>map()</code> transforms one iterator into another, by means of its argument: something that implements <a href="%60FnOnce%60"><code>FnOnce</code></a>. It produces a new iterator which calls this closure on each element of the original iterator.If you are good at thinking in types, you can think of <code>map()</code> like this: If you have an iterator that gives you elements of some type <code>A</code>, and you want an iterator of some other type <code>B</code>, you can use <code>map()</code>, passing a closure that takes an <code>A</code> and returns a <code>B</code>.<code>map()</code> is conceptually similar to a <code>for</code> loop. However, as <code>map()</code> is lazy, it is best used when you're already working with other iterators. If you're doing some sort of looping for a side effect, it's considered more idiomatic to use <code>for</code> than <code>map()</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter().map(|x| 2 * x);

assert!(iter.next() == Some(2));
assert!(iter.next() == Some(4));
assert!(iter.next() == Some(6));
assert!(iter.next() == None);
</code></pre>
<p>If you're doing some sort of side effect, prefer <code>for</code> to <code>map()</code>:</p>
<pre><code class="language-cairo">// don't do this:
let _ = (0..5_usize).into_iter().map(|x| println!("{x}"));

// it won't even execute, as it is lazy. Cairo will warn you about this if not specifically
ignored, as is done here.

// Instead, use for:
for x in 0..5_usize {
    println!("{x}");
}
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::map</code></p>
<pre><code class="language-rust">fn map&lt;B, F, +core::ops::Fn&lt;F, (Self::Item,)&gt;[Output: B], +Drop&lt;T&gt;, +Drop&lt;F&gt;&gt;(
    self: T, f: F,
) -&gt; Map&lt;T, F&gt;</code></pre>
<h3 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h3>
<p>Creates an iterator which gives the current iteration count as well as the next value.The iterator returned yields pairs <code>(i, val)</code>, where <code>i</code> is the current index of iteration and <code>val</code> is the value returned by the iterator.<code>enumerate()</code> keeps its count as a <a href="./core-usize.html"><code>usize</code></a>.  # Overflow BehaviorThe method does no guarding against overflows, so enumerating more than <code>Bounded::&lt;usize&gt;::MAX</code> elements will always panic.  # PanicsWill panic if the to-be-returned index overflows a <code>usize</code>.  # Examples</p>
<pre><code class="language-cairo">let mut iter = array!['a', 'b', 'c'].into_iter().enumerate();

assert_eq!(iter.next(), Some((0, 'a')));
assert_eq!(iter.next(), Some((1, 'b')));
assert_eq!(iter.next(), Some((2, 'c')));
assert_eq!(iter.next(), None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::enumerate</code></p>
<pre><code class="language-rust">fn enumerate(self: T) -&gt; Enumerate&lt;T&gt;</code></pre>
<h3 id="fold"><a class="header" href="#fold">fold</a></h3>
<p>Folds every element into an accumulator by applying an operation, returning the final result.<code>fold()</code> takes two arguments: an initial value, and a closure with two arguments: an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration.The initial value is the value the accumulator will have on the first call.After applying this closure to every element of the iterator, <code>fold()</code> returns the accumulator.Folding is useful whenever you have a collection of something, and want to produce a single value from it.Note: <code>fold()</code>, and similar methods that traverse the entire iterator, might not terminate for infinite iterators, even on traits for which a result is determinable in finite time.Note: <code>fold()</code> combines elements in a left-associative fashion. For associative operators like <code>+</code>, the order the elements are combined in is not important, but for non-associative operators like <code>-</code> the order will affect the final result.  # Note to ImplementersSeveral of the other (forward) methods have default implementations in terms of this one, so try to implement this explicitly if it can do something better than the default <code>for</code> loop implementation.In particular, try to have this call <code>fold()</code> on the internal parts from which this iterator is composed.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

// the sum of all of the elements of the array
let sum = iter.fold(0, |acc, x| acc + x);

assert_eq!(sum, 6);
</code></pre>
<p>Let's walk through each step of the iteration here:| element | acc | x | result | |---------|-----|---|--------| |         | 0   |   |        | | 1       | 0   | 1 | 1      | | 2       | 1   | 2 | 3      | | 3       | 3   | 3 | 6      |And so, our final result, <code>6</code>.It's common for people who haven't used iterators a lot to use a <code>for</code> loop with a list of things to build up a result. Those can be turned into <code>fold()</code>s:</p>
<pre><code class="language-cairo">let mut numbers = array![1, 2, 3, 4, 5].span();

let mut result = 0;

// for loop:
for i in numbers{
    result = result + (*i);
};

// fold:
let mut numbers_iter = numbers.into_iter();
let result2 = numbers_iter.fold(0, |acc, x| acc + (*x));

// they're the same
assert_eq!(result, result2);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::fold</code></p>
<pre><code class="language-rust">fn fold&lt;
    B, F, +core::ops::Fn&lt;F, (B, Self::Item)&gt;[Output: B], +Destruct&lt;T&gt;, +Destruct&lt;F&gt;, +Destruct&lt;B&gt;,
&gt;(
    ref self: T, init: B, f: F,
) -&gt; B</code></pre>
<h3 id="any"><a class="header" href="#any">any</a></h3>
<p>Tests if any element of the iterator matches a predicate.<code>any()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if any of them return <code>true</code>, then so does <code>any()</code>. If they all return <code>false</code>, it returns <code>false</code>.<code>any()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>true</code>, given that no matter what else happens, the result will also be <code>true</code>.An empty iterator returns <code>false</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">assert!(array![1, 2, 3].into_iter().any(|x| x == 2));

assert!(!array![1, 2, 3].into_iter().any(|x| x &gt; 5));
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::any</code></p>
<pre><code class="language-rust">fn any&lt;
    P,
    +core::ops::Fn&lt;P, (Self::Item,)&gt;[Output: bool],
    +Destruct&lt;P&gt;,
    +Destruct&lt;T&gt;,
    +Destruct&lt;Self::Item&gt;,
&gt;(
    ref self: T, predicate: P,
) -&gt; bool</code></pre>
<h3 id="all"><a class="header" href="#all">all</a></h3>
<p>Tests if every element of the iterator matches a predicate.<code>all()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if all of them return <code>true</code>, then so does <code>all()</code>. If any of them return <code>false</code>, it returns <code>false</code>.<code>all()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>false</code>, given that no matter what else happens, the result will also be <code>false</code>.An empty iterator returns <code>true</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">assert!(array![1, 2, 3].into_iter().all(|x| x &gt; 0));

assert!(!array![1, 2, 3].into_iter().all(|x| x &gt; 2));
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::all</code></p>
<pre><code class="language-rust">fn all&lt;
    P,
    +core::ops::Fn&lt;P, (Self::Item,)&gt;[Output: bool],
    +Destruct&lt;P&gt;,
    +Destruct&lt;T&gt;,
    +Destruct&lt;Self::Item&gt;,
&gt;(
    ref self: T, predicate: P,
) -&gt; bool</code></pre>
<h3 id="find"><a class="header" href="#find">find</a></h3>
<p>Searches for an element of an iterator that satisfies a predicate.<code>find()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator as a snapshot, and if any of them return <code>true</code>, then <code>find()</code> returns <a href="%60Some(element)%60"><code>Some(element)</code></a>. If they all return <code>false</code>, it returns <a href="./core-option.html#none"><code>None</code></a>.<code>find()</code> is short-circuiting; in other words, it will stop processing as soon as the closure returns <code>true</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

assert_eq!(iter.find(|x| *x == 2), Option::Some(2));

assert_eq!(iter.find(|x| *x == 5), Option::None);
</code></pre>
<p>Stopping at the first <code>true</code>:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();

assert_eq!(iter.find(|x| *x == 2), Option::Some(2));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Option::Some(3));
</code></pre>
<p>Note that <code>iter.find(f)</code> is equivalent to <code>iter.filter(f).next()</code>.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::find</code></p>
<pre><code class="language-rust">fn find&lt;
    P,
    +core::ops::Fn&lt;P, (@Self::Item,)&gt;[Output: bool],
    +Destruct&lt;P&gt;,
    +Destruct&lt;T&gt;,
    +Destruct&lt;Self::Item&gt;,
&gt;(
    ref self: T, predicate: P,
) -&gt; Option&lt;Self::Item&gt;</code></pre>
<h3 id="filter-1"><a class="header" href="#filter-1">filter</a></h3>
<p>Creates an iterator which uses a closure to determine if an element should be yielded. The closure takes each element as a snapshot.Given an element the closure must return <code>true</code> or <code>false</code>. The returned iterator will yield only the elements for which the closure returns <code>true</code>.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let a = array![0_u32, 1, 2];

let mut iter = a.into_iter().filter(|x| *x &gt; 0);

assert_eq!(iter.next(), Option::Some(1));
assert_eq!(iter.next(), Option::Some(2));
assert_eq!(iter.next(), Option::None);
</code></pre>
<p>Note that <code>iter.filter(f).next()</code> is equivalent to <code>iter.find(f)</code>.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::filter</code></p>
<pre><code class="language-rust">fn filter&lt;
    P,
    +core::ops::Fn&lt;P, (@Self::Item,)&gt;[Output: bool],
    +Destruct&lt;P&gt;,
    +Destruct&lt;T&gt;,
    +Destruct&lt;Self::Item&gt;,
&gt;(
    self: T, predicate: P,
) -&gt; Filter&lt;T, P&gt;</code></pre>
<h3 id="zip"><a class="header" href="#zip">zip</a></h3>
<p>'Zips up' two iterators into a single iterator of pairs.<code>zip()</code> returns a new iterator that will iterate over two other iterators, returning a tuple where the first element comes from the first iterator, and the second element comes from the second iterator.In other words, it zips two iterators together, into a single one.If either iterator returns <a href="./core-option.html#none"><code>None</code></a>, <a href="%60next%60"><code>next</code></a> from the zipped iterator will return <a href="./core-option.html#none"><code>None</code></a>. If the zipped iterator has no more elements to return then each further attempt to advance it will first try to advance the first iterator at most one time and if it still yielded an item try to advance the second iterator at most one time.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter().zip(array![4, 5, 6].into_iter());

assert_eq!(iter.next(), Some((1, 4)));
assert_eq!(iter.next(), Some((2, 5)));
assert_eq!(iter.next(), Some((3, 6)));
assert_eq!(iter.next(), None);
</code></pre>
<p>Since the argument to <code>zip()</code> uses <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>, we can pass anything that can be converted into an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>, not just an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> itself. For example:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter().zip(array![4, 5, 6]);

assert_eq!(iter.next(), Some((1, 4)));
assert_eq!(iter.next(), Some((2, 5)));
assert_eq!(iter.next(), Some((3, 6)));
assert_eq!(iter.next(), None);
</code></pre>
<p><a href="%60enumerate%60"><code>enumerate</code></a>: Iterator::enumerate <a href="%60next%60"><code>next</code></a>: Iterator::next</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::zip</code></p>
<pre><code class="language-rust">fn zip&lt;U, impl UIntoIter: IntoIterator&lt;U&gt;, +Destruct&lt;T&gt;&gt;(
    self: T, other: U,
) -&gt; Zip&lt;T, UIntoIter::IntoIter&gt;</code></pre>
<h3 id="collect"><a class="header" href="#collect">collect</a></h3>
<p>Transforms an iterator into a collection.<code>collect()</code> can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the core library, used in a variety of contexts.The most basic pattern in which <code>collect()</code> is used is to turn one collection into another. You take a collection, call <a href="%60iter%60"><code>iter</code></a> on it, do a bunch of transformations, and then <code>collect()</code> at the end.<code>collect()</code> can also create instances of types that are not typical collections.Because <code>collect()</code> is so general, it can cause problems with type inference. As such, <code>collect()</code> is one of the few times you'll see the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which collection you're trying to collect into.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let doubled: Array&lt;u32&gt; = array![1, 2, 3].into_iter().map(|x| x * 2).collect();

assert_eq!(array![2, 4, 6], doubled);
</code></pre>
<p>Note that we needed the <code>: Array&lt;u32&gt;</code> on the left-hand side.Using the 'turbofish' instead of annotating <code>doubled</code>:</p>
<pre><code class="language-cairo">let doubled = array![1, 2, 3].into_iter().map(|x| x * 2).collect::&lt;Array&lt;u32&gt;&gt;();

assert_eq!(array![2, 4, 6], doubled);
</code></pre>
<p>Because <code>collect()</code> only cares about what you're collecting into, you can still use a partial type hint, <code>_</code>, with the turbofish:</p>
<pre><code class="language-cairo">let doubled = array![1, 2, 3].into_iter().map(|x| x * 2).collect::&lt;Array&lt;_&gt;&gt;();

assert_eq!(array![2, 4, 6], doubled);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::collect</code></p>
<pre><code class="language-rust">fn collect&lt;
    B,
    impl IntoIter: IntoIterator&lt;T&gt;,
    impl ItemEqual: TypeEqual&lt;IntoIter::Iterator::Item, Self::Item&gt;,
    +Destruct&lt;IntoIter::IntoIter&gt;,
    +FromIterator&lt;B, Self::Item&gt;,
    +Destruct&lt;T&gt;,
&gt;(
    self: T,
) -&gt; B</code></pre>
<h3 id="peekable"><a class="header" href="#peekable">peekable</a></h3>
<p>Creates an iterator which can use the <a href="%60peek%60"><code>peek</code></a> method to look at the next element of the iterator. See its documentation for more information.Note that the underlying iterator is still advanced when <a href="%60peek%60"><code>peek</code></a> is called for the first time: In order to retrieve the next element, <a href="%60next%60"><code>next</code></a> is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the <a href="%60next%60"><code>next</code></a> method will occur.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = (1..4_u8).into_iter().peekable();

// peek() lets us see one step into the future
assert_eq!(iter.peek(), Option::Some(1));
assert_eq!(iter.next(), Option::Some(1));

assert_eq!(iter.next(), Option::Some(2));

// we can peek() multiple times, the iterator won't advance
assert_eq!(iter.peek(), Option::Some(3));
assert_eq!(iter.peek(), Option::Some(3));

assert_eq!(iter.next(), Option::Some(3));

// after the iterator is finished, so is peek()
assert_eq!(iter.peek(), Option::None);
assert_eq!(iter.next(), Option::None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::peekable</code></p>
<pre><code class="language-rust">fn peekable(self: T) -&gt; Peekable&lt;T, Self::Item&gt;</code></pre>
<h3 id="take-1"><a class="header" href="#take-1">take</a></h3>
<p>Creates an iterator that yields the first <code>n</code> elements, or fewer if the underlying iterator ends sooner.<code>take(n)</code> yields elements until <code>n</code> elements are yielded or the end of the iterator is reached (whichever happens first). The returned iterator is a prefix of length <code>n</code> if the original iterator contains at least <code>n</code> elements, otherwise it contains all of the (fewer than <code>n</code>) elements of the original iterator.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter().take(2);

assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), None);
</code></pre>
<p>If less than <code>n</code> elements are available, <code>take</code> will limit itself to the size of the underlying iterator:</p>
<pre><code class="language-cairo">let mut iter = array![1, 2].into_iter().take(5);
assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::take</code></p>
<pre><code class="language-rust">fn take(self: T, n: usize) -&gt; Take&lt;T&gt;</code></pre>
<h3 id="sum"><a class="header" href="#sum">sum</a></h3>
<p>Sums the elements of an iterator.Takes each element, adds them together, and returns the result.An empty iterator returns the zero value of the type.<code>sum()</code> can be used to sum any type implementing [<code>Sum</code>][<code>core::iter::Sum</code>], including [<code>Option</code>][<code>Option::sum</code>] and [<code>Result</code>][<code>Result::sum</code>].  # PanicsWhen calling <code>sum()</code> and a primitive integer type is being returned, this method will panic if the computation overflows.  # Examples</p>
<pre><code class="language-cairo">let mut iter = array![1, 2, 3].into_iter();
let sum: usize = iter.sum();

assert_eq!(sum, 6);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::sum</code></p>
<pre><code class="language-rust">fn sum&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;, +Sum&lt;Self::Item&gt;&gt;(self: T) -&gt; Self::Item</code></pre>
<h3 id="product"><a class="header" href="#product">product</a></h3>
<p>Iterates over the entire iterator, multiplying all the elementsAn empty iterator returns the one value of the type.  # PanicsWhen calling <code>product()</code> and a primitive integer type is being returned, this method will panic if the computation overflows.  # Examples</p>
<pre><code class="language-cairo">fn factorial(n: u32) -&gt; u32 {
    (1..=n).into_iter().product()
}
assert_eq!(factorial(0), 1);
assert_eq!(factorial(1), 1);
assert_eq!(factorial(5), 120);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::product</code></p>
<pre><code class="language-rust">fn product&lt;+Destruct&lt;T&gt;, +Destruct&lt;Self::Item&gt;, +Product&lt;Self::Item&gt;&gt;(self: T) -&gt; Self::Item</code></pre>
<h3 id="chain"><a class="header" href="#chain">chain</a></h3>
<p>Takes two iterators and creates a new iterator over both in sequence.<code>chain()</code> will return a new iterator which will first iterate over values from the first iterator and then over values from the second iterator.In other words, it links two iterators together, in a chain. ðŸ”—Arguments do not have to be of the same type as long as the underlying iterated over items are.  # ExamplesBasic usage:</p>
<pre><code class="language-cairo">use core::ops::Range;

let a: Array&lt;u8&gt; = array![7, 8, 9];
let b: Range&lt;u8&gt; = 0..5;

let mut iter = a.into_iter().chain(b.into_iter());

assert_eq!(iter.next(), Option::Some(7));
assert_eq!(iter.next(), Option::Some(8));
assert_eq!(iter.next(), Option::Some(9));
assert_eq!(iter.next(), Option::Some(0));
assert_eq!(iter.next(), Option::Some(1));
assert_eq!(iter.next(), Option::Some(2));
assert_eq!(iter.next(), Option::Some(3));
assert_eq!(iter.next(), Option::Some(4));
assert_eq!(iter.next(), Option::None);
</code></pre>
<p>Since the argument to <code>chain()</code> uses <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>, we can pass anything that can be converted into an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a>, not just an <a href="./core-iter-traits-iterator-Iterator.html"><code>Iterator</code></a> itself. For example, arrays implement <a href="./core-iter-traits-collect-IntoIterator.html"><code>IntoIterator</code></a>, and so can be passed to <code>chain()</code> directly:</p>
<pre><code class="language-cairo">let a = array![1, 2, 3];
let b = array![4, 5, 6];

let mut iter = a.into_iter().chain(b);

assert_eq!(iter.next(), Option::Some(1));
assert_eq!(iter.next(), Option::Some(2));
assert_eq!(iter.next(), Option::Some(3));
assert_eq!(iter.next(), Option::Some(4));
assert_eq!(iter.next(), Option::Some(5));
assert_eq!(iter.next(), Option::Some(6));
assert_eq!(iter.next(), Option::None);
</code></pre>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::chain</code></p>
<pre><code class="language-rust">fn chain&lt;
    U,
    impl IntoIterU: IntoIterator&lt;U&gt;,
    +TypeEqual&lt;Self::Item, IntoIterU::Iterator::Item&gt;,
    +Destruct&lt;T&gt;,
&gt;(
    self: T, other: U,
) -&gt; Chain&lt;T, IntoIterU::IntoIter&gt;</code></pre>
<h2 id="trait-types-33"><a class="header" href="#trait-types-33">Trait types</a></h2>
<h3 id="item"><a class="header" href="#item">Item</a></h3>
<p>The type of the elements being iterated over.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::Item</code></p>
<pre><code class="language-rust">type Item;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typeequal"><a class="header" href="#typeequal">TypeEqual</a></h1>
<p>A trait that can be used to disable implementations based on the types of the generic args. Assumes that <code>TypeEqualImpl&lt;T&gt;</code> is the only implementation of this trait.Primarily used for optimizations by enabling type-specific implementations. Since <code>TypeEqualImpl&lt;T&gt;</code> is the only implementation, adding <code>-TypeEqual&lt;T, U&gt;</code> as a trait bound ensures the implementation is only available when T and U are different types.</p>
<p>Fully qualified path: <code>core::metaprogramming::TypeEqual</code></p>
<pre><code class="language-rust">pub trait TypeEqual&lt;S, T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendformattedtobytearray"><a class="header" href="#appendformattedtobytearray">AppendFormattedToByteArray</a></h1>
<p>A trait for appending the ASCII representation of a number to an existing <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::to_byte_array::AppendFormattedToByteArray</code></p>
<pre><code class="language-rust">pub trait AppendFormattedToByteArray&lt;T&gt;</code></pre>
<h2 id="trait-functions-145"><a class="header" href="#trait-functions-145">Trait functions</a></h2>
<h3 id="append_formatted_to_byte_array"><a class="header" href="#append_formatted_to_byte_array">append_formatted_to_byte_array</a></h3>
<p>Appends the ASCII representation of the value to the provided <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::to_byte_array::AppendFormattedToByteArray;

let mut buffer = "Count: ";
let num: u32 = 42;
num.append_formatted_to_byte_array(ref buffer, 10);
assert!(buffer == "Count: 42");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array::AppendFormattedToByteArray::append_formatted_to_byte_array</code></p>
<pre><code class="language-rust">fn append_formatted_to_byte_array(self: @T, ref byte_array: ByteArray, base: NonZero&lt;T&gt;)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatasbytearray"><a class="header" href="#formatasbytearray">FormatAsByteArray</a></h1>
<p>A trait for formatting values into their ASCII string representation in a <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::to_byte_array::FormatAsByteArray</code></p>
<pre><code class="language-rust">pub trait FormatAsByteArray&lt;T&gt;</code></pre>
<h2 id="trait-functions-146"><a class="header" href="#trait-functions-146">Trait functions</a></h2>
<h3 id="format_as_byte_array"><a class="header" href="#format_as_byte_array">format_as_byte_array</a></h3>
<p>Returns a new <code>ByteArray</code> containing the ASCII representation of the value.  # Examples</p>
<pre><code class="language-cairo">use core::to_byte_array::FormatAsByteArray;

let num: u32 = 42;
let formatted = num.format_as_byte_array(16);
assert!(formatted, "2a");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array::FormatAsByteArray::format_as_byte_array</code></p>
<pre><code class="language-rust">fn format_as_byte_array(self: @T, base: NonZero&lt;T&gt;) -&gt; ByteArray</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impls-9"><a class="header" href="#impls-9">Impls</a></h1>
<ul>
<li>
<p><a href="./core-circuit-CircuitElementDrop.html">CircuitElementDrop</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementCopy.html">CircuitElementCopy</a></p>
</li>
<li>
<p><a href="./core-circuit-DestructFailureGuarantee.html">DestructFailureGuarantee</a></p>
</li>
<li>
<p><a href="./core-array-SpanIndex.html">SpanIndex</a></p>
</li>
<li>
<p><a href="./core-option-DestructOption.html">DestructOption</a></p>
</li>
<li>
<p><a href="./core-ec-EcStateImpl.html">EcStateImpl</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointImpl.html">EcPointImpl</a></p>
</li>
<li>
<p><a href="./core-pedersen-PedersenImpl.html">PedersenImpl</a></p>
</li>
<li>
<p><a href="./core-poseidon-PoseidonImpl.html">PoseidonImpl</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-SubPointersDeref.html">SubPointersDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-SubPointersMutDeref.html">SubPointersMutDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorableStoragePointerReadAccess.html">StorableStoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageNodeDeref.html">StorageNodeDeref</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageNodeMutDeref.html">StorageNodeMutDeref</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31Impl.html">Bytes31Impl</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayImpl.html">ByteArrayImpl</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementdrop"><a class="header" href="#circuitelementdrop">CircuitElementDrop</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitElementDrop</code></p>
<pre><code class="language-rust">pub impl CircuitElementDrop&lt;T&gt; of Drop&lt;CircuitElement&lt;T&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementcopy"><a class="header" href="#circuitelementcopy">CircuitElementCopy</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitElementCopy</code></p>
<pre><code class="language-rust">pub impl CircuitElementCopy&lt;T&gt; of Copy&lt;CircuitElement&lt;T&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructfailureguarantee"><a class="header" href="#destructfailureguarantee">DestructFailureGuarantee</a></h1>
<p>Fully qualified path: <code>core::circuit::DestructFailureGuarantee</code></p>
<pre><code class="language-rust">pub impl DestructFailureGuarantee of Destruct&lt;CircuitFailureGuarantee&gt;</code></pre>
<h2 id="impl-functions"><a class="header" href="#impl-functions">Impl functions</a></h2>
<h3 id="destruct-2"><a class="header" href="#destruct-2">destruct</a></h3>
<p>Fully qualified path: <code>core::circuit::DestructFailureGuarantee::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: CircuitFailureGuarantee) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spanindex"><a class="header" href="#spanindex">SpanIndex</a></h1>
<p>Fully qualified path: <code>core::array::SpanIndex</code></p>
<pre><code class="language-rust">pub impl SpanIndex&lt;T&gt; of IndexView&lt;Span&lt;T&gt;, usize, @T&gt;</code></pre>
<h2 id="impl-functions-1"><a class="header" href="#impl-functions-1">Impl functions</a></h2>
<h3 id="index-10"><a class="header" href="#index-10">index</a></h3>
<p>Returns a snapshot of the element at the given index.  # Examples</p>
<pre><code class="language-cairo">let span: @Span&lt;u8&gt; = @array![1, 2, 3].span();
let element: @u8 = span[0];
assert!(element == @1);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanIndex::index</code></p>
<pre><code class="language-rust">fn index(self: @Span&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructoption"><a class="header" href="#destructoption">DestructOption</a></h1>
<p>Fully qualified path: <code>core::option::DestructOption</code></p>
<pre><code class="language-rust">pub impl DestructOption&lt;T, +Destruct&lt;T&gt;, -Drop&lt;Option&lt;T&gt;&gt;&gt; of Destruct&lt;Option&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-2"><a class="header" href="#impl-functions-2">Impl functions</a></h2>
<h3 id="destruct-3"><a class="header" href="#destruct-3">destruct</a></h3>
<p>Fully qualified path: <code>core::option::DestructOption::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: Option&lt;T&gt;) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstateimpl"><a class="header" href="#ecstateimpl">EcStateImpl</a></h1>
<p>Fully qualified path: <code>core::ec::EcStateImpl</code></p>
<pre><code class="language-rust">pub impl EcStateImpl of EcStateTrait</code></pre>
<h2 id="impl-functions-3"><a class="header" href="#impl-functions-3">Impl functions</a></h2>
<h3 id="init-1"><a class="header" href="#init-1">init</a></h3>
<p>Initializes an EC computation with the zero point.  # Examples</p>
<pre><code class="language-cairo">let mut state = EcStateTrait::init();
</code></pre>
<p>Fully qualified path: <code>core::ec::EcStateImpl::init</code></p>
<pre><code class="language-rust">fn init() -&gt; EcState nopanic</code></pre>
<h3 id="add-4"><a class="header" href="#add-4">add</a></h3>
<p>Adds a point to the computation.  # Arguments<code>p</code> - The non-zero point to add</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::add</code></p>
<pre><code class="language-rust">fn add(ref self: EcState, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="sub-3"><a class="header" href="#sub-3">sub</a></h3>
<p>Subtracts a point to the computation.  # Arguments<code>p</code> - The non-zero point to subtract</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::sub</code></p>
<pre><code class="language-rust">fn sub(ref self: EcState, p: NonZeroEcPoint)</code></pre>
<h3 id="add_mul-1"><a class="header" href="#add_mul-1">add_mul</a></h3>
<p>Adds the product <code>p * scalar</code> to the state.  # Arguments<code>scalar</code> - The scalar to multiply the point by * <code>p</code> - The non-zero point to multiply and add</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::add_mul</code></p>
<pre><code class="language-rust">fn add_mul(ref self: EcState, scalar: felt252, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="finalize_nz-1"><a class="header" href="#finalize_nz-1">finalize_nz</a></h3>
<p>Finalizes the EC computation and returns the result as a non-zero point.  # Returns<code>Option&lt;NonZeroEcPoint&gt;</code> - The resulting point, or None if the result is the zero point  # PanicsPanics if the result is the point at infinity.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::finalize_nz</code></p>
<pre><code class="language-rust">fn finalize_nz(self: EcState) -&gt; Option&lt;NonZeroEcPoint&gt; nopanic</code></pre>
<h3 id="finalize-3"><a class="header" href="#finalize-3">finalize</a></h3>
<p>Finalizes the EC computation and returns the result.Returns the zero point if the computation results in the point at infinity.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: EcState) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpointimpl"><a class="header" href="#ecpointimpl">EcPointImpl</a></h1>
<p>Fully qualified path: <code>core::ec::EcPointImpl</code></p>
<pre><code class="language-rust">pub impl EcPointImpl of EcPointTrait</code></pre>
<h2 id="impl-functions-4"><a class="header" href="#impl-functions-4">Impl functions</a></h2>
<h3 id="new-7"><a class="header" href="#new-7">new</a></h3>
<p>Creates a new EC point from its (x, y) coordinates.  # Arguments<code>x</code> - The x-coordinate of the point * <code>y</code> - The y-coordinate of the point  # ReturnsReturns <code>None</code> if the point (x, y) is not on the curve.  # Examples</p>
<pre><code class="language-cairo">let point = EcPointTrait::new(
    x: 336742005567258698661916498343089167447076063081786685068305785816009957563,
    y: 1706004133033694959518200210163451614294041810778629639790706933324248611779,
).unwrap();
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new</code></p>
<pre><code class="language-rust">fn new(x: felt252, y: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz-1"><a class="header" href="#new_nz-1">new_nz</a></h3>
<p>Creates a new NonZero EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_nz</code></p>
<pre><code class="language-rust">fn new_nz(x: felt252, y: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="new_from_x-1"><a class="header" href="#new_from_x-1">new_from_x</a></h3>
<p>Creates a new EC point from its x coordinate.  # Arguments<code>x</code> - The x-coordinate of the point  # ReturnsReturns <code>None</code> if no point with the given x-coordinate exists on the curve.  # PanicsPanics if <code>x</code> is 0, as this would be the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let valid = EcPointTrait::new_from_x(1);
assert!(valid.is_some());
let invalid = EcPointTrait::new_from_x(0);
assert!(invalid.is_none());
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_from_x</code></p>
<pre><code class="language-rust">fn new_from_x(x: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz_from_x-1"><a class="header" href="#new_nz_from_x-1">new_nz_from_x</a></h3>
<p>Creates a new NonZero EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_nz_from_x</code></p>
<pre><code class="language-rust">fn new_nz_from_x(x: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="coordinates-1"><a class="header" href="#coordinates-1">coordinates</a></h3>
<p>Returns the coordinates of the EC point.  # ReturnsA tuple containing the (x, y) coordinates of the point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let point_nz = EcPointTrait::new_nz_from_x(1).unwrap();
let (x, _y) = point_nz.coordinates();
assert!(x == 1);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointImpl::coordinates</code></p>
<pre><code class="language-rust">fn coordinates(self: NonZeroEcPoint) -&gt; (felt252, felt252)</code></pre>
<h3 id="x-1"><a class="header" href="#x-1">x</a></h3>
<p>Returns the x coordinate of the EC point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let point_nz = EcPointTrait::new_nz_from_x(1).unwrap();
let x = point_nz.x();
assert!(x == 1);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointImpl::x</code></p>
<pre><code class="language-rust">fn x(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="y-1"><a class="header" href="#y-1">y</a></h3>
<p>Returns the y coordinate of the EC point.  # PanicsPanics if the point is the point at infinity.  # Examples</p>
<pre><code class="language-cairo">let gen_point =
EcPointTrait::new_nz_from_x(0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca).unwrap();
let y = gen_point.y();
assert!(y == 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f);
</code></pre>
<p>Fully qualified path: <code>core::ec::EcPointImpl::y</code></p>
<pre><code class="language-rust">fn y(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="mul-4"><a class="header" href="#mul-4">mul</a></h3>
<p>Computes the product of an EC point by the given scalar.  # Arguments<code>scalar</code> - The scalar to multiply the point by  # ReturnsThe resulting point after scalar multiplication.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::mul</code></p>
<pre><code class="language-rust">fn mul(self: EcPoint, scalar: felt252) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersenimpl"><a class="header" href="#pedersenimpl">PedersenImpl</a></h1>
<p>A trait for creating a new Pedersen hash state.</p>
<p>Fully qualified path: <code>core::pedersen::PedersenImpl</code></p>
<pre><code class="language-rust">pub impl PedersenImpl of PedersenTrait</code></pre>
<h2 id="impl-functions-5"><a class="header" href="#impl-functions-5">Impl functions</a></h2>
<h3 id="new-8"><a class="header" href="#new-8">new</a></h3>
<p>Creates a new Pedersen hash state with the given base value.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
assert!(state.state == 0);
</code></pre>
<p>Fully qualified path: <code>core::pedersen::PedersenImpl::new</code></p>
<pre><code class="language-rust">fn new(base: felt252) -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidonimpl"><a class="header" href="#poseidonimpl">PoseidonImpl</a></h1>
<p>A trait for creating a new Poseidon hash state.</p>
<p>Fully qualified path: <code>core::poseidon::PoseidonImpl</code></p>
<pre><code class="language-rust">pub impl PoseidonImpl of PoseidonTrait</code></pre>
<h2 id="impl-functions-6"><a class="header" href="#impl-functions-6">Impl functions</a></h2>
<h3 id="new-9"><a class="header" href="#new-9">new</a></h3>
<p>Creates an initial state with all fields set to 0.  # Examples</p>
<pre><code class="language-cairo">use core::poseidon::PoseidonTrait;

let mut state = PoseidonTrait::new();
</code></pre>
<p>Fully qualified path: <code>core::poseidon::PoseidonImpl::new</code></p>
<pre><code class="language-rust">fn new() -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersderef"><a class="header" href="#subpointersderef">SubPointersDeref</a></h1>
<p>This makes the sub-pointers members directly accessible from a pointer to the parent struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersDeref</code></p>
<pre><code class="language-rust">pub impl SubPointersDeref&lt;T, +SubPointers&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePointer&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-7"><a class="header" href="#impl-functions-7">Impl functions</a></h2>
<h3 id="deref-3"><a class="header" href="#deref-3">deref</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersDeref::deref</code></p>
<pre><code class="language-rust">fn deref(self: StoragePointer&lt;T&gt;) -&gt; Self::Target</code></pre>
<h2 id="impl-types"><a class="header" href="#impl-types">Impl types</a></h2>
<h3 id="target-9"><a class="header" href="#target-9">Target</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersDeref::Target</code></p>
<pre><code class="language-rust">type Target = SubPointers::&lt;T&gt;::SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersmutderef"><a class="header" href="#subpointersmutderef">SubPointersMutDeref</a></h1>
<p>This makes the sub-pointers members directly accessible from a pointer to the parent struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersMutDeref</code></p>
<pre><code class="language-rust">pub impl SubPointersMutDeref&lt;T, +SubPointersMut&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePointer&lt;Mutable&lt;T&gt;&gt;&gt;</code></pre>
<h2 id="impl-functions-8"><a class="header" href="#impl-functions-8">Impl functions</a></h2>
<h3 id="deref-4"><a class="header" href="#deref-4">deref</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersMutDeref::deref</code></p>
<pre><code class="language-rust">fn deref(self: StoragePointer&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::Target</code></pre>
<h2 id="impl-types-1"><a class="header" href="#impl-types-1">Impl types</a></h2>
<h3 id="target-10"><a class="header" href="#target-10">Target</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::SubPointersMutDeref::Target</code></p>
<pre><code class="language-rust">type Target = SubPointersMut::&lt;T&gt;::SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storablestoragepointerreadaccess"><a class="header" href="#storablestoragepointerreadaccess">StorableStoragePointerReadAccess</a></h1>
<p>Simple implementation of <code>StoragePointerReadAccess</code> for any type that implements <code>Store</code> for any offset.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess</code></p>
<pre><code class="language-rust">pub impl StorableStoragePointerReadAccess&lt;
    T, +starknet::Store&lt;T&gt;,
&gt; of StoragePointerReadAccess&lt;StoragePointer&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-9"><a class="header" href="#impl-functions-9">Impl functions</a></h2>
<h3 id="read-4"><a class="header" href="#read-4">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: @StoragePointer&lt;T&gt;) -&gt; T</code></pre>
<h2 id="impl-types-2"><a class="header" href="#impl-types-2">Impl types</a></h2>
<h3 id="value-11"><a class="header" href="#value-11">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess::Value</code></p>
<pre><code class="language-rust">type Value = T;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenodederef"><a class="header" href="#storagenodederef">StorageNodeDeref</a></h1>
<p>This makes the storage node members directly accessible from a path to the parent struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeDeref</code></p>
<pre><code class="language-rust">pub impl StorageNodeDeref&lt;T, +StorageNode&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePath&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-10"><a class="header" href="#impl-functions-10">Impl functions</a></h2>
<h3 id="deref-5"><a class="header" href="#deref-5">deref</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeDeref::deref</code></p>
<pre><code class="language-rust">fn deref(self: StoragePath&lt;T&gt;) -&gt; Self::Target</code></pre>
<h2 id="impl-types-3"><a class="header" href="#impl-types-3">Impl types</a></h2>
<h3 id="target-11"><a class="header" href="#target-11">Target</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeDeref::Target</code></p>
<pre><code class="language-rust">type Target = StorageNode::&lt;T&gt;::NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenodemutderef"><a class="header" href="#storagenodemutderef">StorageNodeMutDeref</a></h1>
<p>This makes the storage node members directly accessible from a path to the parent struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeMutDeref</code></p>
<pre><code class="language-rust">pub impl StorageNodeMutDeref&lt;T, +StorageNodeMut&lt;T&gt;&gt; of core::ops::Deref&lt;StoragePath&lt;Mutable&lt;T&gt;&gt;&gt;</code></pre>
<h2 id="impl-functions-11"><a class="header" href="#impl-functions-11">Impl functions</a></h2>
<h3 id="deref-6"><a class="header" href="#deref-6">deref</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeMutDeref::deref</code></p>
<pre><code class="language-rust">fn deref(self: StoragePath&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::Target</code></pre>
<h2 id="impl-types-4"><a class="header" href="#impl-types-4">Impl types</a></h2>
<h3 id="target-12"><a class="header" href="#target-12">Target</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageNodeMutDeref::Target</code></p>
<pre><code class="language-rust">type Target = StorageNodeMut::&lt;T&gt;::NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31impl"><a class="header" href="#bytes31impl">Bytes31Impl</a></h1>
<p>A trait for accessing a specific byte of a <code>bytes31</code> type.</p>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Impl</code></p>
<pre><code class="language-rust">pub impl Bytes31Impl of Bytes31Trait</code></pre>
<h2 id="impl-functions-12"><a class="header" href="#impl-functions-12">Impl functions</a></h2>
<h3 id="at-6"><a class="header" href="#at-6">at</a></h3>
<p>Returns the byte at the given index (LSB's index is 0).Assumes that <code>index &lt; BYTES_IN_BYTES31</code>. If the assumption is not met, the behavior is undefined.  # Examples</p>
<pre><code class="language-cairo">let bytes: bytes31 = 1_u8.into();
assert!(bytes.at(0) == 1);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Impl::at</code></p>
<pre><code class="language-rust">fn at(self: @bytes31, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearrayimpl"><a class="header" href="#bytearrayimpl">ByteArrayImpl</a></h1>
<p>Functions associated with the <code>ByteArray</code> type.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl</code></p>
<pre><code class="language-rust">pub impl ByteArrayImpl of ByteArrayTrait</code></pre>
<h2 id="impl-functions-13"><a class="header" href="#impl-functions-13">Impl functions</a></h2>
<h3 id="append_word-1"><a class="header" href="#append_word-1">append_word</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>.This function assumes that: 1. <code>word</code> could be validly converted to a <code>bytes31</code> which has no more than <code>len</code> bytes of data. 2. len &lt;= BYTES_IN_BYTES31.If these assumptions are not met, it can corrupt the <code>ByteArray</code>. Thus, this should be a private function. We could add masking/assertions but it would be more expensive.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_word('word', 4);
assert!(ba == "word");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word</code></p>
<pre><code class="language-rust">fn append_word(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append-3"><a class="header" href="#append-3">append</a></h3>
<p>Appends a <code>ByteArray</code> to the end of another <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "1";
ba.append(@"2");
assert!(ba == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append</code></p>
<pre><code class="language-rust">fn append(ref self: ByteArray, other: @ByteArray)</code></pre>
<h3 id="concat-1"><a class="header" href="#concat-1">concat</a></h3>
<p>Concatenates two <code>ByteArray</code> and returns the result.The content of <code>left</code> is cloned in a new memory segment. # Examples</p>
<pre><code class="language-cairo">let ba = "1";
let other_ba = "2";
let result = ByteArrayTrait::concat(@ba, @other_ba);
assert!(result == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::concat</code></p>
<pre><code class="language-rust">fn concat(left: @ByteArray, right: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_byte-1"><a class="header" href="#append_byte-1">append_byte</a></h3>
<p>Appends a single byte to the end of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_byte(0);
assert!(ba == "0");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_byte</code></p>
<pre><code class="language-rust">fn append_byte(ref self: ByteArray, byte: u8)</code></pre>
<h3 id="len-5"><a class="header" href="#len-5">len</a></h3>
<p>Returns the length of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let len = ba.len();
assert!(len == 10);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::len</code></p>
<pre><code class="language-rust">fn len(self: @ByteArray) -&gt; usize</code></pre>
<h3 id="at-7"><a class="header" href="#at-7">at</a></h3>
<p>Returns an option of the byte at the given index of <code>self</code> or <code>None</code> if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let byte = ba.at(0).unwrap();
assert!(byte == 98);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::at</code></p>
<pre><code class="language-rust">fn at(self: @ByteArray, index: usize) -&gt; Option&lt;u8&gt;</code></pre>
<h3 id="rev-1"><a class="header" href="#rev-1">rev</a></h3>
<p>Returns a <code>ByteArray</code> with the reverse order of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
let rev_ba = ba.rev();
assert!(rev_ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::rev</code></p>
<pre><code class="language-rust">fn rev(self: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_word_rev-1"><a class="header" href="#append_word_rev-1">append_word_rev</a></h3>
<p>Appends the reverse of the given word to the end of <code>self</code>.This function assumes that: 1. len &lt; 31 2. word is validly convertible to bytes31 of length <code>len</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_word_rev('123', 3);
assert!(ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word_rev</code></p>
<pre><code class="language-rust">fn append_word_rev(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_word_fits_into_pending-1"><a class="header" href="#append_word_fits_into_pending-1">append_word_fits_into_pending</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>, assuming there is enough space in the pending word (<code>self.pending_word_len + len &lt; BYTES_IN_BYTES31</code>).<code>word</code> is of type <code>felt252</code> but actually represents a <code>bytes31</code>. It is represented as a <code>felt252</code> to improve performance of building the <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word_fits_into_pending</code></p>
<pre><code class="language-rust">fn append_word_fits_into_pending(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_split_index_lt_16-1"><a class="header" href="#append_split_index_lt_16-1">append_split_index_lt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that <code>0 &lt; split_index &lt; 16</code>.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_lt_16</code></p>
<pre><code class="language-rust">fn append_split_index_lt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split_index_16-1"><a class="header" href="#append_split_index_16-1">append_split_index_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is exactly 16.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_16</code></p>
<pre><code class="language-rust">fn append_split_index_16(ref self: ByteArray, word: felt252)</code></pre>
<h3 id="append_split_index_gt_16-1"><a class="header" href="#append_split_index_gt_16-1">append_split_index_gt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is &gt; 16.<code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_gt_16</code></p>
<pre><code class="language-rust">fn append_split_index_gt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split-1"><a class="header" href="#append_split-1">append_split</a></h3>
<p>A helper function to append a remainder to <code>self</code>, by: 1. completing <code>self.pending_word</code> to a full word using <code>complete_full_word</code>, assuming it's validly convertible to a <code>bytes31</code> of length exactly <code>BYTES_IN_BYTES31 - self.pending_word_len</code>. 2. Setting <code>self.pending_word</code> to <code>new_pending</code>.Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split</code></p>
<pre><code class="language-rust">fn append_split(ref self: ByteArray, complete_full_word: felt252, new_pending: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-types-19"><a class="header" href="#extern-types-19">Extern types</a></h1>
<ul>
<li>
<p><a href="./core-RangeCheck.html">RangeCheck</a></p>
</li>
<li>
<p><a href="./core-SegmentArena.html">SegmentArena</a></p>
</li>
<li>
<p><a href="./core-felt252.html">felt252</a></p>
</li>
<li>
<p><a href="./core-circuit-RangeCheck96.html">RangeCheck96</a></p>
</li>
<li>
<p><a href="./core-circuit-AddMod.html">AddMod</a></p>
</li>
<li>
<p><a href="./core-circuit-MulMod.html">MulMod</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitModulus.html">CircuitModulus</a></p>
</li>
<li>
<p><a href="./core-circuit-Circuit.html">Circuit</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInput.html">CircuitInput</a></p>
</li>
<li>
<p><a href="./core-box-Box.html">Box</a></p>
</li>
<li>
<p><a href="./core-nullable-Nullable.html">Nullable</a></p>
</li>
<li>
<p><a href="./core-array-Array.html">Array</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252Dict.html">Felt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252Dict.html">SquashedFelt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntry.html">Felt252DictEntry</a></p>
</li>
<li>
<p><a href="./core-ec-EcOp.html">EcOp</a></p>
</li>
<li>
<p><a href="./core-ec-EcPoint.html">EcPoint</a></p>
</li>
<li>
<p><a href="./core-ec-EcState.html">EcState</a></p>
</li>
<li>
<p><a href="./core-integer-u128.html">u128</a></p>
</li>
<li>
<p><a href="./core-integer-U128MulGuarantee.html">U128MulGuarantee</a></p>
</li>
<li>
<p><a href="./core-integer-Bitwise.html">Bitwise</a></p>
</li>
<li>
<p><a href="./core-integer-u8.html">u8</a></p>
</li>
<li>
<p><a href="./core-integer-u16.html">u16</a></p>
</li>
<li>
<p><a href="./core-integer-u32.html">u32</a></p>
</li>
<li>
<p><a href="./core-integer-u64.html">u64</a></p>
</li>
<li>
<p><a href="./core-integer-i8.html">i8</a></p>
</li>
<li>
<p><a href="./core-integer-i16.html">i16</a></p>
</li>
<li>
<p><a href="./core-integer-i32.html">i32</a></p>
</li>
<li>
<p><a href="./core-integer-i64.html">i64</a></p>
</li>
<li>
<p><a href="./core-integer-i128.html">i128</a></p>
</li>
<li>
<p><a href="./core-gas-BuiltinCosts.html">BuiltinCosts</a></p>
</li>
<li>
<p><a href="./core-gas-GasBuiltin.html">GasBuiltin</a></p>
</li>
<li>
<p><a href="./core-pedersen-Pedersen.html">Pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon-Poseidon.html">Poseidon</a></p>
</li>
<li>
<p><a href="./core-starknet-System.html">System</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">starknet::storage_access::StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">starknet::contract_address::ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">starknet::class_hash::ClassHash</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">starknet::storage_access::StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageBaseAddress.html">StorageBaseAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">starknet::contract_address::ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1Point.html">Secp256k1Point</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1Point.html">Secp256r1Point</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">starknet::class_hash::ClassHash</a></p>
</li>
<li>
<p><a href="./core-zeroable-NonZero.html">NonZero</a></p>
</li>
<li>
<p><a href="./core-bytes_31-bytes31.html">bytes31</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangecheck"><a class="header" href="#rangecheck">RangeCheck</a></h1>
<p>General purpose implicits.</p>
<p>Fully qualified path: <code>core::RangeCheck</code></p>
<pre><code class="language-rust">pub extern type RangeCheck</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segmentarena"><a class="header" href="#segmentarena">SegmentArena</a></h1>
<p>Fully qualified path: <code>core::SegmentArena</code></p>
<pre><code class="language-rust">pub extern type SegmentArena</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252"><a class="header" href="#felt252">felt252</a></h1>
<p><code>felt252</code> is the basic field element used in Cairo.It corresponds to an integer in the range 0 â‰¤ x &lt; P where P is a very large prime number currently equal to 2^251 + 17â‹…2^192 + 1.Any operation that uses <code>felt252</code> will be computed modulo P.</p>
<p>Fully qualified path: <code>core::felt252</code></p>
<pre><code class="language-rust">pub extern type felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangecheck96"><a class="header" href="#rangecheck96">RangeCheck96</a></h1>
<p>Range check builtin for 96-bit operations.</p>
<p>Fully qualified path: <code>core::circuit::RangeCheck96</code></p>
<pre><code class="language-rust">pub extern type RangeCheck96</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addmod"><a class="header" href="#addmod">AddMod</a></h1>
<p>Builtin for modular addition operations.</p>
<p>Fully qualified path: <code>core::circuit::AddMod</code></p>
<pre><code class="language-rust">pub extern type AddMod</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mulmod"><a class="header" href="#mulmod">MulMod</a></h1>
<p>Builtin for modular multiplication operations.</p>
<p>Fully qualified path: <code>core::circuit::MulMod</code></p>
<pre><code class="language-rust">pub extern type MulMod</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitmodulus"><a class="header" href="#circuitmodulus">CircuitModulus</a></h1>
<p>A type that can be used as a circuit modulus (a u384 that is not zero or one).The modulus defines the finite field over which the circuit operates. It must be: - A 384-bit number (represented as four 96-bit limbs) - Not zero or one - Typically a prime number for cryptographic applications</p>
<p>Fully qualified path: <code>core::circuit::CircuitModulus</code></p>
<pre><code class="language-rust">pub extern type CircuitModulus</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-1"><a class="header" href="#circuit-1">Circuit</a></h1>
<p>A type that creates a circuit from a tuple of outputs.This type represents a complete circuit instance, constructed from its output gates. The type parameter <code>Outputs</code> defines the structure of the circuit's outputs.</p>
<p>Fully qualified path: <code>core::circuit::Circuit</code></p>
<pre><code class="language-rust">pub extern type Circuit&lt;Outputs&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitinput"><a class="header" href="#circuitinput">CircuitInput</a></h1>
<p>Defines an input for a circuit.Represents an input signal in the circuit, indexed by <code>N</code>. Each input must be assigned a value before circuit evaluation.</p>
<p>Fully qualified path: <code>core::circuit::CircuitInput</code></p>
<pre><code class="language-rust">#[phantom]
pub extern type CircuitInput&lt;const N: usize&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-1"><a class="header" href="#box-1">Box</a></h1>
<p>A <code>Box</code> is a type that points to a wrapped value. It allows for cheap moving around of the value, as its size is small, and may wrap a large size.</p>
<p>Fully qualified path: <code>core::box::Box</code></p>
<pre><code class="language-rust">pub extern type Box&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable-1"><a class="header" href="#nullable-1">Nullable</a></h1>
<p>A type that can either be null or contain a boxed value.</p>
<p>Fully qualified path: <code>core::nullable::Nullable</code></p>
<pre><code class="language-rust">pub extern type Nullable&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<p>A collection of elements of the same type contiguous in memory.</p>
<p>Fully qualified path: <code>core::array::Array</code></p>
<pre><code class="language-rust">pub extern type Array&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dict"><a class="header" href="#felt252dict">Felt252Dict</a></h1>
<p>A dictionary that maps <code>felt252</code> keys to a value of any type.</p>
<p>Fully qualified path: <code>core::dict::Felt252Dict</code></p>
<pre><code class="language-rust">pub extern type Felt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="squashedfelt252dict"><a class="header" href="#squashedfelt252dict">SquashedFelt252Dict</a></h1>
<p>A dictionary in a squashed state. It cannot be mutated anymore.</p>
<p>Fully qualified path: <code>core::dict::SquashedFelt252Dict</code></p>
<pre><code class="language-rust">pub extern type SquashedFelt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictentry"><a class="header" href="#felt252dictentry">Felt252DictEntry</a></h1>
<p>An intermediate type that is returned after calling the <code>entry</code> method that consumes ownership of the dictionary. This ensures that the dictionary cannot be mutated until the entry is finalized, which restores ownership of the dictionary.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictEntry</code></p>
<pre><code class="language-rust">pub extern type Felt252DictEntry&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecop"><a class="header" href="#ecop">EcOp</a></h1>
<p>Fully qualified path: <code>core::ec::EcOp</code></p>
<pre><code class="language-rust">pub extern type EcOp</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpoint"><a class="header" href="#ecpoint">EcPoint</a></h1>
<p>A point on the STARK curve.Points can be created using <a href="%60EcPointTrait::new%60"><code>EcPointTrait::new</code></a> or <a href="%60EcPointTrait::new_from_x%60"><code>EcPointTrait::new_from_x</code></a>. The zero point represents the point at infinity.</p>
<p>Fully qualified path: <code>core::ec::EcPoint</code></p>
<pre><code class="language-rust">pub extern type EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstate"><a class="header" href="#ecstate">EcState</a></h1>
<p>Elliptic curve state.Use this to perform multiple point operations efficiently. Initialize with <a href="%60EcStateTrait::init%60"><code>EcStateTrait::init</code></a>, add points with <a href="%60EcStateTrait::add%60"><code>EcStateTrait::add</code></a> or <a href="%60EcStateTrait::add_mul%60"><code>EcStateTrait::add_mul</code></a>, and finalize with <a href="%60EcStateTrait::finalize%60"><code>EcStateTrait::finalize</code></a>.</p>
<p>Fully qualified path: <code>core::ec::EcState</code></p>
<pre><code class="language-rust">pub extern type EcState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128"><a class="header" href="#u128">u128</a></h1>
<p>The 128-bit unsigned integer type.</p>
<p>Fully qualified path: <code>core::integer::u128</code></p>
<pre><code class="language-rust">pub extern type u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128mulguarantee"><a class="header" href="#u128mulguarantee">U128MulGuarantee</a></h1>
<p>A type that contains 4 u128s (a, b, c, d) and guarantees that <code>a * b = 2**128 * c + d</code>.The guarantee is verified by <code>u128_mul_guarantee_verify</code>, which is the only way to destruct this type. This way, one can trust that the guarantee holds although it has not yet been verified.</p>
<p>Fully qualified path: <code>core::integer::U128MulGuarantee</code></p>
<pre><code class="language-rust">pub extern type U128MulGuarantee</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h1>
<p>Fully qualified path: <code>core::integer::Bitwise</code></p>
<pre><code class="language-rust">pub extern type Bitwise</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8"><a class="header" href="#u8">u8</a></h1>
<p>The 8-bit unsigned integer type.</p>
<p>Fully qualified path: <code>core::integer::u8</code></p>
<pre><code class="language-rust">pub extern type u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16"><a class="header" href="#u16">u16</a></h1>
<p>The 16-bit unsigned integer type.</p>
<p>Fully qualified path: <code>core::integer::u16</code></p>
<pre><code class="language-rust">pub extern type u16</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32"><a class="header" href="#u32">u32</a></h1>
<p>The 32-bit unsigned integer type.</p>
<p>Fully qualified path: <code>core::integer::u32</code></p>
<pre><code class="language-rust">pub extern type u32</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64"><a class="header" href="#u64">u64</a></h1>
<p>The 64-bit unsigned integer type.</p>
<p>Fully qualified path: <code>core::integer::u64</code></p>
<pre><code class="language-rust">pub extern type u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8"><a class="header" href="#i8">i8</a></h1>
<p>The 8-bit signed integer type.</p>
<p>Fully qualified path: <code>core::integer::i8</code></p>
<pre><code class="language-rust">pub extern type i8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16"><a class="header" href="#i16">i16</a></h1>
<p>The 16-bit signed integer type.</p>
<p>Fully qualified path: <code>core::integer::i16</code></p>
<pre><code class="language-rust">pub extern type i16</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32"><a class="header" href="#i32">i32</a></h1>
<p>The 32-bit signed integer type.</p>
<p>Fully qualified path: <code>core::integer::i32</code></p>
<pre><code class="language-rust">pub extern type i32</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64"><a class="header" href="#i64">i64</a></h1>
<p>The 64-bit signed integer type.</p>
<p>Fully qualified path: <code>core::integer::i64</code></p>
<pre><code class="language-rust">pub extern type i64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128"><a class="header" href="#i128">i128</a></h1>
<p>The 128-bit signed integer type.</p>
<p>Fully qualified path: <code>core::integer::i128</code></p>
<pre><code class="language-rust">pub extern type i128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtincosts"><a class="header" href="#builtincosts">BuiltinCosts</a></h1>
<p>Type representing the table of the costs of the different builtin usages.</p>
<p>Fully qualified path: <code>core::gas::BuiltinCosts</code></p>
<pre><code class="language-rust">#[cfg(not(gas: &quot;disabled&quot;))]
pub extern type BuiltinCosts</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasbuiltin"><a class="header" href="#gasbuiltin">GasBuiltin</a></h1>
<p>The gas builtin. This type is used to handle gas in the Cairo code. Contains the amount of gas available for the current run.</p>
<p>Fully qualified path: <code>core::gas::GasBuiltin</code></p>
<pre><code class="language-rust">pub extern type GasBuiltin</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-1"><a class="header" href="#pedersen-1">pedersen</a></h1>
<p>Fully qualified path: <code>core::pedersen::pedersen</code></p>
<pre><code class="language-rust">pub extern fn pedersen(a: felt252, b: felt252) -&gt; felt252 implicits(Pedersen) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-1"><a class="header" href="#poseidon-1">Poseidon</a></h1>
<p>Fully qualified path: <code>core::poseidon::Poseidon</code></p>
<pre><code class="language-rust">pub extern type Poseidon</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system"><a class="header" href="#system">System</a></h1>
<p>Fully qualified path: <code>core::starknet::System</code></p>
<pre><code class="language-rust">pub extern type System</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaddress"><a class="header" href="#storageaddress">StorageAddress</a></h1>
<p>Represents the address of a storage value in a Starknet contract. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageAddress</code></p>
<pre><code class="language-rust">pub extern type StorageAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddress"><a class="header" href="#contractaddress">ContractAddress</a></h1>
<p>Represents a Starknet contract address. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddress</code></p>
<pre><code class="language-rust">pub extern type ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhash"><a class="header" href="#classhash">ClassHash</a></h1>
<p>Represents a Starknet contract class hash. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHash</code></p>
<pre><code class="language-rust">pub extern type ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaddress-1"><a class="header" href="#storageaddress-1">StorageAddress</a></h1>
<p>Represents the address of a storage value in a Starknet contract. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageAddress</code></p>
<pre><code class="language-rust">pub extern type StorageAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagebaseaddress"><a class="header" href="#storagebaseaddress">StorageBaseAddress</a></h1>
<p>Represents a base storage address that can be combined with offsets. The value range of this type is <code>[0, 2**251 - 256)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageBaseAddress</code></p>
<pre><code class="language-rust">pub extern type StorageBaseAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddress-1"><a class="header" href="#contractaddress-1">ContractAddress</a></h1>
<p>Represents a Starknet contract address. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddress</code></p>
<pre><code class="language-rust">pub extern type ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1point"><a class="header" href="#secp256k1point">Secp256k1Point</a></h1>
<p>A point on the secp256k1 curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Point</code></p>
<pre><code class="language-rust">pub extern type Secp256k1Point</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1point"><a class="header" href="#secp256r1point">Secp256r1Point</a></h1>
<p>Represents a point on the secp256r1 elliptic curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Point</code></p>
<pre><code class="language-rust">pub extern type Secp256r1Point</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhash-1"><a class="header" href="#classhash-1">ClassHash</a></h1>
<p>Represents a Starknet contract class hash. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHash</code></p>
<pre><code class="language-rust">pub extern type ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonzero"><a class="header" href="#nonzero">NonZero</a></h1>
<p>A wrapper type for non-zero values of type T.This type guarantees that the wrapped value is never zero.</p>
<p>Fully qualified path: <code>core::zeroable::NonZero</code></p>
<pre><code class="language-rust">pub extern type NonZero&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31"><a class="header" href="#bytes31">bytes31</a></h1>
<p>Represents a 31-byte fixed-size byte type.</p>
<p>Fully qualified path: <code>core::bytes_31::bytes31</code></p>
<pre><code class="language-rust">pub extern type bytes31</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-functions-17"><a class="header" href="#extern-functions-17">Extern functions</a></h1>
<ul>
<li>
<p><a href="./core-felt252_div.html">felt252_div</a></p>
</li>
<li>
<p><a href="./core-blake-blake2s_compress.html">blake2s_compress</a></p>
</li>
<li>
<p><a href="./core-blake-blake2s_finalize.html">blake2s_finalize</a></p>
</li>
<li>
<p><a href="./core-nullable-null.html">null</a></p>
</li>
<li>
<p><a href="./core-nullable-match_nullable.html">match_nullable</a></p>
</li>
<li>
<p><a href="./core-ec-ec_point_unwrap.html">ec_point_unwrap</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_add.html">u128_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_sub.html">u128_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_sqrt.html">u128_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u128_safe_divmod.html">u128_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u128_byte_reverse.html">u128_byte_reverse</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_add.html">u8_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_sub.html">u8_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wide_mul.html">u8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_sqrt.html">u8_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u8_safe_divmod.html">u8_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_add.html">u16_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_sub.html">u16_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wide_mul.html">u16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u16_sqrt.html">u16_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u16_safe_divmod.html">u16_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_add.html">u32_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_sub.html">u32_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wide_mul.html">u32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u32_sqrt.html">u32_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u32_safe_divmod.html">u32_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_add.html">u64_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_sub.html">u64_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wide_mul.html">u64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u64_sqrt.html">u64_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u64_safe_divmod.html">u64_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u256_sqrt.html">u256_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-i8_wide_mul.html">i8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i8_diff.html">i8_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i16_wide_mul.html">i16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i16_diff.html">i16_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i32_wide_mul.html">i32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i32_diff.html">i32_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i64_wide_mul.html">i64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i64_diff.html">i64_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i128_diff.html">i128_diff</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas.html">withdraw_gas</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas_all.html">withdraw_gas_all</a></p>
</li>
<li>
<p><a href="./core-gas-redeposit_gas.html">redeposit_gas</a></p>
</li>
<li>
<p><a href="./core-gas-get_builtin_costs.html">get_builtin_costs</a></p>
</li>
<li>
<p><a href="./core-panics-panic.html">panic</a></p>
</li>
<li>
<p><a href="./core-pedersen-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon-hades_permutation.html">hades_permutation</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_const.html">starknet::contract_address::contract_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_const.html">storage_base_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_from_felt252.html">storage_base_address_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base_and_offset.html">storage_address_from_base_and_offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base.html">storage_address_from_base</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-call_contract_syscall.html">call_contract_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-deploy_syscall.html">deploy_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-emit_event_syscall.html">emit_event_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_block_hash_syscall.html">get_block_hash_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_syscall.html">get_execution_info_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_v2_syscall.html">get_execution_info_v2_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-library_call_syscall.html">library_call_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-send_message_to_l1_syscall.html">send_message_to_l1_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_read_syscall.html">storage_read_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_write_syscall.html">storage_write_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-replace_class_syscall.html">replace_class_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_class_hash_at_syscall.html">get_class_hash_at_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-keccak_syscall.html">keccak_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-sha256_process_block_syscall.html">sha256_process_block_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_const.html">starknet::contract_address::contract_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_const.html">class_hash_const</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-cheatcode.html">cheatcode</a></p>
</li>
<li>
<p><a href="./core-internal-revoke_ap_tracking.html">revoke_ap_tracking</a></p>
</li>
<li>
<p><a href="./core-internal-require_implicit.html">require_implicit</a></p>
</li>
<li>
<p><a href="./core-testing-get_available_gas.html">get_available_gas</a></p>
</li>
<li>
<p><a href="./core-testing-get_unspent_gas.html">get_unspent_gas</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_div"><a class="header" href="#felt252_div">felt252_div</a></h1>
<p>Performs division on <code>felt252</code> values in Cairo's finite field. Unlike regular integer division, <code>felt252</code> division returns a field element n that satisfies the equation: n * rhs â‰¡ lhs (mod P), where P is the <code>felt252</code> prime.  # Examples</p>
<pre><code class="language-cairo">use core::felt252_div;

// Division with 0 remainder works the same way as integer division.
assert!(felt252_div(4, 2) == 2);

// Division with non 0 remainder returns a field element n where n * 3 â‰¡ 4 (mod P)
assert!(felt252_div(4, 3) ==
1206167596222043737899107594365023368541035738443865566657697352045290673495);

</code></pre>
<p>Fully qualified path: <code>core::felt252_div</code></p>
<pre><code class="language-rust">pub extern fn felt252_div(lhs: felt252, rhs: NonZero&lt;felt252&gt;) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blake2s_compress"><a class="header" href="#blake2s_compress">blake2s_compress</a></h1>
<p>The blake2s compress function, which takes a state, a byte count, and a message, and returns a new state. <code>byte_count</code> should be the total number of bytes hashed after hashing the current <code>msg</code>.</p>
<p>Fully qualified path: <code>core::blake::blake2s_compress</code></p>
<pre><code class="language-rust">pub extern fn blake2s_compress(
    state: Blake2sState, byte_count: u32, msg: Blake2sInput,
) -&gt; Blake2sState nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blake2s_finalize"><a class="header" href="#blake2s_finalize">blake2s_finalize</a></h1>
<p>Similar to <code>blake2s_compress</code>, but used for the final block of the message.</p>
<p>Fully qualified path: <code>core::blake::blake2s_finalize</code></p>
<pre><code class="language-rust">pub extern fn blake2s_finalize(
    state: Blake2sState, byte_count: u32, msg: Blake2sInput,
) -&gt; Blake2sState nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-1"><a class="header" href="#null-1">null</a></h1>
<p>Fully qualified path: <code>core::nullable::null</code></p>
<pre><code class="language-rust">pub extern fn null&lt;T&gt;() -&gt; Nullable&lt;T&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match_nullable"><a class="header" href="#match_nullable">match_nullable</a></h1>
<p>Fully qualified path: <code>core::nullable::match_nullable</code></p>
<pre><code class="language-rust">pub extern fn match_nullable&lt;T&gt;(value: Nullable&lt;T&gt;) -&gt; FromNullableResult&lt;T&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec_point_unwrap"><a class="header" href="#ec_point_unwrap">ec_point_unwrap</a></h1>
<p>Unwraps a non-zero point into its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::ec_point_unwrap</code></p>
<pre><code class="language-rust">pub extern fn ec_point_unwrap(p: NonZeroEcPoint) -&gt; (felt252, felt252) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_add"><a class="header" href="#u128_overflowing_add">u128_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u128_overflowing_add(
    lhs: u128, rhs: u128,
) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_sub"><a class="header" href="#u128_overflowing_sub">u128_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u128_overflowing_sub(
    lhs: u128, rhs: u128,
) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_sqrt"><a class="header" href="#u128_sqrt">u128_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u128_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u128_sqrt(value: u128) -&gt; u64 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_safe_divmod"><a class="header" href="#u128_safe_divmod">u128_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u128_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u128_safe_divmod(
    lhs: u128, rhs: NonZero&lt;u128&gt;,
) -&gt; (u128, u128) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_byte_reverse"><a class="header" href="#u128_byte_reverse">u128_byte_reverse</a></h1>
<p>Fully qualified path: <code>core::integer::u128_byte_reverse</code></p>
<pre><code class="language-rust">pub extern fn u128_byte_reverse(input: u128) -&gt; u128 implicits(Bitwise) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_overflowing_add"><a class="header" href="#u8_overflowing_add">u8_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u8_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u8_overflowing_add(lhs: u8, rhs: u8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_overflowing_sub"><a class="header" href="#u8_overflowing_sub">u8_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u8_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u8_overflowing_sub(lhs: u8, rhs: u8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wide_mul"><a class="header" href="#u8_wide_mul">u8_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u8_wide_mul(lhs: u8, rhs: u8) -&gt; u16 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_sqrt"><a class="header" href="#u8_sqrt">u8_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u8_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u8_sqrt(value: u8) -&gt; u8 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_safe_divmod"><a class="header" href="#u8_safe_divmod">u8_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u8_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u8_safe_divmod(lhs: u8, rhs: NonZero&lt;u8&gt;) -&gt; (u8, u8) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_overflowing_add"><a class="header" href="#u16_overflowing_add">u16_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u16_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u16_overflowing_add(
    lhs: u16, rhs: u16,
) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_overflowing_sub"><a class="header" href="#u16_overflowing_sub">u16_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u16_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u16_overflowing_sub(
    lhs: u16, rhs: u16,
) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wide_mul"><a class="header" href="#u16_wide_mul">u16_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u16_wide_mul(lhs: u16, rhs: u16) -&gt; u32 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_sqrt"><a class="header" href="#u16_sqrt">u16_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u16_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u16_sqrt(value: u16) -&gt; u8 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_safe_divmod"><a class="header" href="#u16_safe_divmod">u16_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u16_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u16_safe_divmod(
    lhs: u16, rhs: NonZero&lt;u16&gt;,
) -&gt; (u16, u16) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_overflowing_add"><a class="header" href="#u32_overflowing_add">u32_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u32_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u32_overflowing_add(
    lhs: u32, rhs: u32,
) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_overflowing_sub"><a class="header" href="#u32_overflowing_sub">u32_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u32_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u32_overflowing_sub(
    lhs: u32, rhs: u32,
) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wide_mul"><a class="header" href="#u32_wide_mul">u32_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u32_wide_mul(lhs: u32, rhs: u32) -&gt; u64 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_sqrt"><a class="header" href="#u32_sqrt">u32_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u32_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u32_sqrt(value: u32) -&gt; u16 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_safe_divmod"><a class="header" href="#u32_safe_divmod">u32_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u32_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u32_safe_divmod(
    lhs: u32, rhs: NonZero&lt;u32&gt;,
) -&gt; (u32, u32) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_overflowing_add"><a class="header" href="#u64_overflowing_add">u64_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u64_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u64_overflowing_add(
    lhs: u64, rhs: u64,
) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_overflowing_sub"><a class="header" href="#u64_overflowing_sub">u64_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u64_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u64_overflowing_sub(
    lhs: u64, rhs: u64,
) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wide_mul"><a class="header" href="#u64_wide_mul">u64_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u64_wide_mul(lhs: u64, rhs: u64) -&gt; u128 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_sqrt"><a class="header" href="#u64_sqrt">u64_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u64_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u64_sqrt(value: u64) -&gt; u32 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_safe_divmod"><a class="header" href="#u64_safe_divmod">u64_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u64_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u64_safe_divmod(
    lhs: u64, rhs: NonZero&lt;u64&gt;,
) -&gt; (u64, u64) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_sqrt"><a class="header" href="#u256_sqrt">u256_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u256_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u256_sqrt(a: u256) -&gt; u128 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8_wide_mul"><a class="header" href="#i8_wide_mul">i8_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i8_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i8_wide_mul(lhs: i8, rhs: i8) -&gt; i16 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8_diff"><a class="header" href="#i8_diff">i8_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**8 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i8_diff</code></p>
<pre><code class="language-rust">pub extern fn i8_diff(lhs: i8, rhs: i8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16_wide_mul"><a class="header" href="#i16_wide_mul">i16_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i16_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i16_wide_mul(lhs: i16, rhs: i16) -&gt; i32 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16_diff"><a class="header" href="#i16_diff">i16_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**16 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i16_diff</code></p>
<pre><code class="language-rust">pub extern fn i16_diff(lhs: i16, rhs: i16) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32_wide_mul"><a class="header" href="#i32_wide_mul">i32_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i32_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i32_wide_mul(lhs: i32, rhs: i32) -&gt; i64 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32_diff"><a class="header" href="#i32_diff">i32_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**32 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i32_diff</code></p>
<pre><code class="language-rust">pub extern fn i32_diff(lhs: i32, rhs: i32) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64_wide_mul"><a class="header" href="#i64_wide_mul">i64_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i64_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i64_wide_mul(lhs: i64, rhs: i64) -&gt; i128 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64_diff"><a class="header" href="#i64_diff">i64_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**64 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i64_diff</code></p>
<pre><code class="language-rust">pub extern fn i64_diff(lhs: i64, rhs: i64) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128_diff"><a class="header" href="#i128_diff">i128_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**128 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i128_diff</code></p>
<pre><code class="language-rust">pub extern fn i128_diff(lhs: i128, rhs: i128) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdraw_gas"><a class="header" href="#withdraw_gas">withdraw_gas</a></h1>
<p>Withdraws gas from the <code>GasBuiltin</code> to handle the success case flow. Returns <code>Some(())</code> if there is sufficient gas to handle the success case, otherwise returns <code>None</code>.  # Examples</p>
<pre><code class="language-cairo">// The success branch is the following lines, the failure branch is the `panic` caused by the
// `unwrap` call.
withdraw_gas().unwrap();
</code></pre>
<pre><code class="language-cairo">// Direct handling of `withdraw_gas`.
match withdraw_gas() {
    Some(()) =&gt; success_case(),
    None =&gt; cheap_not_enough_gas_case(),
}
</code></pre>
<p>Fully qualified path: <code>core::gas::withdraw_gas</code></p>
<pre><code class="language-rust">pub extern fn withdraw_gas() -&gt; Option&lt;()&gt; implicits(RangeCheck, GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdraw_gas_all"><a class="header" href="#withdraw_gas_all">withdraw_gas_all</a></h1>
<p>Same as <code>withdraw_gas</code>, but directly receives <code>BuiltinCosts</code>, which enables optimizations by removing the need for repeated internal calls for fetching the table of constants that may internally happen in calls to <code>withdraw_gas</code>. Should be used with caution.</p>
<p>Fully qualified path: <code>core::gas::withdraw_gas_all</code></p>
<pre><code class="language-rust">pub extern fn withdraw_gas_all(
    costs: BuiltinCosts,
) -&gt; Option&lt;()&gt; implicits(RangeCheck, GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redeposit_gas"><a class="header" href="#redeposit_gas">redeposit_gas</a></h1>
<p>Returns unused gas into the gas builtin.Useful for cases where different branches take different amounts of gas, but gas withdrawal is the same for both.</p>
<p>Fully qualified path: <code>core::gas::redeposit_gas</code></p>
<pre><code class="language-rust">pub extern fn redeposit_gas() implicits(GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_builtin_costs"><a class="header" href="#get_builtin_costs">get_builtin_costs</a></h1>
<p>Returns the <code>BuiltinCosts</code> table to be used in <code>withdraw_gas_all</code>.</p>
<p>Fully qualified path: <code>core::gas::get_builtin_costs</code></p>
<pre><code class="language-rust">pub extern fn get_builtin_costs() -&gt; BuiltinCosts nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1">panic</a></h1>
<p>Triggers an immediate panic with the provided data and terminates execution.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic</code></p>
<pre><code class="language-rust">pub extern fn panic(data: Array&lt;felt252&gt;) -&gt; crate::never;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-2"><a class="header" href="#pedersen-2">pedersen</a></h1>
<p>Fully qualified path: <code>core::pedersen::pedersen</code></p>
<pre><code class="language-rust">pub extern fn pedersen(a: felt252, b: felt252) -&gt; felt252 implicits(Pedersen) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hades_permutation"><a class="header" href="#hades_permutation">hades_permutation</a></h1>
<p>Fully qualified path: <code>core::poseidon::hades_permutation</code></p>
<pre><code class="language-rust">pub extern fn hades_permutation(
    s0: felt252, s1: felt252, s2: felt252,
) -&gt; (felt252, felt252, felt252) implicits(Poseidon) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_const"><a class="header" href="#contract_address_const">contract_address_const</a></h1>
<p>Returns a <code>ContractAddress</code> given a <code>felt252</code> value.  # Examples</p>
<pre><code class="language-cairo">use starknet::contract_address::contract_address_const;

let contract_address = contract_address_const::&lt;0x0&gt;();
</code></pre>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_const</code></p>
<pre><code class="language-rust">pub extern fn contract_address_const&lt;const address: felt252&gt;() -&gt; ContractAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_base_address_const"><a class="header" href="#storage_base_address_const">storage_base_address_const</a></h1>
<p>Returns a <code>StorageBaseAddress</code> given a constant <code>felt252</code> value.The value is validated to be in the range <code>[0, 2**251 - 256)</code> at compile time.  # Examples</p>
<pre><code class="language-cairo">use starknet::storage_access::storage_base_address_const;

let base_address = storage_base_address_const::&lt;0&gt;();
</code></pre>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_base_address_const</code></p>
<pre><code class="language-rust">pub extern fn storage_base_address_const&lt;const address: felt252&gt;() -&gt; StorageBaseAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_base_address_from_felt252"><a class="header" href="#storage_base_address_from_felt252">storage_base_address_from_felt252</a></h1>
<p>Returns a <code>StorageBaseAddress</code> given a <code>felt252</code> value.Wraps around the value if it is not in the range <code>[0, 2**251 - 256)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_base_address_from_felt252</code></p>
<pre><code class="language-rust">pub extern fn storage_base_address_from_felt252(
    addr: felt252,
) -&gt; StorageBaseAddress implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_from_base_and_offset"><a class="header" href="#storage_address_from_base_and_offset">storage_address_from_base_and_offset</a></h1>
<p>Sums the base address and the offset to return a storage address.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_from_base_and_offset</code></p>
<pre><code class="language-rust">pub extern fn storage_address_from_base_and_offset(
    base: StorageBaseAddress, offset: u8,
) -&gt; StorageAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_from_base"><a class="header" href="#storage_address_from_base">storage_address_from_base</a></h1>
<p>Converts a <code>StorageBaseAddress</code> into a <code>StorageAddress</code>.This should be used through the high-level <code>Into</code> trait.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_from_base</code></p>
<pre><code class="language-rust">pub extern fn storage_address_from_base(base: StorageBaseAddress) -&gt; StorageAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call_contract_syscall"><a class="header" href="#call_contract_syscall">call_contract_syscall</a></h1>
<p>Calls a given contract.  # Arguments<code>address</code> - The address of the called contract. * <code>entry_point_selector</code> - A selector for a function within that contract. * <code>calldata</code> - Call arguments.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::call_contract_syscall</code></p>
<pre><code class="language-rust">pub extern fn call_contract_syscall(
    address: ContractAddress, entry_point_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy_syscall"><a class="header" href="#deploy_syscall">deploy_syscall</a></h1>
<p>Deploys a new instance of a previously declared class.  # Arguments<code>class_hash</code> - The class hash of the contract to be deployed. * <code>contract_address_salt</code> - The salt, an arbitrary value provided by the deployer, used in the computation of the contract's address. * <code>calldata</code> - Call arguments for the constructor. * <code>deploy_from_zero</code> - Deploy the contract from the zero address.  # ReturnsThe address of the deployed contract. * The serialized return value of the constructor.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::deploy_syscall</code></p>
<pre><code class="language-rust">pub extern fn deploy_syscall(
    class_hash: ClassHash,
    contract_address_salt: felt252,
    calldata: Span&lt;felt252&gt;,
    deploy_from_zero: bool,
) -&gt; SyscallResult&lt;(ContractAddress, Span&lt;felt252&gt;)&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emit_event_syscall"><a class="header" href="#emit_event_syscall">emit_event_syscall</a></h1>
<p>Emits an event.  # Arguments<code>keys</code> - The keys of the event. * <code>data</code> - The data of the event.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::emit_event_syscall</code></p>
<pre><code class="language-rust">pub extern fn emit_event_syscall(
    keys: Span&lt;felt252&gt;, data: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_hash_syscall"><a class="header" href="#get_block_hash_syscall">get_block_hash_syscall</a></h1>
<p>Returns the hash of the block with the given number.  # Arguments<code>block_number</code> - The number of the queried block.  # ReturnsThe hash of the block with the given number.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_block_hash_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_block_hash_syscall(
    block_number: u64,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info_syscall"><a class="header" href="#get_execution_info_syscall">get_execution_info_syscall</a></h1>
<p>Gets information about the currently executing block and the transactions in the block. For a complete description of this information, see [<code>Execution information</code>](<code>Execution information</code>).When an accountâ€™s <code>__validate__</code>, <code>__validate_deploy__</code>, or <code>__validate_declare__</code> function calls <code>get_execution_info</code>, the return values for <code>block_timestamp</code> and <code>block_number</code> are modified as follows: * <code>block_timestamp</code> returns the hour, rounded down to the nearest hour. * <code>block_number</code> returns the block number, rounded down to the nearest multiple of 100.  # ReturnsA struct that contains information about the currently executing function, transaction, and block.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_execution_info_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_execution_info_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info_v2_syscall"><a class="header" href="#get_execution_info_v2_syscall">get_execution_info_v2_syscall</a></h1>
<p>Gets information about the current execution, version 2. This syscall should not be called directly. Instead, use <code>starknet::info::get_execution_info</code>.  # ReturnsA box containing the current V2 execution information.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_execution_info_v2_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_execution_info_v2_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::v2::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library_call_syscall"><a class="header" href="#library_call_syscall">library_call_syscall</a></h1>
<p>Calls the requested function in any previously declared class.  # Arguments<code>class_hash</code> - The hash of the class to be used. * <code>function_selector</code> - A selector for a function within that class. * <code>calldata</code> - Call arguments.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::library_call_syscall</code></p>
<pre><code class="language-rust">pub extern fn library_call_syscall(
    class_hash: ClassHash, function_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send_message_to_l1_syscall"><a class="header" href="#send_message_to_l1_syscall">send_message_to_l1_syscall</a></h1>
<p>Sends a message to L1.  # Arguments<code>to_address</code> - The recipient's L1 address. * <code>payload</code> - The content of the message.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::send_message_to_l1_syscall</code></p>
<pre><code class="language-rust">pub extern fn send_message_to_l1_syscall(
    to_address: felt252, payload: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_read_syscall"><a class="header" href="#storage_read_syscall">storage_read_syscall</a></h1>
<p>Gets the value of a key in the storage of the calling contract.  # Arguments<code>address_domain</code> - The domain of the address. Only <code>address_domain</code> 0 is currently supported, in the future it will enable access to address spaces with different data availability guarantees. * <code>address</code> - The address of the storage key to read.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::storage_read_syscall</code></p>
<pre><code class="language-rust">pub extern fn storage_read_syscall(
    address_domain: u32, address: StorageAddress,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_write_syscall"><a class="header" href="#storage_write_syscall">storage_write_syscall</a></h1>
<p>Sets the value of a key in the storage of the calling contract.  # Arguments<code>address_domain</code> - The domain of the address. Only <code>address_domain</code> 0 is currently supported, in the future it will enable access to address spaces with different data availability guarantees. * <code>address</code> - The address of the storage key to write. * <code>value</code> - The value to write to the key.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::storage_write_syscall</code></p>
<pre><code class="language-rust">pub extern fn storage_write_syscall(
    address_domain: u32, address: StorageAddress, value: felt252,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replace_class_syscall"><a class="header" href="#replace_class_syscall">replace_class_syscall</a></h1>
<p>Replaces the class hash of the current contract, instantly modifying its entrypoints.The new class becomes effective only after the current function call completes. The remaining code in the current function will continue executing from the old class. The new class will be used: * In subsequent transactions * If the contract is called via <code>call_contract</code> syscall later in the same transaction  # Arguments<code>class_hash</code> - The class hash that should replace the current one.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::replace_class_syscall</code></p>
<pre><code class="language-rust">pub extern fn replace_class_syscall(
    class_hash: ClassHash,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_class_hash_at_syscall"><a class="header" href="#get_class_hash_at_syscall">get_class_hash_at_syscall</a></h1>
<p>Gets the class hash of the contract at the given address.  # Arguments<code>contract_address</code> - The address of the deployed contract.  # ReturnsThe class hash of the contract's originating code.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_class_hash_at_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_class_hash_at_syscall(
    contract_address: ContractAddress,
) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_syscall"><a class="header" href="#keccak_syscall">keccak_syscall</a></h1>
<p>Computes the keccak of the input.The input must be a multiple of 1088 bits (== 17 u64 words) * The input must be pre-padded following the Keccak padding rule (pad10*1): 1. Add a '1' bit 2. Add zero or more '0' bits 3. Add a final '1' bit The total length after padding must be a multiple of 1088 bits  # Arguments<code>input</code> - Array of 64-bit words (little endian) to be hashed.  # ReturnsThe keccak hash as a little-endian u256</p>
<p>Fully qualified path: <code>core::starknet::syscalls::keccak_syscall</code></p>
<pre><code class="language-rust">pub extern fn keccak_syscall(
    input: Span&lt;u64&gt;,
) -&gt; SyscallResult&lt;u256&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256_process_block_syscall"><a class="header" href="#sha256_process_block_syscall">sha256_process_block_syscall</a></h1>
<p>Computes the next SHA-256 state of the input with the given state.  # Arguments<code>state</code> - The current SHA-256 state. * <code>input</code> - The input provided to compute the next SHA-256 state.  # ReturnsThe next SHA-256 state of the input with the givens state.The system call does not add any padding and the input needs to be a multiple of 512 bits (== 16 u32 word).</p>
<p>Fully qualified path: <code>core::starknet::syscalls::sha256_process_block_syscall</code></p>
<pre><code class="language-rust">pub extern fn sha256_process_block_syscall(
    state: core::sha256::Sha256StateHandle, input: Box&lt;[u32; 16]&gt;,
) -&gt; SyscallResult&lt;core::sha256::Sha256StateHandle&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_const-1"><a class="header" href="#contract_address_const-1">contract_address_const</a></h1>
<p>Returns a <code>ContractAddress</code> given a <code>felt252</code> value.  # Examples</p>
<pre><code class="language-cairo">use starknet::contract_address::contract_address_const;

let contract_address = contract_address_const::&lt;0x0&gt;();
</code></pre>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_const</code></p>
<pre><code class="language-rust">pub extern fn contract_address_const&lt;const address: felt252&gt;() -&gt; ContractAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash_const"><a class="header" href="#class_hash_const">class_hash_const</a></h1>
<p>Returns a <code>ClassHash</code> given a <code>felt252</code> value.  # Examples</p>
<pre><code class="language-cairo">use starknet::class_hash::class_hash_const;

let class_hash = class_hash_const::&lt;0x123&gt;();
</code></pre>
<p>Fully qualified path: <code>core::starknet::class_hash::class_hash_const</code></p>
<pre><code class="language-rust">pub extern fn class_hash_const&lt;const address: felt252&gt;() -&gt; ClassHash nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cheatcode"><a class="header" href="#cheatcode">cheatcode</a></h1>
<p>A general cheatcode function used to simplify implementation of Starknet testing functions.This is the base function used by testing utilities to interact with the test environment. External users can implement custom cheatcodes by injecting a custom <code>CairoHintProcessor</code> in the runner.  # Arguments<code>selector</code> - The cheatcode identifier. <code>input</code> - Input parameters for the cheatcode.  # ReturnsA span containing the cheatcode's output</p>
<p>Fully qualified path: <code>core::starknet::testing::cheatcode</code></p>
<pre><code class="language-rust">pub extern fn cheatcode&lt;const selector: felt252&gt;(
    input: Span&lt;felt252&gt;,
) -&gt; Span&lt;felt252&gt; implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revoke_ap_tracking"><a class="header" href="#revoke_ap_tracking">revoke_ap_tracking</a></h1>
<p>Fully qualified path: <code>core::internal::revoke_ap_tracking</code></p>
<pre><code class="language-rust">pub extern fn revoke_ap_tracking() implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="require_implicit"><a class="header" href="#require_implicit">require_implicit</a></h1>
<p>Function to enforce that <code>Implicit</code> is used by a function calling it. Note: This extern function is not mapped to a Sierra function, and all usages of it are removed during compilation.</p>
<p>Fully qualified path: <code>core::internal::require_implicit</code></p>
<pre><code class="language-rust">pub extern fn require_implicit&lt;Implicit&gt;() implicits(Implicit) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_available_gas"><a class="header" href="#get_available_gas">get_available_gas</a></h1>
<p>Returns the amount of gas available in the <code>GasBuiltin</code>.Useful for asserting that a certain amount of gas was consumed. Note: The actual gas consumption observed by calls to <code>get_available_gas</code> is only exact immediately before calls to <code>withdraw_gas</code>.  # Examples</p>
<pre><code class="language-cairo">use core::testing::get_available_gas;

fn gas_heavy_function() {
    // ... some gas-intensive code
}

fn test_gas_consumption() {
    let gas_before = get_available_gas();
    // Making sure `gas_before` is exact.
    core::gas::withdraw_gas().unwrap();

    gas_heavy_function();

    let gas_after = get_available_gas();
    // Making sure `gas_after` is exact
    core::gas::withdraw_gas().unwrap();

    assert!(gas_after - gas_before &lt; 100_000);
}
</code></pre>
<p>Fully qualified path: <code>core::testing::get_available_gas</code></p>
<pre><code class="language-rust">pub extern fn get_available_gas() -&gt; u128 implicits(GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_unspent_gas"><a class="header" href="#get_unspent_gas">get_unspent_gas</a></h1>
<p>Returns the amount of gas available in the <code>GasBuiltin</code>, as well as the amount of gas unused in the local wallet.Useful for asserting that a certain amount of gas used. Note: This function call costs exactly <code>2300</code> gas, so this may be ignored in calculations. # Examples</p>
<pre><code class="language-cairo">use core::testing::get_unspent_gas;

fn gas_heavy_function() {
    // ... some gas-intensive code
}

fn test_gas_consumption() {
    let gas_before = get_unspent_gas();
    gas_heavy_function();
    let gas_after = get_unspent_gas();
    assert!(gas_after - gas_before &lt; 100_000);
}
</code></pre>
<p>Fully qualified path: <code>core::testing::get_unspent_gas</code></p>
<pre><code class="language-rust">pub extern fn get_unspent_gas() -&gt; u128 implicits(GasBuiltin) nopanic;</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
